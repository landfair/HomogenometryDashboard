<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Homogenometry Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Montserrat', sans-serif;
            background: #f8f9fa;
            color: #2d2d2d;
            padding: 0;
            line-height: 1.7;
        }
        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background-color: white;
            border-bottom: 3px solid #57068c;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            padding: 0 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }
        .logo img {
            height: 60px;
            width: auto;
        }
        .header-title {
            color: #57068c;
            font-weight: 600;
            font-size: 1.4rem;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            letter-spacing: 0.5px;
        }
        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-left: auto;
            position: relative;
            z-index: 9999;
        }
        .header-menu {
            position: relative;
        }
        .menu-trigger {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            font-size: 1.5rem;
            color: #57068c;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        .menu-trigger:hover {
            background-color: #f0e6ff;
        }
        .header-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 200px;
            display: none;
            z-index: 10000;
            margin-top: 8px;
        }
        .header-dropdown.show {
            display: block;
        }
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            color: #2d2d2d;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-family: 'Montserrat', sans-serif;
        }
        .dropdown-item:first-child {
            border-radius: 8px 8px 0 0;
        }
        .dropdown-item:last-child {
            border-radius: 0 0 8px 8px;
        }
        .dropdown-item:hover {
            background-color: #f0e6ff;
            color: #57068c;
        }
        .dropdown-item i {
            width: 16px;
            color: #57068c;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 90px 20px 20px;
        }
        h1 {
            text-align: center;
            color: #57068c;
            margin-bottom: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .file-input {
            display: none;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            display: none;
        }
        .dashboard {
            display: none;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .metric-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        .panel-header {
            background: #57068c;
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            font-size: 16px;
            letter-spacing: 0.3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-info {
            font-size: 12px;
            opacity: 0.9;
            font-weight: normal;
        }
        .panel-content {
            padding: 20px;
        }
        .metric-item {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .metric-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .metric-name {
            font-weight: 600;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 8px;
        }
        .metric-formula {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #7f8c8d;
            background: #f8f9fa;
            padding: 6px 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            border-left: 3px solid #57068c;
        }
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #57068c;
            margin-bottom: 8px;
        }
        .metric-interpretation {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
        }
        .metric-bar {
            height: 12px;
            background: #ecf0f1;
            border-radius: 6px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        .metric-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        .metric-bar-marker {
            position: absolute;
            top: -5px;
            width: 2px;
            height: 22px;
            background: #57068c;
        }
        .metric-bar-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
        }
        .stat-badge {
            display: inline-block;
            padding: 4px 10px;
            background: #ecf0f1;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 8px;
            margin-top: 5px;
        }
        .stat-badge.warning {
            background: #fff3cd;
            color: #856404;
        }
        .stat-badge.danger {
            background: #f8d7da;
            color: #721c24;
        }
        .stat-badge.success {
            background: #d4edda;
            color: #155724;
        }
        .phrase-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .phrase-item {
            padding: 12px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .phrase-item:hover {
            background: #f8f9fa;
        }
        .phrase-text {
            font-style: italic;
            color: #2c3e50;
            flex: 1;
        }
        .phrase-stats {
            display: flex;
            gap: 10px;
            font-size: 12px;
        }
        .phrase-count {
            background: #57068C;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .phrase-significance {
            background: #e74c3c;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .distribution-viz {
            margin-top: 15px;
        }
        .histogram {
            display: flex;
            align-items: flex-end;
            height: 150px;
            gap: 3px;
            margin: 20px 0;
        }
        .histogram-bar {
            flex: 1;
            background: #57068C;
            border-radius: 3px 3px 0 0;
            min-width: 8px;
            position: relative;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .histogram-bar:hover {
            opacity: 0.7;
        }
        .histogram-bar.highlight {
            background: #e74c3c;
        }
        .histogram-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        .methodology {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #57068C;
        }
        .methodology h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .methodology p {
            font-size: 13px;
            line-height: 1.6;
            color: #555;
        }
        .methodology code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        .export-btn {
            background: #27ae60;
            color: white;
            padding: 10px 20px;
            border: 2px solid #27ae60;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            letter-spacing: 0.3px;
            margin-top: 10px;
            transition: all 0.2s ease;
        }
        .export-btn:hover {
            background: #229954;
            border-color: #229954;
        }
        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .pattern-chip {
            display: inline-block;
            padding: 6px 12px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 16px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 5px;
        }
        .pattern-chip:hover {
            background: #57068c;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(87,6,140,0.15);
        }
        .pattern-chip .count {
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 6px;
            font-size: 11px;
            font-weight: 600;
        }
        .correlation-result {
            margin-top: 20px;
            padding: 20px;
            background: #fff;
            border: 2px solid #57068c;
            border-radius: 8px;
        }
        .correlation-header {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        .correlation-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .corr-stat {
            background: #ecf0f1;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
        }
        .corr-stat strong {
            color: #e74c3c;
        }
        .respondent-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
        }
        .respondent-chip {
            background: #e74c3c;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .correlation-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .correlation-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }
        .word-correlation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .word-correlation-item:last-child {
            border-bottom: none;
        }
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: white;
            border: none;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.3px;
            color: #7f8c8d;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
        }
        .tab-button:hover {
            background: #f8f9fa;
        }
        .tab-button.active {
            color: #57068c;
            background: #f8f9fa;
            border-bottom: 3px solid #57068c;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .similarity-pair-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }
        .similarity-pair-item:hover {
            background: #f8f9fa;
        }
        .pair-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .pair-ids {
            font-weight: 600;
            color: #2c3e50;
            font-size: 15px;
        }
        .similarity-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
        }
        .similarity-high {
            background: #e74c3c;
            color: white;
        }
        .similarity-medium {
            background: #f39c12;
            color: white;
        }
        .similarity-low {
            background: #27ae60;
            color: white;
        }
        .response-preview {
            font-size: 13px;
            color: #666;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .flagged-respondent-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }
        .flagged-respondent-item:hover {
            background: #f8f9fa;
        }
        .flagged-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .flag-count-badge {
            background: #e74c3c;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        .match-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .match-chip {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .modal-content {
            background: white;
            max-width: 1200px;
            margin: 40px auto;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .modal-header {
            background: #57068C;
            color: white;
            padding: 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            opacity: 0.7;
        }
        .modal-body {
            padding: 25px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .comparison-box {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .comparison-header {
            background: #ecf0f1;
            padding: 10px 15px;
            font-weight: 600;
            color: #2c3e50;
        }
        .comparison-text {
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
        }
        .shared-phrases-box {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }
        .shared-phrases-box h4 {
            margin: 0 0 10px 0;
            color: #856404;
            font-size: 14px;
        }
        .phrase-chip {
            display: inline-block;
            background: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 4px;
            border: 1px solid #ffc107;
        }
        .highlight-match {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .highlight-exact {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
        .highlight-fuzzy {
            background: #ffe0b2;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px dotted #ff9800;
        }
        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            background: #57068C;
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            margin-left: 4px;
            position: relative;
        }
        .info-icon:hover {
            background: #440670;
        }
        .tooltip {
            visibility: hidden;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #57068C;
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #2c3e50;
        }
        .info-icon:hover .tooltip {
            visibility: visible;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Fixed Header -->
    <header class="fixed-header">
        <div class="logo">
            <img src="https://i.imgur.com/HpJ1Z46.png" alt="AI in Education VIP Logo" />
        </div>
        <div class="header-title">The Homogenometry Dashboard</div>
        <div class="header-right">
            <div class="header-menu">
                <button class="menu-trigger" onclick="toggleHeaderMenu()" aria-label="Menu">
                    <i class="fas fa-ellipsis-v"></i>
                </button>
                <div class="header-dropdown" id="header-dropdown">
                    <button class="dropdown-item" onclick="document.getElementById('csvFile').click(); toggleHeaderMenu();">
                        <i class="fas fa-upload"></i> Upload CSV File
                    </button>
                    <button class="dropdown-item" onclick="toggleMetricSettings(); toggleHeaderMenu();">
                        <i class="fas fa-cog"></i> Metric Settings
                    </button>
                    <button class="dropdown-item" onclick="toggleMethodologyModal(); toggleHeaderMenu();">
                        <i class="fas fa-info-circle"></i> About / Methodology
                    </button>
                    <button class="dropdown-item" onclick="clearSession(); toggleHeaderMenu();">
                        <i class="fas fa-trash-alt"></i> Clear Session
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Hidden file input -->
    <input type="file" id="csvFile" class="file-input" accept=".csv" style="display: none;">

    <div class="container">

        <!-- Welcome Screen -->
        <div id="welcomeScreen" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60vh; text-align: center; padding: 40px 20px;">
            <div style="max-width: 600px;">
                <div style="font-size: 72px; margin-bottom: 20px;"></div>
                <h1 style="color: #57068C; font-size: 32px; margin-bottom: 16px; font-weight: 600;">Welcome to The Homogenometry Dashboard</h1>
                <p style="color: #666; font-size: 18px; line-height: 1.6; margin-bottom: 40px;">
                    Analyze corpus-internal homogeneity by measuring pairwise similarity between responses.
                    For detecting unusual convergence in survey responses, essays, homework exercises, or any other corpus of texts. 
                </p>
                <button onclick="document.getElementById('csvFile').click()"
                    style="padding: 16px 40px; background: #57068C; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 18px; box-shadow: 0 4px 12px rgba(87, 6, 140, 0.3); transition: all 0.3s;"
                    onmouseover="this.style.background='#6d0aac'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(87, 6, 140, 0.4)'"
                    onmouseout="this.style.background='#57068C'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(87, 6, 140, 0.3)'">
                    <i class="fas fa-upload"></i> Upload CSV File
                </button>
                <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #57068C; text-align: left;">
                    <h4 style="margin-top: 0; color: #2c3e50; font-size: 16px;">CSV Format Requirements</h4>
                    <ul style="color: #666; font-size: 14px; line-height: 1.8; margin: 10px 0;">
                        <li>First row should contain column headers</li>
                        <li>Include an ID column (e.g., "Respondent ID", "Name", "Email")</li>
                        <li>Include one or more text response columns to analyze</li>
                        <li>UTF-8 encoding recommended for special characters</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="controls" id="controls" style="display: none;">
            <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 25px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600; white-space: nowrap;">Question Column:</label>
                    <select id="columnSelect"></select>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600; white-space: nowrap;">
                        Threshold: <span id="thresholdDisplay" style="color: #e74c3c;">0.60</span>
                    </label>
                    <input type="range" id="similarityThreshold" min="0.30" max="0.95" step="0.05" value="0.60"
                        style="width: 150px; height: 6px;"
                        oninput="updateThreshold(this.value)">
                </div>
                <div>
                    <button onclick="toggleMetricSettings()"
                        style="padding: 8px 16px; background: #57068C; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; white-space: nowrap;">
                        <i class="fas fa-cog"></i> Metric Settings
                    </button>
                </div>
            </div>
        </div>

        <!-- Metric Settings Modal -->
        <div class="modal" id="metricSettings" style="display: none;" onclick="if(event.target===this) toggleMetricSettings()">
            <div class="modal-content" style="max-width: 900px;" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h3 style="margin: 0; color: white;">Similarity Metrics Configuration</h3>
                    <button class="modal-close" onclick="toggleMetricSettings()">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="margin: 0 0 10px 0; font-size: 13px; color: #666;">
                        Select metrics to include in the Combined similarity score and set their weights. Higher weights = more influence on final score.
                    </p>
                    <div style="margin-bottom: 20px; padding: 12px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                        <strong style="color: #1565c0;">Weight Guidelines:</strong>
                        <div style="font-size: 12px; color: #555; margin-top: 5px;">
                            High (3.0+): Strong evidence of copying/paraphrasing (fuzzy matching, n-grams)<br>
                            Medium (1.0): Content similarity (cosine, Jaccard, NER)<br>
                            Low (0.3): Structural similarity (word count, sentence length)
                        </div>
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <!-- Cosine Similarity -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_cosine" checked onchange="toggleMetricWeight('cosine')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Cosine Similarity</strong>
                                <div style="font-size: 12px; color: #666;">Word frequency patterns</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_cosine" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('cosine', this.value)">
                                <span id="weightDisplay_cosine" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Jaccard Index -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_jaccard" checked onchange="toggleMetricWeight('jaccard')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Jaccard Index</strong>
                                <div style="font-size: 12px; color: #666;">Vocabulary overlap</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_jaccard" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('jaccard', this.value)">
                                <span id="weightDisplay_jaccard" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- N-gram Overlap -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngram" checked onchange="toggleMetricWeight('ngram')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram Overlap</strong>
                                <div style="font-size: 12px; color: #666;">Character sequence similarity</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngram" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngram', this.value)">
                                <span id="weightDisplay_ngram" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Sentence Variance -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_sentenceVariance" checked onchange="toggleMetricWeight('sentenceVariance')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Sentence Variance</strong>
                                <div style="font-size: 12px; color: #666;">Similar variation in sentence lengths</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_sentenceVariance" min="0.1" max="5.0" step="0.1" value="0.3"
                                       style="flex: 1;" oninput="updateWeightDisplay('sentenceVariance', this.value)">
                                <span id="weightDisplay_sentenceVariance" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.3</span>
                            </div>
                        </div>

                        <!-- Word Count -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordCount" checked onchange="toggleMetricWeight('wordCount')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Word Count</strong>
                                <div style="font-size: 12px; color: #666;">Similar response length - LOW signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordCount" min="0.1" max="5.0" step="0.1" value="0.3"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordCount', this.value)">
                                <span id="weightDisplay_wordCount" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.3</span>
                            </div>
                        </div>

                        <!-- Avg Sentence Length -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_avgSentenceLength" checked onchange="toggleMetricWeight('avgSentenceLength')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Avg Sentence Length</strong>
                                <div style="font-size: 12px; color: #666;">Similar sentence complexity - LOW signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_avgSentenceLength" min="0.1" max="5.0" step="0.1" value="0.3"
                                       style="flex: 1;" oninput="updateWeightDisplay('avgSentenceLength', this.value)">
                                <span id="weightDisplay_avgSentenceLength" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.3</span>
                            </div>
                        </div>

                        <!-- Temporal Burstiness -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_temporalBurstiness" onchange="toggleMetricWeight('temporalBurstiness')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Temporal Burstiness</strong>
                                <div style="font-size: 12px; color: #666;">Word clustering patterns (Cui et al. 2017) - SLOW</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_temporalBurstiness" min="0.1" max="5.0" step="0.1" value="0.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('temporalBurstiness', this.value)">
                                <span id="weightDisplay_temporalBurstiness" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.5</span>
                            </div>
                        </div>

                        <!-- Pronoun Density -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_pronounDensity" checked onchange="toggleMetricWeight('pronounDensity')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Pronoun Density</strong>
                                <div style="font-size: 12px; color: #666;">First-person usage patterns</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_pronounDensity" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('pronounDensity', this.value)">
                                <span id="weightDisplay_pronounDensity" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Transition Words -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_transitionWords" checked onchange="toggleMetricWeight('transitionWords')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Transition Words</strong>
                                <div style="font-size: 12px; color: #666;">Discourse marker usage</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_transitionWords" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('transitionWords', this.value)">
                                <span id="weightDisplay_transitionWords" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- N-gram with Punctuation -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngramPunctuation" checked onchange="toggleMetricWeight('ngramPunctuation')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram with Punctuation</strong>
                                <div style="font-size: 12px; color: #666;">3-char sequences keeping punctuation</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngramPunctuation" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngramPunctuation', this.value)">
                                <span id="weightDisplay_ngramPunctuation" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- 3-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordNgram" checked onchange="toggleMetricWeight('wordNgram')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>3-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Word-level n-grams - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordNgram" min="0.1" max="5.0" step="0.1" value="2.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordNgram', this.value)">
                                <span id="weightDisplay_wordNgram" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.0</span>
                            </div>
                        </div>

                        <!-- N-gram 4-char -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngram4" checked onchange="toggleMetricWeight('ngram4')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram 4-char</strong>
                                <div style="font-size: 12px; color: #666;">4-character sequences</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngram4" min="0.1" max="5.0" step="0.1" value="1.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngram4', this.value)">
                                <span id="weightDisplay_ngram4" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.5</span>
                            </div>
                        </div>

                        <!-- N-gram 5-char -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngram5" checked onchange="toggleMetricWeight('ngram5')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram 5-char</strong>
                                <div style="font-size: 12px; color: #666;">5-character sequences - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngram5" min="0.1" max="5.0" step="0.1" value="2.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngram5', this.value)">
                                <span id="weightDisplay_ngram5" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.0</span>
                            </div>
                        </div>

                        <!-- Named Entity Recognition -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ner" checked onchange="toggleMetricWeight('ner')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Named Entity Recognition</strong>
                                <div style="font-size: 12px; color: #666;">Extracts all capitalized sequences (proper nouns)</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ner" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ner', this.value)">
                                <span id="weightDisplay_ner" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Fuzzy 3-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_fuzzyNgram3" onchange="toggleMetricWeight('fuzzyNgram3')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Fuzzy 3-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Levenshtein ≤5 edits - catches short paraphrasing - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_fuzzyNgram3" min="0.1" max="5.0" step="0.1" value="2.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('fuzzyNgram3', this.value)">
                                <span id="weightDisplay_fuzzyNgram3" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.5</span>
                            </div>
                        </div>

                        <!-- Fuzzy 6-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_fuzzyNgram6" onchange="toggleMetricWeight('fuzzyNgram6')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Fuzzy 6-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Levenshtein ≤13 edits - detects longer paraphrasing - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_fuzzyNgram6" min="0.1" max="5.0" step="0.1" value="2.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('fuzzyNgram6', this.value)">
                                <span id="weightDisplay_fuzzyNgram6" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.5</span>
                            </div>
                        </div>

                        <!-- Word-Level 3-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordLevelFuzzy3" checked onchange="toggleMetricWeight('wordLevelFuzzy3')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Word-Level 3-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Word substitutions ≤1 - catches "helping" → "aiding" - VERY HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordLevelFuzzy3" min="0.1" max="5.0" step="0.1" value="3.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordLevelFuzzy3', this.value)">
                                <span id="weightDisplay_wordLevelFuzzy3" style="min-width: 35px; font-weight: 600; font-size: 13px;">3.0</span>
                            </div>
                        </div>

                        <!-- Word-Level 5-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordLevelFuzzy5" checked onchange="toggleMetricWeight('wordLevelFuzzy5')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Word-Level 5-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Word substitutions ≤2 - detects phrase-level paraphrasing - VERY HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordLevelFuzzy5" min="0.1" max="5.0" step="0.1" value="3.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordLevelFuzzy5', this.value)">
                                <span id="weightDisplay_wordLevelFuzzy5" style="min-width: 35px; font-weight: 600; font-size: 13px;">3.0</span>
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 13px; color: #666; font-style: italic;">
                            Click "Apply Metrics" to recalculate with your selected metrics
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveMetricSettings()"
                                style="padding: 10px 24px; background: #57068C; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 14px;">
                                Apply Metrics
                            </button>
                            <button onclick="toggleMetricSettings()"
                                style="padding: 10px 24px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 14px;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Methodology Modal -->
        <div class="modal" id="methodologyModal" style="display: none;" onclick="if(event.target===this) toggleMethodologyModal()">
            <div class="modal-content" style="max-width: 700px;" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h3 style="margin: 0; color: white;">About / Methodology</h3>
                    <button class="modal-close" onclick="toggleMethodologyModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <h4 style="margin-top: 0; color: #57068C;">The Homogenometry Dashboard</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        This tool measures <strong>corpus-internal homogeneity</strong> by computing pairwise similarity between all responses
                        in your dataset. A dataset may be a collection of student essays, homework exercises, Google Form responses, or any
                        set of text responses you wish to analyze. Rather than comparing against external benchmarks or looking for specific "tells" (like the word "delve"
                        or em dashes), it reveals which responses are unusually similar <em>to each other</em>. Each metric is calculated and
                        displayed separately for transparent interpretation.
                    </p>

                    <h4 style="color: #57068C; margin-top: 25px;">Why This Approach?</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        Traditional detection tools search for specific patterns or "fingerprints" (certain vocabulary, punctuation habits,
                        sentence structures). This approach has limitations:
                    </p>
                    <ul style="font-size: 14px; line-height: 1.8; color: #555;">
                        <li><strong>Model-specific:</strong> AI fingerprints change with each new model version</li>
                        <li><strong>False positives:</strong> Human writers may naturally use flagged words or patterns</li>
                        <li><strong>Narrow focus:</strong> Only detects one specific source (e.g., AI) rather than any form of similarity</li>
                    </ul>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        <strong>Homogeneity analysis is different:</strong> It doesn't care <em>why</em> responses are similar—whether from
                        AI use, copying, collaboration, or shared sources. It simply identifies pairs showing unusual convergence in vocabulary,
                        phrasing, and structure. This makes it model-agnostic, future-proof, and equally effective at catching copying between
                        humans as AI-assisted writing.
                    </p>

                    <h4 style="color: #57068C; margin-top: 25px;">How It Works</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        The analyzer computes pairwise similarity between all responses using 18 distinct metrics, each capturing different
                        aspects of textual similarity. All metrics can be enabled/disabled and weighted via Metric Settings.
                    </p>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Lexical Similarity Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>1. Cosine Similarity</strong> - Measures similarity in word frequency patterns by treating each text as a vector
                            of word counts. High scores indicate similar vocabulary usage rates.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A: "The cat sat on the mat" (the=2, cat=1, sat=1...) vs Text B: "The dog sat on the rug"
                            (the=2, dog=1, sat=1...) - Similar frequency patterns despite different words.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>2. Jaccard Index</strong> - Calculates the proportion of shared unique words relative to total unique words.
                            Measures vocabulary overlap without considering word frequency.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A uses {education, reform, policy, students} and Text B uses {education, policy, teachers, funding}.
                            Shared: 2 words. Total unique: 6 words. Jaccard = 2/6 = 33.3%.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Character-Level N-gram Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>3. N-gram Similarity (3-character)</strong> - Compares sequences of 3 consecutive characters, ignoring punctuation.
                            Detects similar spelling patterns and word fragments.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "education" → {edu, duc, uca, cat, ati, tio, ion}. Matches with "educational" which shares most
                            of these 3-grams.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>4. N-gram Similarity (4-character)</strong> - Same as above but using 4-character sequences for more specificity.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "therefore" → {ther, here, eref, refo, efor, fore}. Catches longer spelling patterns.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>5. N-gram Similarity (5-character)</strong> - Uses 5-character sequences for even more specific pattern matching.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Useful for detecting copy-paste of unique phrases or technical terms like "photosynthesis."
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>6. N-gram with Punctuation</strong> - Same as 3-character n-grams but preserves punctuation, capturing formatting
                            and stylistic choices.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "don't" vs "dont" vs "do not" - preserved punctuation reveals exact stylistic matches.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Word-Level N-gram Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>7. Word N-gram (3-word phrases)</strong> - Identifies shared 3-word sequences. Excellent for detecting copied phrases
                            and sentence fragments.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "In other words" appears in both texts. "The main argument" appears in both. Indicates
                            similar phrasing patterns or direct copying.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Fuzzy Matching Metrics (Paraphrase Detection)</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>8. Fuzzy N-gram (3-word phrases, ≤5 character edits)</strong> - Compares 3-word phrases allowing up to 5 character
                            differences via Levenshtein distance. Catches light paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "the primary argument" matches "the main argument" (5 character changes: "primary" → "main").
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>9. Fuzzy N-gram (6-word phrases, ≤13 character edits)</strong> - Longer phrases with more tolerance for changes.
                            Detects more extensive paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "In conclusion we can see that education" matches "In summary we observe that schooling"
                            (multiple word substitutions within tolerance).
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>10. Word-Level Fuzzy (3-word phrases, ≤1 word substitution)</strong> - Compares 3-word phrases allowing exactly
                            1 word to differ. Detects single-word paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "climate change impacts" matches "climate change effects" (1 word different: impacts → effects).
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>11. Word-Level Fuzzy (5-word phrases, ≤2 word substitutions)</strong> - Longer phrases allowing up to 2 words
                            to differ. Catches multi-word paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "the study reveals important findings about" matches "this research shows significant results regarding"
                            (2 words changed: study→research, reveals→shows).
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Structural Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>12. Word Count Similarity</strong> - Measures similarity in total word count. Responses with similar length
                            requirements often have similar word counts.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A has 247 words, Text B has 251 words. Very similar lengths may indicate similar levels
                            of elaboration or adherence to length requirements.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>13. Average Sentence Length</strong> - Compares the mean number of words per sentence. Reflects writing style
                            and complexity.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A averages 18.3 words/sentence, Text B averages 18.7 words/sentence. Similar sentence
                            length patterns suggest similar writing styles or shared sources.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>14. Sentence Length Variance</strong> - Measures similarity in sentence length variability. Writers with consistent
                            sentence rhythms show similar variance patterns.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A has sentence lengths [10, 12, 9, 11] (low variance = consistent). Text B has [8, 22, 5, 19]
                            (high variance = varied). Different writing styles.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Stylistic Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>15. Pronoun Density</strong> - Compares the proportion of pronouns (I, you, he, she, it, we, they, etc.) in each text.
                            Reflects perspective and voice.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A: 12% pronouns (first-person narrative). Text B: 2% pronouns (formal academic). Very different
                            writing styles. Similarity indicates shared voice or perspective.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>16. Transition Words Density</strong> - Measures usage frequency of transition words and phrases (however, furthermore,
                            for example, in other words, etc.). Reflects rhetorical sophistication and organization.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A uses 15 transition phrases in 500 words (3.0%). Text B uses 14 in 480 words (2.9%). Similar
                            usage patterns suggest similar rhetorical training or shared source material.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Advanced Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>17. Named Entity Recognition (NER)</strong> - Identifies and compares proper nouns (people, places, organizations).
                            Shared entities indicate common source material or topics.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Both texts mention "Stanford University," "John Dewey," and "Department of Education." High entity
                            overlap suggests citing the same sources or discussing identical examples.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>18. Temporal Burstiness</strong> - Analyzes word positioning patterns using the burstiness metric from Cui et al. (2017).
                            Words that appear in concentrated "bursts" vs. evenly distributed show different usage patterns.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A uses "democracy" clustered in the introduction (bursty, μ=0.8). Text B uses "democracy"
                            evenly throughout (distributed, μ=0.2). Similar burstiness patterns suggest similar organizational strategies or copied structure.
                        </div>
                    </div>

                    <p style="font-size: 13px; line-height: 1.6; color: #555; margin-top: 20px; font-style: italic;">
                        All 18 metrics are combined using weighted averaging with min-max normalization. Configure which metrics to use
                        and their relative weights via the Metric Settings button in the header menu.
                    </p>

                    <h4 style="color: #57068C; margin-top: 25px;">Interpretation</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        High similarity scores indicate responses that share unusual amounts of vocabulary, phrasing, or structure.
                        While this doesn't prove misconduct, it flags pairs that warrant closer human review. Adjust the similarity
                        threshold to balance sensitivity and specificity for your use case.
                    </p>

                    <h4 style="color: #e74c3c; margin-top: 25px;">Important Limitations</h4>

                    <p style="font-size: 14px; line-height: 1.6; color: #555; margin-bottom: 15px;">
                        <strong>Scores are dataset-relative, not absolute.</strong> The tool uses min-max normalization to make metrics
                        comparable <em>within</em> each analysis session, but this means similarity scores cannot be meaningfully compared
                        <em>across</em> different datasets.
                    </p>

                    <div style="background: #fff3cd; padding: 15px; border-radius: 5px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <p style="font-size: 13px; margin: 0 0 10px 0; color: #856404;">
                            <strong>Why this matters:</strong> A 60% similarity score in one dataset may be more significant than a 75% score
                            in another, depending on the "natural" variance in that corpus.
                        </p>
                        <p style="font-size: 13px; margin: 0; color: #856404;">
                            <strong>Example:</strong> Responses to "Define photosynthesis" naturally cluster around similar definitions (high baseline
                            similarity). Responses to "Write a creative short story" show much greater diversity (low baseline). After normalization,
                            both datasets span 0-100%, but the underlying similarity levels are completely different.
                        </p>
                    </div>

                    <p style="font-size: 14px; line-height: 1.6; color: #555; margin-bottom: 8px;">
                        <strong>Factors affecting score interpretation:</strong>
                    </p>
                    <ul style="font-size: 14px; line-height: 1.8; color: #555; margin-top: 0;">
                        <li><strong>Population size:</strong> Smaller datasets may have narrower variance ranges, affecting normalization</li>
                        <li><strong>Genre conventions:</strong> Academic essays, technical writing, and formulaic responses naturally show higher baseline similarity than creative or open-ended writing</li>
                        <li><strong>Prompt specificity:</strong> Highly constrained prompts (e.g., "List the steps of mitosis") produce more homogeneous responses than open prompts</li>
                        <li><strong>Entry length:</strong> Shorter responses have fewer opportunities for divergence in vocabulary and structure</li>
                        <li><strong>Skill variance:</strong> Homogeneous skill levels (e.g., all advanced writers) produce different score distributions than mixed-ability groups</li>
                        <li><strong>Shared source material:</strong> If the assignment requires citing specific texts, legitimate responses will naturally share quoted material and terminology</li>
                    </ul>

                    <p style="font-size: 14px; line-height: 1.6; color: #555; margin-top: 15px;">
                        <strong>Best practice:</strong> Use similarity scores to compare pairs <em>within the same analysis session</em>, not across different
                        datasets or assignments. Establish context-appropriate thresholds based on the specific assignment type, expected diversity, and your
                        population's characteristics.
                    </p>

                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #17a2b8;">
                        <p style="font-size: 13px; margin: 0 0 8px 0; color: #0c5460;">
                            <strong>Additional limitations:</strong>
                        </p>
                        <ul style="font-size: 13px; margin: 0; color: #0c5460; line-height: 1.6;">
                            <li>The tool cannot determine <em>why</em> responses are similar (AI use, copying, collaboration, shared sources, or coincidence)</li>
                            <li>Short responses (&lt;50 words) may produce unreliable similarity scores due to limited text for comparison</li>
                            <li>Non-English text may not be properly tokenized, affecting accuracy of word-based metrics</li>
                            <li>Paraphrasing that preserves meaning while changing vocabulary may not be fully detected by lexical metrics</li>
                            <li>Statistical significance: With large datasets, even low similarity scores may represent genuine patterns requiring investigation</li>
                        </ul>
                    </div>

                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #57068C;">
                        <p style="font-size: 13px; margin: 0; color: #666;">
                            <strong>Note:</strong> This tool is designed for academic integrity research and should be used as one component
                            of a comprehensive evaluation process, not as the sole determinant of academic misconduct.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard" id="dashboard" style="display: none;">
            <div id="pairs-tab" class="tab-content active">
                <!-- Flagged Respondents Panel with Tabs -->
                <div class="metric-panel" id="frequentRespondentsPanel" style="display: none;">
                    <div class="panel-header">
                        Flagged Respondents
                        <span class="panel-info">Analysis by similarity patterns</span>
                    </div>
                    <div class="panel-content">
                        <!-- Tabs for Most/Least Flagged -->
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0;">
                            <button id="mostFlaggedTab" onclick="switchFlaggedTab('most')"
                                style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid #57068C; color: #57068C; font-weight: 600; cursor: pointer;">
                                Most Flagged
                            </button>
                            <button id="leastFlaggedTab" onclick="switchFlaggedTab('least')"
                                style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #666; font-weight: 600; cursor: pointer;">
                                Least Flagged
                            </button>
                        </div>

                        <div id="mostFlaggedContent">
                            <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Respondents appearing in multiple high-similarity pairs</p>
                            <div id="frequentRespondentsList"></div>
                        </div>

                        <div id="leastFlaggedContent" style="display: none;">
                            <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Respondents with consistently low similarity to others</p>
                            <div id="infrequentRespondentsList"></div>
                        </div>
                    </div>
                </div>

                <!-- Similarity Pairs List -->
                <div class="metric-panel">
                    <div class="panel-header">
                        High Similarity Pairs
                        <span class="panel-info" id="pairCountDisplay">0 pairs above threshold</span>
                    </div>
                    <div class="panel-content">
                        <div id="similarityPairsList">
                            <p style="color: #999; text-align: center; padding: 40px;">
                                Upload a file to see similarity analysis
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="export-btn" onclick="exportResults()">
                    📥 Export Analysis Report
                </button>
            </div>
        </div>

        <!-- Comparison Modal -->
        <div class="modal" id="comparisonModal" onclick="if(event.target===this) closeModal()">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modalTitle">Response Comparison</h3>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <div class="modal-body" id="modalBody"></div>
            </div>
        </div>

        <!-- Progress Modal -->
        <div class="modal" id="progressModal" style="z-index: 10002; background: rgba(0,0,0,0.7);">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header" style="background: #57068C; color: white; padding: 20px;">
                    <h3 id="progressTitle" style="margin: 0; color: white;">Analyzing Corpus...</h3>
                </div>
                <div class="modal-body" style="padding: 30px;">
                    <div style="margin-bottom: 20px;">
                        <div id="progressMessage" style="font-size: 14px; color: #666; margin-bottom: 10px;">
                            Initializing...
                        </div>
                        <div style="background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden;">
                            <div id="progressBar" style="background: linear-gradient(90deg, #57068C, #8e44ad); height: 100%; width: 0%; transition: width 0.3s;">
                            </div>
                        </div>
                        <div id="progressPercent" style="text-align: center; margin-top: 8px; font-weight: bold; color: #57068C;">
                            0%
                        </div>
                    </div>
                    <div id="progressDetails" style="font-size: 13px; color: #999; margin-bottom: 20px; min-height: 40px;">
                    </div>
                    <div style="text-align: center;">
                        <button id="cancelButton" onclick="cancelAnalysis()"
                            style="padding: 10px 30px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Spinner -->
        <div id="loadingSpinner" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10003; justify-content: center; align-items: center;">
            <div style="text-align: center;">
                <div style="border: 8px solid #f3f3f3; border-top: 8px solid #57068C; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                <p style="color: white; margin-top: 20px; font-size: 16px; font-weight: 600;">Loading...</p>
            </div>
        </div>

        <!-- Calculation Details Modal (appears on top of comparison modal) -->
        <div class="modal" id="calculationModal" onclick="if(event.target===this) closeCalculationModal()" style="z-index: 10001;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="calculationTitle">Calculation Details</h3>
                    <button class="modal-close" onclick="closeCalculationModal()">&times;</button>
                </div>
                <div class="modal-body" id="calculationBody"></div>
            </div>
        </div>
    </div>

    <script>
        let csvData = [];
        let headers = [];
        let currentColumn = 0;
        let analysisResults = {};
        let responses = []; // Global responses array
        let analysisIsRunning = false;
        let cancelRequested = false;
        let metricNormalizationParams = {}; // Stores min/max for each metric for normalization

        // ========== HEADER MENU ==========

        function toggleHeaderMenu() {
            const dropdown = document.getElementById('header-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('header-dropdown');
            const menuTrigger = document.querySelector('.menu-trigger');
            if (dropdown && !dropdown.contains(event.target) && !menuTrigger.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // ========== SESSION PERSISTENCE ==========

        function saveSession() {
            try {
                localStorage.setItem('homogeneityAnalyzer_csvData', JSON.stringify(csvData));
                localStorage.setItem('homogeneityAnalyzer_headers', JSON.stringify(headers));
                localStorage.setItem('homogeneityAnalyzer_currentColumn', currentColumn.toString());
                localStorage.setItem('homogeneityAnalyzer_threshold', document.getElementById('similarityThreshold')?.value || '0.60');

                // Save complete analysis state to avoid recalculation
                if (analysisResults) {
                    localStorage.setItem('homogeneityAnalyzer_analysisResults', JSON.stringify(analysisResults));
                }
                if (allSimilarityPairs && allSimilarityPairs.length > 0) {
                    localStorage.setItem('homogeneityAnalyzer_similarityPairs', JSON.stringify(allSimilarityPairs));
                }
                if (responses && responses.length > 0) {
                    localStorage.setItem('homogeneityAnalyzer_responses', JSON.stringify(responses));
                }
            } catch (e) {
                console.error('Failed to save session:', e);
            }
        }

        function restoreSession() {
            try {
                const savedCsvData = localStorage.getItem('homogeneityAnalyzer_csvData');
                const savedHeaders = localStorage.getItem('homogeneityAnalyzer_headers');
                const savedColumn = localStorage.getItem('homogeneityAnalyzer_currentColumn');
                const savedThreshold = localStorage.getItem('homogeneityAnalyzer_threshold');

                if (savedCsvData && savedHeaders) {
                    csvData = JSON.parse(savedCsvData);
                    headers = JSON.parse(savedHeaders);
                    currentColumn = parseInt(savedColumn) || 1;

                    // Populate column selector
                    const select = document.getElementById('columnSelect');
                    select.innerHTML = '';
                    headers.forEach((header, i) => {
                        if (i > 0 && header.trim()) {
                            const option = document.createElement('option');
                            option.value = i;
                            option.textContent = header.length > 80 ? header.substring(0, 80) + '...' : header;
                            if (i === currentColumn) option.selected = true;
                            select.appendChild(option);
                        }
                    });

                    // Restore threshold
                    if (savedThreshold) {
                        document.getElementById('similarityThreshold').value = savedThreshold;
                        document.getElementById('thresholdDisplay').textContent = savedThreshold;
                    }

                    // Hide welcome screen and show app interface
                    document.getElementById('welcomeScreen').style.display = 'none';
                    document.getElementById('controls').style.display = 'block';
                    document.getElementById('dashboard').style.display = 'block';

                    // Try to restore saved analysis state to avoid recalculation
                    const savedAnalysisResults = localStorage.getItem('homogeneityAnalyzer_analysisResults');
                    const savedSimilarityPairs = localStorage.getItem('homogeneityAnalyzer_similarityPairs');
                    const savedResponses = localStorage.getItem('homogeneityAnalyzer_responses');

                    if (savedAnalysisResults && savedSimilarityPairs && savedResponses) {
                        // Restore saved analysis state
                        analysisResults = JSON.parse(savedAnalysisResults);
                        allSimilarityPairs = JSON.parse(savedSimilarityPairs);
                        responses = JSON.parse(savedResponses);

                        // Update display with restored data
                        updateThreshold(savedThreshold || '0.40');

                        showNotification('Session restored instantly! Your previous analysis has been loaded.');
                    } else {
                        // No saved analysis, recalculate
                        analyzeCorpus();
                        showNotification('Session restored! Recalculating analysis...');
                    }

                    return true;
                }
            } catch (e) {
                console.error('Failed to restore session:', e);
            }
            return false;
        }

        function clearSession() {
            if (confirm('Clear saved session data? This will reload the page.')) {
                localStorage.removeItem('homogeneityAnalyzer_csvData');
                localStorage.removeItem('homogeneityAnalyzer_headers');
                localStorage.removeItem('homogeneityAnalyzer_currentColumn');
                localStorage.removeItem('homogeneityAnalyzer_threshold');
                localStorage.removeItem('homogeneityAnalyzer_analysisResults');
                localStorage.removeItem('homogeneityAnalyzer_similarityPairs');
                localStorage.removeItem('homogeneityAnalyzer_responses');
                location.reload();
            }
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #27ae60;
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Try to restore session on page load
        window.addEventListener('DOMContentLoaded', () => {
            restoreSession();
            restoreMetricSettings();

            // Event Listeners
            document.getElementById('csvFile').addEventListener('change', handleFileUpload);
            document.getElementById('columnSelect').addEventListener('change', async (e) => {
                currentColumn = parseInt(e.target.value);
                await analyzeCorpus();
                saveSession();
            });
        });

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                parseCSV(event.target.result);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const rows = parseCSVText(text);
            if (rows.length === 0) return;

            headers = rows[0];
            csvData = [];

            for (let i = 1; i < rows.length; i++) {
                if (rows[i].length >= headers.length) {
                    csvData.push(rows[i]);
                }
            }

            // Populate column selector
            const select = document.getElementById('columnSelect');
            select.innerHTML = '';
            headers.forEach((header, i) => {
                if (i > 0 && header.trim()) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = header.length > 80 ? header.substring(0, 80) + '...' : header;
                    select.appendChild(option);
                }
            });

            currentColumn = 1;

            // Hide welcome screen and show app interface
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('dashboard').style.display = 'block';

            analyzeCorpus();
            saveSession();
        }

        function parseCSVText(text) {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (inQuotes) {
                    if (char === '"' && nextChar === '"') {
                        currentField += '"';
                        i++;
                    } else if (char === '"') {
                        inQuotes = false;
                    } else {
                        currentField += char;
                    }
                } else {
                    if (char === '"') {
                        inQuotes = true;
                    } else if (char === ',') {
                        currentRow.push(currentField.trim());
                        currentField = '';
                    } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
                        if (char === '\r') i++;
                        currentRow.push(currentField.trim());
                        if (currentRow.some(field => field !== '')) {
                            rows.push(currentRow);
                        }
                        currentRow = [];
                        currentField = '';
                    } else if (char !== '\r') {
                        currentField += char;
                    }
                }
            }

            currentRow.push(currentField.trim());
            if (currentRow.some(field => field !== '')) {
                rows.push(currentRow);
            }

            return rows;
        }

        async function analyzeCorpus() {
            // Update global responses array
            responses = csvData.map(row => ({
                id: row[0],
                text: row[currentColumn] || ''
            })).filter(r => r.text.trim());

            if (responses.length === 0) return;

            // Calculate similarity pairs FIRST with progress tracking
            await calculateSimilarityPairs(responses);

            // Calculate all other metrics (using already-calculated similarity data)
            const diversity = calculateLexicalDiversity(responses);
            const phrases = analyzePhrases(responses);
            const similarity = analyzeSimilarity(responses);

            // Corpus-level temporal burstiness analysis (Cui et al. 2017)
            // Runs AFTER similarity to avoid interference
            let burstiness = null;
            try {
                burstiness = analyzeBurstiness(responses);
                console.log('Burstiness analysis completed:', burstiness.stats);
            } catch (error) {
                console.error('Burstiness analysis failed:', error);
                burstiness = null;
            }

            // Store results
            analysisResults = {
                diversity,
                phrases,
                similarity,
                burstiness,
                responses
            };

            // Update display
            updateThreshold(document.getElementById('similarityThreshold').value);

            // Save session for persistence
            saveSession();
        }

        function calculateLexicalDiversity(responses) {
            const allWords = [];
            const wordFreq = {};
            const uniqueWordsPerResponse = [];

            responses.forEach(r => {
                const words = tokenize(r.text);
                allWords.push(...words);

                // Unique words in this response
                const uniqueInResponse = new Set(words);
                uniqueWordsPerResponse.push(uniqueInResponse.size);

                // Word frequency
                words.forEach(w => {
                    wordFreq[w] = (wordFreq[w] || 0) + 1;
                });
            });

            const totalWords = allWords.length;
            const uniqueWords = Object.keys(wordFreq).length;
            const ttr = uniqueWords / totalWords;

            // Hapax legomena (words appearing only once)
            const hapaxCount = Object.values(wordFreq).filter(count => count === 1).length;
            const hapaxRate = hapaxCount / uniqueWords;

            // Average unique words per response
            const avgUniqueWords = uniqueWordsPerResponse.reduce((a, b) => a + b, 0) / responses.length;

            return {
                totalWords,
                uniqueWords,
                ttr,
                hapaxCount,
                hapaxRate,
                avgUniqueWords
            };
        }

        function tokenize(text) {
            return text.toLowerCase()
                .replace(/[\u2018\u2019\u201C\u201D]/g, "'")  // Normalize smart quotes to straight quotes
                .replace(/[^\w\s']/g, ' ')  // Keep apostrophes for contractions
                .split(/\s+/)
                .filter(w => w.length > 0);  // Changed from > 2 to > 0 to allow pronouns like "i", "me", "we"
        }

        function analyzePhrases(responses) {
            const phraseCounts = {};
            const n = responses.length;

            // Extract n-grams from 2 to 8 words
            responses.forEach(r => {
                const words = r.text.toLowerCase().split(/\s+/).filter(w => w.length > 0);

                for (let ngramSize = 2; ngramSize <= Math.min(8, words.length); ngramSize++) {
                    for (let i = 0; i <= words.length - ngramSize; i++) {
                        const phrase = words.slice(i, i + ngramSize).join(' ');
                        if (!phraseCounts[phrase]) {
                            phraseCounts[phrase] = { count: 0, ids: new Set() };
                        }
                        phraseCounts[phrase].count++;
                        phraseCounts[phrase].ids.add(r.id);
                    }
                }
            });

            // Calculate statistics
            const allPhrases = Object.entries(phraseCounts).map(([phrase, data]) => ({
                text: phrase,
                count: data.ids.size, // Number of distinct responses containing it
                percentage: (data.ids.size / n) * 100,
                ids: Array.from(data.ids)
            }));

            // Filter to phrases appearing in multiple responses
            const repeatedPhrases = allPhrases.filter(p => p.count >= 2);

            // Sort by occurrence rate
            repeatedPhrases.sort((a, b) => b.count - a.count);

            // High frequency (>20% of responses)
            const highFreq = repeatedPhrases.filter(p => p.percentage > 20);

            // Calculate expected rate and find outliers
            // Simple model: expected rate decreases with phrase length
            const outliers = repeatedPhrases.filter(p => {
                const wordCount = p.text.split(' ').length;
                const expectedRate = Math.max(5, 30 / wordCount); // Rough heuristic
                return p.percentage > expectedRate * 2; // 2x expected = outlier
            });

            const maxPhraseRate = repeatedPhrases.length > 0 ? repeatedPhrases[0].percentage : 0;

            return {
                topPhrases: repeatedPhrases.slice(0, 50),
                highFreq,
                outliers,
                maxPhraseRate
            };
        }

        function analyzeSimilarity(responses) {
            // Use already-calculated similarity pairs instead of recalculating
            const similarities = allSimilarityPairs.map(pair => pair.similarity);

            if (similarities.length === 0) {
                return {
                    mean: 0,
                    stdDev: 0,
                    highSimilarity: 0,
                    highSimilarityPct: 0,
                    histogram: new Array(20).fill(0),
                    total: 0
                };
            }

            const mean = similarities.reduce((a, b) => a + b, 0) / similarities.length;
            const variance = similarities.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / similarities.length;
            const stdDev = Math.sqrt(variance);

            const highSimilarity = similarities.filter(s => s > 0.70).length;
            const highSimilarityPct = (highSimilarity / similarities.length) * 100;

            // Create histogram data
            const bins = 20;
            const histogram = new Array(bins).fill(0);
            similarities.forEach(sim => {
                const binIndex = Math.min(Math.floor(sim * bins), bins - 1);
                histogram[binIndex]++;
            });

            return {
                mean,
                stdDev,
                highSimilarity,
                highSimilarityPct,
                histogram,
                total: similarities.length
            };
        }

        // ========== NEW SIMILARITY METRICS ==========

        function sentenceLengthVariance(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            if (sentences.length === 0) return 0;
            const lengths = sentences.map(s => s.trim().split(/\s+/).length);
            const mean = lengths.reduce((a,b) => a+b, 0) / lengths.length;
            const variance = lengths.reduce((sum, len) => sum + Math.pow(len - mean, 2), 0) / lengths.length;
            return variance;
        }

        function sentenceVarianceSimilarity(text1, text2) {
            const var1 = sentenceLengthVariance(text1);
            const var2 = sentenceLengthVariance(text2);
            if (var1 === 0 && var2 === 0) return 1;
            return 1 - Math.abs(var1 - var2) / Math.max(var1, var2, 1);
        }

        function wordCountSimilarity(text1, text2) {
            const count1 = text1.trim().split(/\s+/).length;
            const count2 = text2.trim().split(/\s+/).length;
            if (count1 === 0 && count2 === 0) return 1;
            return 1 - Math.abs(count1 - count2) / Math.max(count1, count2);
        }

        function avgSentenceLengthSimilarity(text1, text2) {
            const sentences1 = text1.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const sentences2 = text2.split(/[.!?]+/).filter(s => s.trim().length > 0);

            const avg1 = sentences1.reduce((sum, s) => sum + s.trim().split(/\s+/).length, 0) / sentences1.length;
            const avg2 = sentences2.reduce((sum, s) => sum + s.trim().split(/\s+/).length, 0) / sentences2.length;

            if (!avg1 || !avg2) return 0;
            return 1 - Math.abs(avg1 - avg2) / Math.max(avg1, avg2);
        }

        // OLD BURSTINESS FUNCTIONS REMOVED
        // Replaced with corpus-level temporal burstiness analysis from Cui et al. 2017

        function pronounDensitySimilarity(text1, text2) {
            const pronouns = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
                            'you', 'your', 'yours', 'yourself', 'yourselves',
                            'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
                            'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
                            'i\'m', 'i\'ve', 'i\'d', 'i\'ll', 'you\'re', 'you\'ve', 'you\'d', 'you\'ll',
                            'he\'s', 'he\'d', 'he\'ll', 'she\'s', 'she\'d', 'she\'ll', 'it\'s', 'it\'d', 'it\'ll',
                            'we\'re', 'we\'ve', 'we\'d', 'we\'ll', 'they\'re', 'they\'ve', 'they\'d', 'they\'ll'];

            const words1 = tokenize(text1);
            const words2 = tokenize(text2);

            const count1 = words1.filter(w => pronouns.includes(w.toLowerCase())).length;
            const count2 = words2.filter(w => pronouns.includes(w.toLowerCase())).length;

            const density1 = words1.length > 0 ? count1 / words1.length : 0;
            const density2 = words2.length > 0 ? count2 / words2.length : 0;

            if (density1 === 0 && density2 === 0) return 1;
            const maxDensity = Math.max(density1, density2);
            if (maxDensity === 0) return 1;
            return 1 - Math.abs(density1 - density2) / maxDensity;
        }

        function transitionWordsSimilarity(text1, text2) {
            const transitions = [
                // Addition
                'furthermore', 'moreover', 'additionally', 'also', 'besides', 'in addition', 'as well as',
                // Example/Clarification
                'for example', 'for instance', 'specifically', 'to illustrate', 'namely', 'in other words',
                'that is', 'in particular', 'such as',
                // Contrast/Opposition
                'however', 'nevertheless', 'nonetheless', 'conversely', 'on the other hand', 'in contrast',
                'yet', 'still', 'although', 'even though', 'despite', 'regardless', 'alternatively',
                // Cause/Effect
                'therefore', 'thus', 'consequently', 'as a result', 'accordingly', 'hence', 'for this reason',
                'because of this', 'due to', 'since',
                // Time/Sequence
                'meanwhile', 'subsequently', 'finally', 'firstly', 'secondly', 'thirdly', 'then', 'next',
                'afterward', 'previously', 'eventually', 'ultimately', 'later', 'initially', 'formerly',
                // Conclusion/Summary
                'in conclusion', 'to sum up', 'in summary', 'overall', 'all in all', 'in brief',
                'to conclude', 'in the end',
                // Emphasis
                'indeed', 'in fact', 'certainly', 'undoubtedly', 'notably', 'especially', 'particularly',
                'importantly', 'significantly',
                // Comparison
                'similarly', 'likewise', 'in the same way', 'equally', 'by comparison'
            ];

            const count1 = transitions.reduce((sum, word) =>
                sum + (text1.toLowerCase().match(new RegExp('\\b' + word + '\\b', 'g')) || []).length, 0
            );
            const count2 = transitions.reduce((sum, word) =>
                sum + (text2.toLowerCase().match(new RegExp('\\b' + word + '\\b', 'g')) || []).length, 0
            );

            const words1 = text1.trim().split(/\s+/).length;
            const words2 = text2.trim().split(/\s+/).length;

            const density1 = (count1 / words1) * 100;
            const density2 = (count2 / words2) * 100;

            if (density1 === 0 && density2 === 0) return 1;
            return 1 - Math.abs(density1 - density2) / Math.max(density1, density2, 1);
        }

        function temporalBurstinessSimilarity(text1, text2) {
            // Pairwise temporal burstiness comparison using word positions
            const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i',
                                       'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
                                       'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she',
                                       'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their']);

            // Track word positions for each text
            const getWordPositions = (text) => {
                const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
                const positions = {};
                words.forEach((word, idx) => {
                    if (!stopWords.has(word) && word.length > 3) {
                        if (!positions[word]) positions[word] = [];
                        positions[word].push(idx);
                    }
                });
                return { positions, totalWords: words.length };
            };

            const data1 = getWordPositions(text1);
            const data2 = getWordPositions(text2);

            // Find common significant words (appear at least 2 times in each)
            const commonWords = Object.keys(data1.positions).filter(word =>
                data2.positions[word] &&
                data1.positions[word].length >= 2 &&
                data2.positions[word].length >= 2
            );

            if (commonWords.length === 0) return 0; // No shared repeated words = no similarity

            // Calculate burstiness for common words in each text
            const burstinessScores = commonWords.map(word => {
                const burst1 = calculateTemporalBurstiness(data1.positions[word], data1.totalWords);
                const burst2 = calculateTemporalBurstiness(data2.positions[word], data2.totalWords);

                // Similarity is 1 minus the absolute difference
                return 1 - Math.abs(burst1 - burst2);
            });

            // Return average similarity across all common words
            return burstinessScores.reduce((a, b) => a + b, 0) / burstinessScores.length;
        }

        // Calculate all individual metric scores for a pair of texts
        function calculateAllMetrics(text1, text2, selectedMetrics) {
            const metrics = {};

            selectedMetrics.forEach(metricId => {
                switch(metricId) {
                    case 'cosine':
                        metrics.cosine = cosineSimilarity(text1, text2);
                        break;
                    case 'jaccard':
                        metrics.jaccard = jaccardSimilarity(text1, text2);
                        break;
                    case 'ngram':
                        metrics.ngram = ngramSimilarity(text1, text2, 3);
                        break;
                    case 'sentenceVariance':
                        metrics.sentenceVariance = sentenceVarianceSimilarity(text1, text2);
                        break;
                    case 'wordCount':
                        metrics.wordCount = wordCountSimilarity(text1, text2);
                        break;
                    case 'avgSentenceLength':
                        metrics.avgSentenceLength = avgSentenceLengthSimilarity(text1, text2);
                        break;
                    case 'temporalBurstiness':
                        metrics.temporalBurstiness = temporalBurstinessSimilarity(text1, text2);
                        break;
                    case 'pronounDensity':
                        metrics.pronounDensity = pronounDensitySimilarity(text1, text2);
                        break;
                    case 'transitionWords':
                        metrics.transitionWords = transitionWordsSimilarity(text1, text2);
                        break;
                    case 'ngramPunctuation':
                        metrics.ngramPunctuation = ngramWithPunctuationSimilarity(text1, text2, 3);
                        break;
                    case 'wordNgram':
                        metrics.wordNgram = wordNgramSimilarity(text1, text2, 3);
                        break;
                    case 'ngram4':
                        metrics.ngram4 = ngram4Similarity(text1, text2);
                        break;
                    case 'ngram5':
                        metrics.ngram5 = ngram5Similarity(text1, text2);
                        break;
                    case 'ner':
                        metrics.ner = nerSimilarity(text1, text2);
                        break;
                    case 'fuzzyNgram3':
                        metrics.fuzzyNgram3 = fuzzyNgramSimilarity(text1, text2, 3, 5);
                        break;
                    case 'fuzzyNgram6':
                        metrics.fuzzyNgram6 = fuzzyNgramSimilarity(text1, text2, 6, 13);
                        break;
                    case 'wordLevelFuzzy3':
                        metrics.wordLevelFuzzy3 = wordLevelFuzzyNgramSimilarity(text1, text2, 3, 1);
                        break;
                    case 'wordLevelFuzzy5':
                        metrics.wordLevelFuzzy5 = wordLevelFuzzyNgramSimilarity(text1, text2, 5, 2);
                        break;
                }
            });

            return metrics;
        }

        // Normalize a metric score using min-max normalization
        function normalizeMetric(score, metricId) {
            const params = metricNormalizationParams[metricId];
            if (!params || params.max === params.min) {
                return score; // No normalization if params don't exist or range is zero
            }
            return (score - params.min) / (params.max - params.min);
        }

        function calculateCombinedSimilarity(text1, text2) {
            // Get selected metrics from settings
            const selected = getSelectedMetrics();

            // Calculate all individual metric scores
            const metrics = calculateAllMetrics(text1, text2, selected);

            // Get metric weights
            const weights = getMetricWeights();

            // Calculate weighted average of NORMALIZED metrics
            let weightedSum = 0;
            let totalWeight = 0;

            selected.forEach(metric => {
                if (metrics[metric] !== undefined) {
                    const weight = weights[metric] || 1.0;
                    const normalizedScore = normalizeMetric(metrics[metric], metric);
                    weightedSum += normalizedScore * weight;
                    totalWeight += weight;
                }
            });

            return totalWeight > 0 ? weightedSum / totalWeight : 0;
        }

        function getSelectedMetrics() {
            const metricIds = ['cosine', 'jaccard', 'ngram', 'sentenceVariance', 'wordCount',
                              'avgSentenceLength', 'temporalBurstiness', 'pronounDensity', 'transitionWords',
                              'ngramPunctuation', 'wordNgram', 'ngram4', 'ngram5', 'ner', 'fuzzyNgram3', 'fuzzyNgram6',
                              'wordLevelFuzzy3', 'wordLevelFuzzy5'];
            return metricIds.filter(id => {
                const checkbox = document.getElementById('metric_' + id);
                return checkbox && checkbox.checked;
            });
        }

        function toggleMetricSettings() {
            const modal = document.getElementById('metricSettings');
            if (modal.style.display === 'none' || modal.style.display === '') {
                modal.style.display = 'flex';
            } else {
                modal.style.display = 'none';
            }
        }

        function toggleMethodologyModal() {
            const modal = document.getElementById('methodologyModal');
            if (modal.style.display === 'none' || modal.style.display === '') {
                modal.style.display = 'flex';
            } else {
                modal.style.display = 'none';
            }
        }

        function updateWeightDisplay(metricId, value) {
            const display = document.getElementById(`weightDisplay_${metricId}`);
            if (display) {
                display.textContent = parseFloat(value).toFixed(1);
            }
        }

        function toggleMetricWeight(metricId) {
            const checkbox = document.getElementById(`metric_${metricId}`);
            const weightSlider = document.getElementById(`weight_${metricId}`);
            const weightDisplay = document.getElementById(`weightDisplay_${metricId}`);

            if (weightSlider) {
                weightSlider.disabled = !checkbox.checked;
            }
            if (weightDisplay) {
                weightDisplay.style.opacity = checkbox.checked ? '1' : '0.4';
            }
        }

        function getMetricWeights() {
            const weights = {};
            const metricIds = ['cosine', 'jaccard', 'ngram', 'sentenceVariance', 'wordCount', 'avgSentenceLength',
                              'temporalBurstiness', 'pronounDensity', 'transitionWords', 'ngramPunctuation', 'wordNgram',
                              'ngram4', 'ngram5', 'ner', 'fuzzyNgram3', 'fuzzyNgram6', 'wordLevelFuzzy3', 'wordLevelFuzzy5'];

            metricIds.forEach(id => {
                const slider = document.getElementById(`weight_${id}`);
                if (slider) {
                    weights[id] = parseFloat(slider.value);
                }
            });

            return weights;
        }

        async function saveMetricSettings() {
            const selected = getSelectedMetrics();
            const weights = getMetricWeights();

            localStorage.setItem('homogeneityAnalyzer_selectedMetrics', JSON.stringify(selected));
            localStorage.setItem('homogeneityAnalyzer_metricWeights', JSON.stringify(weights));

            // Close the modal
            toggleMetricSettings();

            // Recalculate similarity pairs with new metric selection and weights
            if (responses.length > 0) {
                await calculateSimilarityPairs(responses);
                // Re-apply the current threshold to update the display
                const currentThreshold = document.getElementById('similarityThreshold')?.value || '0.4';
                updateThreshold(currentThreshold);
            }
        }

        function restoreMetricSettings() {
            // Restore selected metrics
            const saved = localStorage.getItem('homogeneityAnalyzer_selectedMetrics');
            if (saved) {
                const selected = JSON.parse(saved);
                const metricIds = ['cosine', 'jaccard', 'ngram', 'sentenceVariance', 'wordCount',
                                  'avgSentenceLength', 'temporalBurstiness', 'pronounDensity', 'transitionWords',
                                  'ngramPunctuation', 'wordNgram', 'ngram4', 'ngram5', 'ner', 'fuzzyNgram3', 'fuzzyNgram6',
                                  'wordLevelFuzzy3', 'wordLevelFuzzy5'];
                metricIds.forEach(id => {
                    const checkbox = document.getElementById('metric_' + id);
                    if (checkbox) {
                        checkbox.checked = selected.includes(id);
                    }
                });
            }

            // Restore metric weights
            const savedWeights = localStorage.getItem('homogeneityAnalyzer_metricWeights');
            if (savedWeights) {
                const weights = JSON.parse(savedWeights);
                Object.keys(weights).forEach(id => {
                    const slider = document.getElementById(`weight_${id}`);
                    const display = document.getElementById(`weightDisplay_${id}`);
                    if (slider) {
                        slider.value = weights[id];
                        if (display) {
                            display.textContent = parseFloat(weights[id]).toFixed(1);
                        }
                    }
                });
            }
        }

        function generateMetricBadges(text1, text2, combinedScore, id1, id2) {
            // Get selected metrics to only calculate what's needed
            const selectedIds = getSelectedMetrics();

            // Only calculate the selected metrics
            const metricValues = {};
            selectedIds.forEach(metricId => {
                switch(metricId) {
                    case 'cosine':
                        metricValues['Cosine'] = cosineSimilarity(text1, text2);
                        break;
                    case 'jaccard':
                        metricValues['Jaccard'] = jaccardSimilarity(text1, text2);
                        break;
                    case 'ngram':
                        metricValues['N-gram'] = ngramSimilarity(text1, text2, 3);
                        break;
                    case 'sentenceVariance':
                        metricValues['Sentence Variance'] = sentenceVarianceSimilarity(text1, text2);
                        break;
                    case 'wordCount':
                        metricValues['Word Count'] = wordCountSimilarity(text1, text2);
                        break;
                    case 'avgSentenceLength':
                        metricValues['Avg Sentence Length'] = avgSentenceLengthSimilarity(text1, text2);
                        break;
                    case 'temporalBurstiness':
                        metricValues['Temporal Burstiness'] = temporalBurstinessSimilarity(text1, text2);
                        break;
                    case 'pronounDensity':
                        metricValues['Pronoun Density'] = pronounDensitySimilarity(text1, text2);
                        break;
                    case 'transitionWords':
                        metricValues['Transition Words'] = transitionWordsSimilarity(text1, text2);
                        break;
                    case 'ngramPunctuation':
                        metricValues['N-gram with Punctuation'] = ngramWithPunctuationSimilarity(text1, text2, 3);
                        break;
                    case 'wordNgram':
                        metricValues['3-Word Phrases'] = wordNgramSimilarity(text1, text2, 3);
                        break;
                    case 'ngram4':
                        metricValues['N-gram 4-char'] = ngram4Similarity(text1, text2);
                        break;
                    case 'ngram5':
                        metricValues['N-gram 5-char'] = ngram5Similarity(text1, text2);
                        break;
                    case 'ner':
                        metricValues['Named Entity Recognition'] = nerSimilarity(text1, text2);
                        break;
                    case 'fuzzyNgram3':
                        metricValues['Fuzzy 3-Word Phrases'] = fuzzyNgramSimilarity(text1, text2, 3, 5);
                        break;
                    case 'fuzzyNgram6':
                        metricValues['Fuzzy 6-Word Phrases'] = fuzzyNgramSimilarity(text1, text2, 6, 13);
                        break;
                    case 'wordLevelFuzzy3':
                        metricValues['Word-Level 3-Word'] = wordLevelFuzzyNgramSimilarity(text1, text2, 3, 1);
                        break;
                    case 'wordLevelFuzzy5':
                        metricValues['Word-Level 5-Word'] = wordLevelFuzzyNgramSimilarity(text1, text2, 5, 2);
                        break;
                }
            });

            // Map metric IDs to display names
            const metricIdToName = {
                'cosine': 'Cosine',
                'jaccard': 'Jaccard',
                'ngram': 'N-gram',
                'sentenceVariance': 'Sentence Variance',
                'wordCount': 'Word Count',
                'avgSentenceLength': 'Avg Sentence Length',
                'temporalBurstiness': 'Temporal Burstiness',
                'pronounDensity': 'Pronoun Density',
                'transitionWords': 'Transition Words',
                'ngramPunctuation': 'N-gram with Punctuation',
                'wordNgram': '3-Word Phrases',
                'ngram4': 'N-gram 4-char',
                'ngram5': 'N-gram 5-char',
                'ner': 'Named Entity Recognition',
                'fuzzyNgram3': 'Fuzzy 3-Word Phrases',
                'fuzzyNgram6': 'Fuzzy 6-Word Phrases',
                'wordLevelFuzzy3': 'Word-Level 3-Word',
                'wordLevelFuzzy5': 'Word-Level 5-Word'
            };

            const metricTooltips = {
                'Cosine': 'Word frequency similarity (click to see calculation)',
                'Jaccard': 'Vocabulary overlap (click to see details)',
                'N-gram': 'Character sequence similarity (click to see shared n-grams)',
                'Sentence Variance': 'Sentence length variation patterns (click for details)',
                'Word Count': 'Total word count similarity (click for breakdown)',
                'Avg Sentence Length': 'Average sentence length (click for details)',
                'Temporal Burstiness': 'Word temporal clustering patterns (click to see word-by-word analysis)',
                'Pronoun Density': 'Pronoun usage frequency (click for breakdown)',
                'Transition Words': 'Transition word usage (click to see which words)',
                'N-gram with Punctuation': '3-char sequences with punctuation (click to see patterns)',
                '3-Word Phrases': 'Word-level n-grams (click to see shared phrases)',
                'N-gram 4-char': '4-character sequences (click to see patterns)',
                'N-gram 5-char': '5-character sequences (click to see patterns)',
                'Named Entity Recognition': 'Named entity similarity (people, places, organizations) - click for breakdown',
                'Fuzzy 3-Word Phrases': 'Levenshtein ≤5 edits on 3-word phrases - catches short paraphrasing (click for details)',
                'Fuzzy 6-Word Phrases': 'Levenshtein ≤13 edits on 6-word phrases - detects longer paraphrasing (click for details)',
                'Word-Level 3-Word': 'Word substitutions ≤1 - detects single word changes (click for details)',
                'Word-Level 5-Word': 'Word substitutions ≤2 - detects multi-word paraphrasing (click for details)'
            };

            const selectedNames = selectedIds.map(id => metricIdToName[id]).filter(n => n);

            // Always show Combined first, then only selected metrics
            const metrics = [
                {
                    name: 'Combined',
                    value: combinedScore,
                    tooltip: 'Average of selected metrics (click to see breakdown)'
                },
                ...selectedNames.map(name => ({
                    name: name,
                    value: metricValues[name],
                    tooltip: metricTooltips[name]
                }))
            ];

            // We need to store texts globally for the click handlers to access
            window.currentComparisonTexts = { text1, text2, id1, id2 };

            return metrics.map(m => `
                <div class="stat-badge" onclick='showMetricDetails("${m.name}", window.currentComparisonTexts.text1, window.currentComparisonTexts.text2, "${id1}", "${id2}")'
                     style="cursor: pointer; transition: transform 0.2s;"
                     onmouseover="this.style.transform='scale(1.05)'"
                     onmouseout="this.style.transform='scale(1)'">
                    ${m.name}: <strong>${(m.value * 100).toFixed(1)}%</strong>
                    <span class="info-icon">?
                        <span class="tooltip">${m.tooltip}</span>
                    </span>
                </div>
            `).join('');
        }

        function showMetricDetails(metricName, text1, text2, id1, id2) {
            const modal = document.getElementById('calculationModal');
            const title = document.getElementById('calculationTitle');
            const body = document.getElementById('calculationBody');

            title.textContent = `${metricName} - Calculation Details`;

            let detailsHTML = '';

            switch(metricName) {
                case 'Cosine':
                    detailsHTML = generateCosineDetails(text1, text2, id1, id2);
                    break;
                case 'Jaccard':
                    detailsHTML = generateJaccardDetails(text1, text2, id1, id2);
                    break;
                case 'N-gram':
                    detailsHTML = generateNgramDetails(text1, text2, id1, id2);
                    break;
                case 'Sentence Variance':
                    detailsHTML = generateSentenceVarianceDetails(text1, text2, id1, id2);
                    break;
                case 'Word Count':
                    detailsHTML = generateWordCountDetails(text1, text2, id1, id2);
                    break;
                case 'Avg Sentence Length':
                    detailsHTML = generateAvgSentenceLengthDetails(text1, text2, id1, id2);
                    break;
                case 'Temporal Burstiness':
                    detailsHTML = generateBurstinessDetails(text1, text2, id1, id2);
                    break;
                case 'Pronoun Density':
                    detailsHTML = generatePronounDensityDetails(text1, text2, id1, id2);
                    break;
                case 'Transition Words':
                    detailsHTML = generateTransitionWordsDetails(text1, text2, id1, id2);
                    break;
                case 'N-gram with Punctuation':
                    detailsHTML = generateNgramPunctuationDetails(text1, text2, id1, id2);
                    break;
                case '3-Word Phrases':
                    detailsHTML = generateWordNgramDetails(text1, text2, id1, id2);
                    break;
                case 'N-gram 4-char':
                    detailsHTML = generateNgram4Details(text1, text2, id1, id2);
                    break;
                case 'N-gram 5-char':
                    detailsHTML = generateNgram5Details(text1, text2, id1, id2);
                    break;
                case 'Named Entity Recognition':
                    detailsHTML = generateNERDetails(text1, text2, id1, id2);
                    break;
                case 'Fuzzy 3-Word Phrases':
                    detailsHTML = generateFuzzyNgram3Details(text1, text2, id1, id2);
                    break;
                case 'Fuzzy 6-Word Phrases':
                    detailsHTML = generateFuzzyNgram6Details(text1, text2, id1, id2);
                    break;
                case 'Word-Level 3-Word':
                    detailsHTML = generateWordLevelFuzzy3Details(text1, text2, id1, id2);
                    break;
                case 'Word-Level 5-Word':
                    detailsHTML = generateWordLevelFuzzy5Details(text1, text2, id1, id2);
                    break;
                case 'Combined':
                    detailsHTML = generateCombinedDetails(text1, text2, id1, id2);
                    break;
            }

            body.innerHTML = detailsHTML + `
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="closeCalculationModal()"
                        style="padding: 10px 30px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                        Close
                    </button>
                </div>
            `;

            modal.style.display = 'block';
        }

        function generateCosineDetails(text1, text2, id1, id2) {
            const words1 = tokenize(text1);
            const words2 = tokenize(text2);
            const freq1 = {};
            const freq2 = {};
            const allWords = new Set([...words1, ...words2]);

            words1.forEach(w => freq1[w] = (freq1[w] || 0) + 1);
            words2.forEach(w => freq2[w] = (freq2[w] || 0) + 1);

            let dotProduct = 0, mag1 = 0, mag2 = 0;
            const wordDetails = [];
            allWords.forEach(word => {
                const v1 = freq1[word] || 0;
                const v2 = freq2[word] || 0;
                if (v1 > 0 || v2 > 0) {
                    wordDetails.push({ word, v1, v2, product: v1 * v2 });
                }
                dotProduct += v1 * v2;
                mag1 += v1 * v1;
                mag2 += v2 * v2;
            });

            const similarity = (mag1 === 0 || mag2 === 0) ? 0 : dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));

            wordDetails.sort((a, b) => b.product - a.product);
            const topWords = wordDetails.slice(0, 20);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Cosine Similarity Formula</h3>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px;">
                        similarity = (A · B) / (||A|| × ||B||)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Dot Product (A · B)</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${dotProduct.toFixed(2)}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Magnitude ||A||</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${Math.sqrt(mag1).toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">√${mag1.toFixed(2)}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Magnitude ||B||</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${Math.sqrt(mag2).toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">√${mag2.toFixed(2)}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${dotProduct.toFixed(2)} / (${Math.sqrt(mag1).toFixed(2)} × ${Math.sqrt(mag2).toFixed(2)}) =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Top Contributing Words (by dot product contribution)</h4>
                <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 13px;">
                    <strong>Note:</strong> The cosine similarity calculation above uses <strong>every single word</strong> from both texts (${allWords.size} unique words total).
                    This table shows only the <strong>top 20 words</strong> that contributed most to the dot product, ranked by their contribution (frequency in text A × frequency in text B).
                </div>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #57068C; color: white;">
                            <th style="padding: 10px; text-align: left;">Word</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id1}</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id2}</th>
                            <th style="padding: 10px; text-align: center;">Product</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topWords.map((w, i) => `
                            <tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'};">
                                <td style="padding: 8px; font-weight: 600;">${escapeHtml(w.word)}</td>
                                <td style="padding: 8px; text-align: center;">${w.v1}</td>
                                <td style="padding: 8px; text-align: center;">${w.v2}</td>
                                <td style="padding: 8px; text-align: center; font-weight: bold;">${w.product}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function generateJaccardDetails(text1, text2, id1, id2) {
            const set1 = new Set(tokenize(text1));
            const set2 = new Set(tokenize(text2));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const only1 = [...set1].filter(x => !set2.has(x));
            const only2 = [...set2].filter(x => !set1.has(x));
            const shared = [...intersection];

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Jaccard Similarity Formula</h3>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px;">
                        similarity = |intersection| / |union| = |A ∩ B| / |A ∪ B|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Unique Words in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${set1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Unique Words in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${set2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared Words</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                </div>

                <div style="background: #fadbd8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Total Unique Words (Union)</h4>
                    <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <div>
                        <h4>Only in Respondent ${id1} (${only1.length})</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">
                            ${only1.slice(0, 50).join(', ')}${only1.length > 50 ? '...' : ''}
                        </div>
                    </div>
                    <div>
                        <h4>Shared Words (${shared.length})</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #d5f4e6; padding: 10px; border-radius: 5px; font-size: 12px;">
                            ${shared.slice(0, 50).join(', ')}${shared.length > 50 ? '...' : ''}
                        </div>
                    </div>
                    <div>
                        <h4>Only in Respondent ${id2} (${only2.length})</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">
                            ${only2.slice(0, 50).join(', ')}${only2.length > 50 ? '...' : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        function generateNgramDetails(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 3; i++) {
                    ngrams.add(clean.substring(i, i + 3));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram Similarity (3-character sequences)</h3>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px;">
                        similarity = |shared 3-grams| / |total unique 3-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 3-character Sequences (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(ng)}"</span>`).join(' ')}
                </div>
            `;
        }

        function generateNgram4Details(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 4; i++) {
                    ngrams.add(clean.substring(i, i + 4));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram 4-char Similarity (4-character sequences)</h3>
                    <p>Uses <strong>4-character n-grams</strong> instead of 3. Longer n-grams are more specific and less likely to match by chance, making them better at detecting deliberate copying or template use.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 4-grams| / |total unique 4-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">4-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">4-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 4-character Sequences (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(ng)}"</span>`).join(' ')}
                </div>
            `;
        }

        function generateNgram5Details(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 5; i++) {
                    ngrams.add(clean.substring(i, i + 5));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram 5-char Similarity (5-character sequences)</h3>
                    <p>Uses <strong>5-character n-grams</strong> for even more specificity. These longer sequences are highly distinctive and excellent for catching exact phrase matches and template reuse. Random matches are extremely rare at this length.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 5-grams| / |total unique 5-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">5-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">5-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 5-character Sequences (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(ng)}"</span>`).join(' ')}
                </div>
            `;
        }

        function generateNERDetails(text1, text2, id1, id2) {
            // Extract entities from both texts - all capitalized sequences (proper nouns)
            const extractEntities = (text) => {
                const wordCount = tokenize(text).length;

                // Extract sequences of capitalized words (proper nouns)
                // Updated to handle mixed case like "EdTech" or "iPhone"
                // Also handles abbreviations like "Mr. Smith", "Mt. Edna", "Rodeo Dr."
                const properNounPattern = /\b[A-Z][A-Za-z]*\.?(?:\s+[A-Z][A-Za-z]*\.?)*\b/g;

                // Remove punctuation from the text before matching to avoid "EdTech." vs "EdTech" issues
                const cleanText = text.replace(/([.!?;:,])/g, ' $1 ');
                const matches = cleanText.match(properNounPattern) || [];

                // Filter out common sentence-starting words and single letters
                const commonWords = new Set(['The', 'This', 'That', 'These', 'Those', 'A', 'An', 'I', 'It', 'He', 'She', 'We', 'They']);

                // Advanced filtering: Only include words that appear capitalized in mid-sentence positions
                // This prevents sentence-initial capitalization from being treated as named entities
                const sentenceBoundaryPattern = /[.!?]\s+/g;
                const sentences = text.split(sentenceBoundaryPattern);

                const validEntities = new Set();

                // Find words that appear in mid-sentence positions
                sentences.forEach(sentence => {
                    const sentenceMatches = sentence.match(/\b[A-Z][A-Za-z]*\.?(?:\s+[A-Z][A-Za-z]*\.?)*\b/g) || [];

                    // All words after the first are mid-sentence
                    sentenceMatches.slice(1).forEach(match => {
                        if (match.length > 1 && !commonWords.has(match)) {
                            validEntities.add(match);
                        }
                    });
                });

                // Now filter the original matches to only include valid entities
                const entities = matches.filter(m => validEntities.has(m));

                // Deduplicate
                const uniqueEntities = [...new Set(entities)];

                // Calculate density (per 100 words)
                const density = wordCount > 0 ? (uniqueEntities.length / wordCount) * 100 : 0;

                return {
                    entities: new Set(uniqueEntities.map(e => e.toLowerCase())),
                    entityList: uniqueEntities,
                    count: uniqueEntities.length,
                    density: density,
                    wordCount: wordCount
                };
            };

            const entities1 = extractEntities(text1);
            const entities2 = extractEntities(text2);

            // Find shared entities
            const sharedEntities = [...entities1.entities].filter(x => entities2.entities.has(x));

            const similarity = nerSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Named Entity Recognition (NER) Similarity</h3>
                    <p>Extracts all capitalized sequences (proper nouns) from both texts and compares them. Based on MIT 2024 study showing LLM-assisted writing has distinct NER patterns (Cramer's V = 0.55 vs 0.27 for human-only).</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Detection Method:</strong> Extracts all capitalized word sequences (e.g., "John Smith", "New York University", "MIT")
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Similarity Formula:</strong> Combines content similarity (60% weight - shared entities) with density similarity (40% weight - usage rate patterns)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Named Entity Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Metric</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;"><strong>Respondent ${id1}</strong></div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;"><strong>Respondent ${id2}</strong></div>
                        </div>

                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px;">Total Entities</div>
                        <div style="padding: 8px; background: #e8f4f8; border-radius: 3px; text-align: center; font-weight: bold;">${entities1.count}</div>
                        <div style="padding: 8px; background: #fef5e7; border-radius: 3px; text-align: center; font-weight: bold;">${entities2.count}</div>

                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px;">Density (per 100 words)</div>
                        <div style="padding: 8px; background: #e8f4f8; border-radius: 3px; text-align: center; font-weight: bold;">${entities1.density.toFixed(2)}</div>
                        <div style="padding: 8px; background: #fef5e7; border-radius: 3px; text-align: center; font-weight: bold;">${entities2.density.toFixed(2)}</div>

                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px;">Shared Entities</div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center; font-weight: bold; grid-column: 2 / 4;">${sharedEntities.length}</div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                </div>

                ${sharedEntities.length > 0 ? `
                <div style="background: #e8f5e9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #2e7d32;">✓ Shared Named Entities (${sharedEntities.length})</h4>
                    <div style="font-size: 14px; line-height: 1.8;">
                        ${sharedEntities.map(e => `<span style="background: #c8e6c9; padding: 5px 10px; margin: 3px; border-radius: 4px; display: inline-block; font-weight: 500;">${escapeHtml(e)}</span>`).join(' ')}
                    </div>
                </div>
                ` : '<div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; color: #666; font-style: italic; text-align: center;">No shared named entities found</div>'}

                <h4 style="margin: 20px 0 15px 0;">All Named Entities by Respondent</h4>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #e8f4f8; border-radius: 5px; text-align: center;">Respondent ${id1} (${entities1.count} entities)</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            <div style="font-size: 14px; line-height: 1.8;">
                                ${entities1.count > 0
                                    ? entities1.entityList.map(e => `<span style="background: #e3f2fd; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">${escapeHtml(e)}</span>`).join(' ')
                                    : '<span style="color: #666; font-style: italic;">No named entities found</span>'}
                            </div>
                        </div>
                    </div>

                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #fef5e7; border-radius: 5px; text-align: center;">Respondent ${id2} (${entities2.count} entities)</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            <div style="font-size: 14px; line-height: 1.8;">
                                ${entities2.count > 0
                                    ? entities2.entityList.map(e => `<span style="background: #fff3e0; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">${escapeHtml(e)}</span>`).join(' ')
                                    : '<span style="color: #666; font-style: italic;">No named entities found</span>'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateFuzzyNgram3Details(text1, text2, id1, id2) {
            const ngramSize = 3;
            const maxDistance = 5;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }

            // Find fuzzy matches with their Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = levenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = fuzzyNgramSimilarity(text1, text2, ngramSize, maxDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Fuzzy 3-Word Phrase Matching (Levenshtein Distance)</h3>
                    <p>Uses the Levenshtein distance algorithm to detect paraphrasing by finding 3-word phrases that are nearly identical with minor word substitutions. Based on MIT 2024 study's n-gram analysis approach.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Levenshtein distance measures the minimum number of single-character edits (insertions, deletions, substitutions) needed to transform one string into another. We apply this to 3-word phrases with a maximum edit distance of ${maxDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Why This Matters:</strong> Catches short paraphrasing like "helping students learn" vs "aiding students learn" or "working with people" vs "working with individuals"
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                    <p style="font-size: 13px; color: #666; margin: 10px 0 0 0;">
                        Calculated as: (total matches) / max(phrases in text 1, phrases in text 2)
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">✓ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                                <div style="font-size: 12px; color: #666; margin-top: 3px;">Distance: ${match.distance} (identical)</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">⚡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Similar phrases with edit distance ≤ ${maxDistance} (potential paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">dist: ${match.distance}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 3-word phrases within edit distance of ${maxDistance})
                </div>
                ` : ''}
            `;
        }

        function generateFuzzyNgram6Details(text1, text2, id1, id2) {
            const ngramSize = 6;
            const maxDistance = 13;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }

            // Find fuzzy matches with their Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = levenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = fuzzyNgramSimilarity(text1, text2, ngramSize, maxDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Fuzzy 6-Word Phrase Matching (Levenshtein Distance)</h3>
                    <p>Uses the Levenshtein distance algorithm to detect paraphrasing by finding 6-word phrases that are nearly identical with word substitutions. Based on MIT 2024 study's n-gram analysis approach.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Levenshtein distance measures the minimum number of single-character edits (insertions, deletions, substitutions) needed to transform one string into another. We apply this to 6-word phrases with a maximum edit distance of ${maxDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Why This Matters:</strong> Detects longer, more complex paraphrasing patterns like "passionate about helping students succeed in school" vs "passionate about supporting students succeed in college" (captures sentence-level similarities)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">6-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">6-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                    <p style="font-size: 13px; color: #666; margin: 10px 0 0 0;">
                        Calculated as: (total matches) / max(phrases in text 1, phrases in text 2)
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">✓ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                                <div style="font-size: 12px; color: #666; margin-top: 3px;">Distance: ${match.distance} (identical)</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">⚡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Similar phrases with edit distance ≤ ${maxDistance} (potential paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">dist: ${match.distance}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 6-word phrases within edit distance of ${maxDistance})
                </div>
                ` : ''}
            `;
        }

        function generateWordLevelFuzzy3Details(text1, text2, id1, id2) {
            const ngramSize = 3;
            const maxWordDistance = 1;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    words: words1.slice(i, i + ngramSize),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    words: words2.slice(i, i + ngramSize),
                    index: i
                });
            }

            // Find fuzzy matches with their word-level Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = wordLevelLevenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxWordDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize, maxWordDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Word-Level 3-Word Phrase Matching</h3>
                    <p>Uses <strong>word-level</strong> Levenshtein distance to detect paraphrasing by counting word substitutions. Perfect for catching single-word changes like "helping" → "aiding".</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Compares 3-word phrases and counts the minimum number of <em>word</em> substitutions/insertions/deletions needed to transform one phrase into another. Maximum word distance = ${maxWordDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Example:</strong> "helping students learn" vs "aiding students learn" = distance of <strong>1</strong> (one word substitution: helping→aiding)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">✓ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">⚡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Phrases with ≤${maxWordDistance} word difference (likely paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">${match.distance} word${match.distance > 1 ? 's' : ''}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 3-word phrases within ${maxWordDistance} word substitution)
                </div>
                ` : ''}
            `;
        }

        function generateWordLevelFuzzy5Details(text1, text2, id1, id2) {
            const ngramSize = 5;
            const maxWordDistance = 2;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    words: words1.slice(i, i + ngramSize),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    words: words2.slice(i, i + ngramSize),
                    index: i
                });
            }

            // Find fuzzy matches with their word-level Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = wordLevelLevenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxWordDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize, maxWordDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Word-Level 5-Word Phrase Matching</h3>
                    <p>Uses <strong>word-level</strong> Levenshtein distance to detect multi-word paraphrasing. Counts word substitutions across longer phrases to catch sentence-level similarities.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Compares 5-word phrases and counts the minimum number of <em>word</em> substitutions/insertions/deletions needed. Maximum word distance = ${maxWordDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Example:</strong> "passionate about helping students succeed" vs "passionate about supporting students excel" = distance of <strong>2</strong> (two word substitutions)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">5-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">5-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">✓ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">⚡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Phrases with ≤${maxWordDistance} word differences (likely paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">${match.distance} word${match.distance > 1 ? 's' : ''}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 5-word phrases within ${maxWordDistance} word substitutions)
                </div>
                ` : ''}
            `;
        }

        function generateSentenceVarianceDetails(text1, text2, id1, id2) {
            const getSentenceLengths = (text) => {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                return sentences.map(s => s.trim().split(/\s+/).length);
            };

            const lengths1 = getSentenceLengths(text1);
            const lengths2 = getSentenceLengths(text2);

            const variance1 = sentenceLengthVariance(text1);
            const variance2 = sentenceLengthVariance(text2);
            const similarity = sentenceVarianceSimilarity(text1, text2);

            const mean1 = lengths1.reduce((a,b) => a+b, 0) / lengths1.length;
            const mean2 = lengths2.reduce((a,b) => a+b, 0) / lengths2.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Sentence Variance Similarity</h3>
                    <p>Compares how sentence lengths vary within each text. Higher similarity means both texts have similar patterns of sentence length variation.</p>

                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 13px;">
                        <strong>How Variance is Calculated:</strong>
                        <ol style="margin: 5px 0 0 20px; padding: 0;">
                            <li>Calculate the mean (average) sentence length</li>
                            <li>For each sentence, find the difference from the mean and square it: (length - mean)²</li>
                            <li>Sum all the squared differences</li>
                            <li>Divide by the number of sentences</li>
                        </ol>
                        <p style="margin: 5px 0 0 0; font-family: monospace;">variance = Σ(length - mean)² / n</p>
                    </div>

                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = 1 - |variance_A - variance_B| / max(variance_A, variance_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p><strong>Sentences:</strong> ${lengths1.length}</p>
                        <p><strong>Mean Length:</strong> ${mean1.toFixed(2)} words</p>
                        <p><strong>Variance:</strong> ${variance1.toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666;">Sentence lengths: ${lengths1.join(', ')}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p><strong>Sentences:</strong> ${lengths2.length}</p>
                        <p><strong>Mean Length:</strong> ${mean2.toFixed(2)} words</p>
                        <p><strong>Variance:</strong> ${variance2.toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666;">Sentence lengths: ${lengths2.join(', ')}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        1 - |${variance1.toFixed(2)} - ${variance2.toFixed(2)}| / ${Math.max(variance1, variance2).toFixed(2)} =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>
            `;
        }

        function generateWordCountDetails(text1, text2, id1, id2) {
            const count1 = tokenize(text1).length;
            const count2 = tokenize(text2).length;
            const similarity = wordCountSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Word Count Similarity</h3>
                    <p>Compares total word counts between texts.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = 1 - |count_A - count_B| / max(count_A, count_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${count1} words</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${count2} words</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        Difference: ${Math.abs(count1 - count2)} words<br>
                        1 - ${Math.abs(count1 - count2)} / ${Math.max(count1, count2)} =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>
            `;
        }

        function generateAvgSentenceLengthDetails(text1, text2, id1, id2) {
            const getAvg = (text) => {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const lengths = sentences.map(s => s.trim().split(/\s+/).length);
                return lengths.reduce((a,b) => a+b, 0) / lengths.length;
            };

            const avg1 = getAvg(text1);
            const avg2 = getAvg(text2);
            const similarity = avgSentenceLengthSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Average Sentence Length Similarity</h3>
                    <p>Compares the average number of words per sentence.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = 1 - |avg_A - avg_B| / max(avg_A, avg_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${avg1.toFixed(2)} words/sentence</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${avg2.toFixed(2)} words/sentence</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        1 - |${avg1.toFixed(2)} - ${avg2.toFixed(2)}| / ${Math.max(avg1, avg2).toFixed(2)} =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>
            `;
        }

        function generateBurstinessDetails(text1, text2, id1, id2) {
            const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i',
                                       'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
                                       'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she',
                                       'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their']);

            // Track word positions for each text
            const getWordPositions = (text) => {
                const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
                const positions = {};
                words.forEach((word, idx) => {
                    if (!stopWords.has(word) && word.length > 3) {
                        if (!positions[word]) positions[word] = [];
                        positions[word].push(idx);
                    }
                });
                return { positions, totalWords: words.length };
            };

            const data1 = getWordPositions(text1);
            const data2 = getWordPositions(text2);

            // Find common significant words (appear at least 2 times in each)
            const commonWords = Object.keys(data1.positions).filter(word =>
                data2.positions[word] &&
                data1.positions[word].length >= 2 &&
                data2.positions[word].length >= 2
            ).slice(0, 20);

            const burstScores = commonWords.map(word => {
                const b1 = calculateTemporalBurstiness(data1.positions[word], data1.totalWords);
                const b2 = calculateTemporalBurstiness(data2.positions[word], data2.totalWords);
                return {
                    word,
                    b1,
                    b2,
                    count1: data1.positions[word].length,
                    count2: data2.positions[word].length,
                    diff: Math.abs(b1 - b2),
                    sim: 1 - Math.abs(b1 - b2)
                };
            });

            const similarity = temporalBurstinessSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Temporal Burstiness Similarity (Cui et al. 2017)</h3>
                    <p>Measures temporal clustering of words using word positions throughout the text.</p>
                    <div style="font-family: monospace; background: white; padding: 12px; border-radius: 3px; margin: 10px 0; font-size: 13px; line-height: 1.8;">
                        <strong>Calculating μ for each word in each respondent:</strong><br><br>
                        <div style="background: #f8f9fa; padding: 8px; margin: 8px 0; border-left: 3px solid #57068C;">
                        <strong>Example:</strong> "The cat sat on <u>the</u> mat and <u>the</u> cat ran"<br>
                        Total words (T) = 10, word "the" at positions [0, 4, 7], frequency (f) = 3
                        </div>
                        1. <strong>Scan positions t</strong> from 0 to T (each word index)<br>
                        2. <strong>At each position t</strong>, count occurrences so far: C(t)<br>
                        <span style="font-size: 11px; color: #666; margin-left: 15px;">
                        t=0: C(0)=1, t=1: C(1)=1, t=4: C(4)=2, t=7: C(7)=3...
                        </span><br>
                        3. <strong>Compare to uniform</strong>: Linear reference = (f/T) × t<br>
                        4. <strong>Calculate area</strong> between C(t) and linear reference<br>
                        5. <strong>μ = (2 × max_area) / (f × T)</strong><br><br>
                        <strong>μ = 1</strong>: Word appears in concentrated bursts<br>
                        <strong>μ = 0</strong>: Word distributed uniformly<br><br>
                        <strong>Similarity</strong> = 1 - |μ_A - μ_B|<br>
                        <strong>Final</strong> = average across ${commonWords.length} common words
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Temporal Burstiness Similarity</h4>
                    <p style="font-size: 24px; font-weight: bold; margin: 0;"><strong>${(similarity * 100).toFixed(1)}%</strong></p>
                    <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Based on ${commonWords.length} common words</p>
                </div>

                <h4>Temporal Burstiness Scores for Common Words</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #57068C; color: white;">
                            <th style="padding: 10px; text-align: left;">Word</th>
                            <th style="padding: 10px; text-align: center;">Count</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id1} μ</th>
                            <th style="padding: 10px; text-align: center;">Count</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id2} μ</th>
                            <th style="padding: 10px; text-align: center;">Difference</th>
                            <th style="padding: 10px; text-align: center;">Similarity</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${burstScores.map((s, i) => `
                            <tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'};">
                                <td style="padding: 8px; font-weight: 600;">${escapeHtml(s.word)}</td>
                                <td style="padding: 8px; text-align: center; color: #666;">${s.count1}</td>
                                <td style="padding: 8px; text-align: center;">${s.b1.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: center; color: #666;">${s.count2}</td>
                                <td style="padding: 8px; text-align: center;">${s.b2.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: center;">${s.diff.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: center; font-weight: bold;">${(s.sim * 100).toFixed(1)}%</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function generatePronounDensityDetails(text1, text2, id1, id2) {
            const pronouns = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
                            'you', 'your', 'yours', 'yourself', 'yourselves',
                            'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
                            'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
                            'i\'m', 'i\'ve', 'i\'d', 'i\'ll', 'you\'re', 'you\'ve', 'you\'d', 'you\'ll',
                            'he\'s', 'he\'d', 'he\'ll', 'she\'s', 'she\'d', 'she\'ll', 'it\'s', 'it\'d', 'it\'ll',
                            'we\'re', 'we\'ve', 'we\'d', 'we\'ll', 'they\'re', 'they\'ve', 'they\'d', 'they\'ll'];

            const words1 = tokenize(text1);
            const words2 = tokenize(text2);

            // Find actual pronouns used in each text
            const foundPronouns1 = words1.filter(w => pronouns.includes(w.toLowerCase()));
            const foundPronouns2 = words2.filter(w => pronouns.includes(w.toLowerCase()));

            // Get unique pronouns and their counts
            const pronounFreq1 = {};
            const pronounFreq2 = {};
            foundPronouns1.forEach(p => {
                const lower = p.toLowerCase();
                pronounFreq1[lower] = (pronounFreq1[lower] || 0) + 1;
            });
            foundPronouns2.forEach(p => {
                const lower = p.toLowerCase();
                pronounFreq2[lower] = (pronounFreq2[lower] || 0) + 1;
            });

            const pronounCount1 = foundPronouns1.length;
            const pronounCount2 = foundPronouns2.length;

            const density1 = words1.length > 0 ? pronounCount1 / words1.length : 0;
            const density2 = words2.length > 0 ? pronounCount2 / words2.length : 0;

            const similarity = pronounDensitySimilarity(text1, text2);

            // Sort pronouns by frequency for display
            const sortedPronouns1 = Object.entries(pronounFreq1).sort((a, b) => b[1] - a[1]);
            const sortedPronouns2 = Object.entries(pronounFreq2).sort((a, b) => b[1] - a[1]);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Pronoun Density Similarity</h3>
                    <p>Compares the proportion of pronouns (I, me, you, he, she, it, they, etc.) in each text.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        density = pronoun_count / total_words<br>
                        similarity = 1 - |density_A - density_B| / max(density_A, density_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p><strong>Total Words:</strong> ${words1.length}</p>
                        <p><strong>Pronouns:</strong> ${pronounCount1}</p>
                        <p><strong>Density:</strong> ${(density1 * 100).toFixed(2)}%</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p><strong>Total Words:</strong> ${words2.length}</p>
                        <p><strong>Pronouns:</strong> ${pronounCount2}</p>
                        <p><strong>Density:</strong> ${(density2 * 100).toFixed(2)}%</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    ${density1 === 0 && density2 === 0 ? `
                        <p style="font-size: 16px; margin: 0 0 10px 0;">
                            Both texts have 0 pronouns → Perfect similarity
                        </p>
                        <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                            100.0%
                        </p>
                    ` : `
                        <p style="font-size: 16px; margin: 0 0 10px 0;">
                            1 - |${(density1 * 100).toFixed(2)} - ${(density2 * 100).toFixed(2)}| / ${(Math.max(density1, density2) * 100).toFixed(2)} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                        </p>
                    `}
                </div>

                <h4 style="margin: 20px 0 15px 0;">Pronouns Found in Each Text</h4>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #e8f4f8; border-radius: 5px; text-align: center;">Respondent ${id1}</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            ${sortedPronouns1.length > 0 ? `
                                <div style="font-size: 14px; line-height: 1.8;">
                                    ${sortedPronouns1.map(([pronoun, count]) =>
                                        `<span style="background: #e3f2fd; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">
                                            ${escapeHtml(pronoun)} <span style="color: #666; font-size: 12px;">(${count})</span>
                                        </span>`
                                    ).join(' ')}
                                </div>
                            ` : '<span style="color: #666; font-style: italic;">No pronouns found</span>'}
                        </div>
                    </div>

                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #fef5e7; border-radius: 5px; text-align: center;">Respondent ${id2}</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            ${sortedPronouns2.length > 0 ? `
                                <div style="font-size: 14px; line-height: 1.8;">
                                    ${sortedPronouns2.map(([pronoun, count]) =>
                                        `<span style="background: #fff3e0; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">
                                            ${escapeHtml(pronoun)} <span style="color: #666; font-size: 12px;">(${count})</span>
                                        </span>`
                                    ).join(' ')}
                                </div>
                            ` : '<span style="color: #666; font-style: italic;">No pronouns found</span>'}
                        </div>
                    </div>
                </div>
            `;
        }

        function generateTransitionWordsDetails(text1, text2, id1, id2) {
            const transitionWords = ['however', 'therefore', 'moreover', 'furthermore', 'nevertheless',
                                   'consequently', 'thus', 'hence', 'accordingly', 'meanwhile',
                                   'additionally', 'likewise', 'similarly', 'conversely', 'instead',
                                   'otherwise', 'namely', 'specifically', 'indeed', 'certainly'];

            const words1 = tokenize(text1);
            const words2 = tokenize(text2);

            const transCount1 = words1.filter(w => transitionWords.includes(w.toLowerCase())).length;
            const transCount2 = words2.filter(w => transitionWords.includes(w.toLowerCase())).length;

            const density1 = words1.length > 0 ? transCount1 / words1.length : 0;
            const density2 = words2.length > 0 ? transCount2 / words2.length : 0;

            const similarity = transitionWordsSimilarity(text1, text2);

            // Find which specific transition words were used
            const used1 = transitionWords.filter(tw => words1.some(w => w.toLowerCase() === tw));
            const used2 = transitionWords.filter(tw => words2.some(w => w.toLowerCase() === tw));

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Transition Words Similarity</h3>
                    <p>Compares the use of transition words (however, therefore, moreover, etc.) in each text.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        density = transition_word_count / total_words<br>
                        similarity = 1 - |density_A - density_B| / max(density_A, density_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p><strong>Total Words:</strong> ${words1.length}</p>
                        <p><strong>Transition Words:</strong> ${transCount1}</p>
                        <p><strong>Density:</strong> ${(density1 * 100).toFixed(2)}%</p>
                        <p style="font-size: 11px; color: #666; margin-top: 10px;"><strong>Used:</strong> ${used1.length > 0 ? used1.join(', ') : 'none'}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p><strong>Total Words:</strong> ${words2.length}</p>
                        <p><strong>Transition Words:</strong> ${transCount2}</p>
                        <p><strong>Density:</strong> ${(density2 * 100).toFixed(2)}%</p>
                        <p style="font-size: 11px; color: #666; margin-top: 10px;"><strong>Used:</strong> ${used2.length > 0 ? used2.join(', ') : 'none'}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${density1 === 0 && density2 === 0 ?
                            'Both texts have 0 transition words = <strong>100% similar</strong>' :
                            `1 - |${(density1 * 100).toFixed(2)} - ${(density2 * 100).toFixed(2)}| / ${(Math.max(density1, density2) * 100).toFixed(2)} =
                            <strong>${(similarity * 100).toFixed(1)}%</strong>`
                        }
                    </p>
                </div>
            `;
        }

        function generateCombinedDetails(text1, text2, id1, id2) {
            const selected = getSelectedMetrics();

            // Calculate all metrics (raw scores for display)
            const metrics = {
                cosine: cosineSimilarity(text1, text2),
                jaccard: jaccardSimilarity(text1, text2),
                ngram: ngramSimilarity(text1, text2, 3),
                sentenceVariance: sentenceVarianceSimilarity(text1, text2),
                wordCount: wordCountSimilarity(text1, text2),
                avgSentenceLength: avgSentenceLengthSimilarity(text1, text2),
                // burstiness: removed - using corpus-level analysis instead
                pronounDensity: pronounDensitySimilarity(text1, text2),
                transitionWords: transitionWordsSimilarity(text1, text2),
                ngramPunctuation: ngramWithPunctuationSimilarity(text1, text2, 3),
                wordNgram: wordNgramSimilarity(text1, text2, 3),
                ngram4: ngram4Similarity(text1, text2),
                ngram5: ngram5Similarity(text1, text2),
                ner: nerSimilarity(text1, text2),
                temporalBurstiness: temporalBurstinessSimilarity(text1, text2),
                fuzzyNgram3: fuzzyNgramSimilarity(text1, text2, 3, 5),
                fuzzyNgram6: fuzzyNgramSimilarity(text1, text2, 6, 13),
                wordLevelFuzzy3: wordLevelFuzzyNgramSimilarity(text1, text2, 3, 1),
                wordLevelFuzzy5: wordLevelFuzzyNgramSimilarity(text1, text2, 5, 2)
            };

            const metricNames = {
                cosine: 'Cosine',
                jaccard: 'Jaccard',
                ngram: 'N-gram',
                sentenceVariance: 'Sentence Variance',
                wordCount: 'Word Count',
                avgSentenceLength: 'Avg Sentence Length',
                burstiness: 'Burstiness',
                pronounDensity: 'Pronoun Density',
                transitionWords: 'Transition Words',
                ngramPunctuation: 'N-gram with Punctuation',
                wordNgram: '3-Word Phrases',
                ngram4: 'N-gram 4-char',
                ngram5: 'N-gram 5-char',
                ner: 'Named Entities',
                temporalBurstiness: 'Temporal Burstiness',
                fuzzyNgram3: 'Fuzzy 3-Word',
                fuzzyNgram6: 'Fuzzy 6-Word',
                wordLevelFuzzy3: 'Word-Level 3-Word',
                wordLevelFuzzy5: 'Word-Level 5-Word'
            };

            // Find the actual pair in allSimilarityPairs to get the pre-calculated combined similarity
            let combined = 0;
            const actualPair = allSimilarityPairs.find(p =>
                (p.id1 === id1 && p.id2 === id2) || (p.id1 === id2 && p.id2 === id1)
            );

            if (actualPair) {
                // Use the pre-calculated similarity from the analysis
                combined = actualPair.similarity;
            } else {
                // Fallback: calculate it (shouldn't normally happen)
                combined = calculateCombinedSimilarity(text1, text2);
            }

            const count = selected.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Combined Similarity Score</h3>
                    <p>The combined score uses <strong>normalized, weighted averaging</strong> of selected metrics:</p>
                    <div style="font-family: monospace; background: white; padding: 12px; border-radius: 3px; margin: 10px 0; font-size: 13px; line-height: 1.8;">
                        <strong>Step 1: Normalize each metric</strong><br>
                        normalized = (score - min) / (max - min)<br>
                        <span style="font-size: 11px; color: #666;">Scales all metrics to [0,1] using min/max across all pairs</span><br><br>
                        <strong>Step 2: Apply weights</strong><br>
                        combined = Σ(normalized × weight) / Σ(weight)<br>
                        <span style="font-size: 11px; color: #666;">Higher weights = more influence on final score</span>
                    </div>
                    <p style="font-size: 12px; color: #666; margin: 10px 0 0 0;">
                        This ensures high-signal metrics (e.g., fuzzy matching) aren't drowned out by low-signal metrics (e.g., word count). Configure metrics and weights via Metric Settings.
                    </p>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Combined Score</h4>
                    <p style="font-size: 32px; font-weight: bold; margin: 0;"><strong>${(combined * 100).toFixed(1)}%</strong></p>
                    <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Based on ${count} selected metrics</p>
                </div>

                <h4>Individual Metric Contributions</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #57068C; color: white;">
                            <th style="padding: 10px; text-align: left;">Metric</th>
                            <th style="padding: 10px; text-align: center;">Score</th>
                            <th style="padding: 10px; text-align: center;">Selected?</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${Object.keys(metrics).map((key, i) => `
                            <tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'}; ${selected.includes(key) ? 'font-weight: bold;' : 'opacity: 0.5;'}">
                                <td style="padding: 8px;">${metricNames[key]}</td>
                                <td style="padding: 8px; text-align: center;">${(metrics[key] * 100).toFixed(1)}%</td>
                                <td style="padding: 8px; text-align: center;">${selected.includes(key) ? '✓' : '✗'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>

                <div style="background: #fff3cd; padding: 15px; border-radius: 5px;">
                    <p style="margin: 0; font-size: 14px;">
                        <strong>Calculation:</strong> (${selected.map(m => (metrics[m] * 100).toFixed(1)).join(' + ')}) / ${count} = ${(combined * 100).toFixed(1)}%
                    </p>
                </div>
            `;
        }

        function generateNgramPunctuationDetails(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase();
                for (let i = 0; i <= clean.length - 3; i++) {
                    ngrams.add(clean.substring(i, i + 3));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram with Punctuation (3-character sequences)</h3>
                    <p>This metric is identical to regular N-gram but <strong>keeps punctuation patterns</strong>. This can reveal similarities in writing style, formatting habits, and punctuation usage that might indicate AI-generated text or template use.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 3-grams| / |total unique 3-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 3-character Sequences with Punctuation (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => {
                        const display = ng.replace(/\s/g, '·'); // Show spaces as middle dots
                        return `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(display)}"</span>`;
                    }).join(' ')}
                </div>
            `;
        }

        function generateWordNgramDetails(text1, text2, id1, id2) {
            const getWordNgrams = (text) => {
                const words = tokenize(text);
                const ngrams = new Set();
                for (let i = 0; i <= words.length - 3; i++) {
                    ngrams.add(words.slice(i, i + 3).join(' ').toLowerCase());
                }
                return ngrams;
            };

            const ngrams1 = getWordNgrams(text1);
            const ngrams2 = getWordNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 50);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">3-Word Phrase Similarity</h3>
                    <p>This metric analyzes <strong>word-level n-grams</strong> (sequences of 3 consecutive words) rather than character sequences. This is excellent for detecting:</p>
                    <ul style="margin: 5px 0 0 20px;">
                        <li>Copy-pasted sentences or paragraphs</li>
                        <li>Template phrases or boilerplate text</li>
                        <li>Common AI-generated phrase patterns</li>
                        <li>Semantic similarity beyond just vocabulary overlap</li>
                    </ul>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 3-word phrases| / |total unique 3-word phrases|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Phrases in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Phrases in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Shared 3-Word Phrases (${Math.min(50, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 300px; overflow-y: auto;">
                    ${shared.map((phrase, i) => `
                        <div style="background: ${i % 2 === 0 ? '#e8f8f5' : 'white'}; padding: 8px; margin: 5px 0; border-left: 3px solid #27ae60; border-radius: 3px;">
                            "${escapeHtml(phrase)}"
                        </div>
                    `).join('')}
                </div>

                ${intersection.size > 50 ? `
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-top: 15px; font-size: 13px;">
                        <strong>Note:</strong> Showing first 50 of ${intersection.size} shared phrases. High phrase overlap often indicates copy-paste, templates, or AI generation.
                    </div>
                ` : ''}
            `;
        }

        function cosineSimilarity(text1, text2) {
            const words1 = tokenize(text1);
            const words2 = tokenize(text2);
            const freq1 = {};
            const freq2 = {};
            const allWords = new Set([...words1, ...words2]);

            words1.forEach(w => freq1[w] = (freq1[w] || 0) + 1);
            words2.forEach(w => freq2[w] = (freq2[w] || 0) + 1);

            let dotProduct = 0, mag1 = 0, mag2 = 0;
            allWords.forEach(word => {
                const v1 = freq1[word] || 0;
                const v2 = freq2[word] || 0;
                dotProduct += v1 * v2;
                mag1 += v1 * v1;
                mag2 += v2 * v2;
            });

            return (mag1 === 0 || mag2 === 0) ? 0 : dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));
        }

        function jaccardSimilarity(text1, text2) {
            const set1 = new Set(tokenize(text1));
            const set2 = new Set(tokenize(text2));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngramSimilarity(text1, text2, n = 3) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - n; i++) {
                    ngrams.add(clean.substring(i, i + n));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngramWithPunctuationSimilarity(text1, text2, n = 3) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase(); // Keep punctuation, just lowercase
                for (let i = 0; i <= clean.length - n; i++) {
                    ngrams.add(clean.substring(i, i + n));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function wordNgramSimilarity(text1, text2, n = 3) {
            const getWordNgrams = (text) => {
                const words = tokenize(text); // Use existing tokenize function
                const ngrams = new Set();
                for (let i = 0; i <= words.length - n; i++) {
                    ngrams.add(words.slice(i, i + n).join(' ').toLowerCase());
                }
                return ngrams;
            };

            const ngrams1 = getWordNgrams(text1);
            const ngrams2 = getWordNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngram4Similarity(text1, text2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 4; i++) {
                    ngrams.add(clean.substring(i, i + 4));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngram5Similarity(text1, text2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 5; i++) {
                    ngrams.add(clean.substring(i, i + 5));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function nerSimilarity(text1, text2) {
            // Extract named entities - all capitalized sequences (proper nouns)
            const extractEntities = (text) => {
                const wordCount = tokenize(text).length;

                // Extract sequences of capitalized words (proper nouns)
                // Matches: "John Smith", "New York University", "MIT", "EdTech", etc.
                // Updated to handle mixed case like "EdTech" or "iPhone"
                const properNounPattern = /\b[A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)*\b/g;

                // Remove punctuation from the text before matching to avoid "EdTech." vs "EdTech" issues
                const cleanText = text.replace(/([.!?;:,])/g, ' $1 ');
                const matches = cleanText.match(properNounPattern) || [];

                // Filter out common sentence-starting words and single letters
                const commonWords = new Set(['The', 'This', 'That', 'These', 'Those', 'A', 'An', 'I', 'It', 'He', 'She', 'We', 'They']);

                // Advanced filtering: Only include words that appear capitalized in mid-sentence positions
                // This prevents sentence-initial capitalization from being treated as named entities
                const sentenceBoundaryPattern = /[.!?]\s+/g;
                const sentences = text.split(sentenceBoundaryPattern);

                const validEntities = new Set();

                // Find words that appear in mid-sentence positions
                sentences.forEach(sentence => {
                    const sentenceMatches = sentence.match(/\b[A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)*\b/g) || [];

                    // All words after the first are mid-sentence
                    sentenceMatches.slice(1).forEach(match => {
                        if (match.length > 1 && !commonWords.has(match)) {
                            validEntities.add(match);
                        }
                    });
                });

                // Now filter the original matches to only include valid entities
                const entities = matches.filter(m => validEntities.has(m));

                // Deduplicate
                const uniqueEntities = [...new Set(entities)];

                // Calculate density (per 100 words)
                const density = wordCount > 0 ? (uniqueEntities.length / wordCount) * 100 : 0;

                return {
                    entities: new Set(uniqueEntities.map(e => e.toLowerCase())),
                    entityList: uniqueEntities,
                    count: uniqueEntities.length,
                    density: density,
                    wordCount: wordCount
                };
            };

            const entities1 = extractEntities(text1);
            const entities2 = extractEntities(text2);

            // Calculate Jaccard similarity
            const intersection = new Set([...entities1.entities].filter(x => entities2.entities.has(x)));
            const union = new Set([...entities1.entities, ...entities2.entities]);
            const contentSimilarity = union.size === 0 ? 0 : intersection.size / union.size;

            // Calculate density similarity (how similar are the usage rates?)
            const densitySimilarity = (() => {
                if (entities1.density === 0 && entities2.density === 0) return 1;
                const max = Math.max(entities1.density, entities2.density);
                return max === 0 ? 0 : 1 - (Math.abs(entities1.density - entities2.density) / max);
            })();

            // Weighted average: 60% content similarity (shared entities), 40% density similarity (usage patterns)
            return (contentSimilarity * 0.6) + (densitySimilarity * 0.4);
        }

        // Levenshtein distance - minimum edits needed to transform one string into another
        // Character-level Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            // Initialize matrix
            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            // Fill matrix
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1[i - 1] === str2[j - 1]) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            matrix[i][j - 1] + 1,     // insertion
                            matrix[i - 1][j] + 1      // deletion
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        // Word-level Levenshtein distance - counts word substitutions/insertions/deletions
        function wordLevelLevenshteinDistance(phrase1, phrase2) {
            const words1 = phrase1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = phrase2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const len1 = words1.length;
            const len2 = words2.length;
            const matrix = [];

            // Initialize matrix
            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            // Fill matrix - comparing words instead of characters
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (words1[i - 1] === words2[j - 1]) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // word substitution
                            matrix[i][j - 1] + 1,     // word insertion
                            matrix[i - 1][j] + 1      // word deletion
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        // Fuzzy n-gram matching using character-level Levenshtein distance
        function fuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxDistance = 3) {
            // Extract word-level n-grams
            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push(words1.slice(i, i + ngramSize).join(' '));
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push(words2.slice(i, i + ngramSize).join(' '));
            }

            if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

            // Find fuzzy matches using Levenshtein distance
            const matches = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = levenshteinDistance(ng1, ng2);
                    // Match if distance is within threshold
                    if (distance <= maxDistance) {
                        matches.add(`${idx1}-${idx2}`);
                    }
                });
            });

            // Calculate similarity as proportion of n-grams that have fuzzy matches
            const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
            return matches.size / totalNgrams;
        }

        // Word-level fuzzy n-gram matching - detects paraphrasing by counting word substitutions
        function wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxWordDistance = 1) {
            // Extract word-level n-grams
            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams (arrays of words)
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push(words1.slice(i, i + ngramSize));
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push(words2.slice(i, i + ngramSize));
            }

            if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

            // Find fuzzy matches using word-level Levenshtein distance
            const matches = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    // Compare word arrays
                    const distance = wordLevelLevenshteinDistance(ng1.join(' '), ng2.join(' '));
                    // Match if word-level distance is within threshold
                    if (distance <= maxWordDistance) {
                        matches.add(`${idx1}-${idx2}`);
                    }
                });
            });

            // Calculate similarity as proportion of n-grams that have fuzzy matches
            const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
            return matches.size / totalNgrams;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function exportResults() {
            const report = {
                timestamp: new Date().toISOString(),
                column: headers[currentColumn],
                totalResponses: analysisResults.responses.length,
                metrics: {
                    lexicalDiversity: analysisResults.diversity,
                    phraseAnalysis: {
                        highFrequencyCount: analysisResults.phrases.highFreq.length,
                        outlierCount: analysisResults.phrases.outliers.length,
                        maxPhraseRate: analysisResults.phrases.maxPhraseRate,
                        topPhrases: analysisResults.phrases.topPhrases.slice(0, 20)
                    },
                    similarity: {
                        mean: analysisResults.similarity.mean,
                        stdDev: analysisResults.similarity.stdDev,
                        highSimilarityCount: analysisResults.similarity.highSimilarity,
                        highSimilarityPct: analysisResults.similarity.highSimilarityPct
                    }
                }
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `homogeneity-analysis-${Date.now()}.json`;
            a.click();
        }

        // ========== DYNAMIC BURSTINESS ANALYSIS ==========
        // Based on: "Dynamic burstiness of word-occurrence and network modularity in textbook systems"
        // Cui et al., Physica A, 2017

        /**
         * Track word occurrences with position information
         * @param {string} text - The text to analyze
         * @returns {Object} - Map of word -> array of positions
         */
        function trackWordPositions(text) {
            const words = text.toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(w => w.length > 2);

            const positions = {};
            words.forEach((word, index) => {
                if (!positions[word]) {
                    positions[word] = [];
                }
                positions[word].push(index);
            });

            return { positions, totalWords: words.length };
        }

        /**
         * Calculate cumulative count C(t) for a word
         * @param {Array} occurrences - Array of occurrence positions
         * @param {number} totalWords - Total number of words in document
         * @returns {Function} - Function that returns cumulative count at position t
         */
        function getCumulativeCount(occurrences, totalWords) {
            return function(t) {
                return occurrences.filter(pos => pos <= t).length;
            };
        }

        /**
         * Calculate core temporal burstiness measure μ (Cui et al. 2017)
         * μ = max_k { (1/fT) ∫ |C(t) - [f/T(t - t_k) + k - 1]| dt }
         *
         * @param {Array} occurrences - Sorted array of occurrence positions
         * @param {number} totalWords - Total number of words
         * @returns {number} - Burstiness measure (0 to 1)
         */
        function calculateTemporalBurstiness(occurrences, totalWords) {
            if (occurrences.length === 0 || totalWords === 0) return 0;

            const f = occurrences.length; // frequency
            const T = totalWords;

            // Pre-compute cumulative count for efficiency (avoid repeated filtering)
            const sortedOccurrences = [...occurrences].sort((a, b) => a - b);

            let maxArea = 0;

            // Limit steps for performance - use fewer steps for larger documents
            const steps = Math.min(200, T); // Reduced from 1000 to 200
            const dt = T / steps;

            // For each occurrence k, calculate area
            for (let k = 0; k < Math.min(f, 20); k++) { // Limit to first 20 occurrence points
                const tk = sortedOccurrences[k];
                let area = 0;

                // Pre-calculate cumulative counts at sampled points
                let occIdx = 0;
                for (let i = 0; i < steps; i++) {
                    const t = i * dt;

                    // Efficient cumulative count using sorted array
                    while (occIdx < f && sortedOccurrences[occIdx] <= t) {
                        occIdx++;
                    }
                    const Ct = occIdx;

                    // Linear interpolation: f/T * (t - tk) + k
                    // Note: Cui et al. (2017) paper uses (k-1) with 1-based indexing;
                    // we use k with 0-based indexing (mathematically equivalent, verified)
                    const linearValue = (f / T) * (t - tk) + k;

                    // |C(t) - linear|
                    const diff = Math.abs(Ct - linearValue);
                    area += diff * dt;
                }

                if (area > maxArea) {
                    maxArea = area;
                }
            }

            // Normalize by fT/2 (area of half square)
            const normalized = (2 * maxArea) / (f * T);

            return Math.min(1, normalized); // Clamp to [0, 1]
        }

        /**
         * Calculate inter-event intervals (τ)
         * @param {Array} occurrences - Sorted array of occurrence positions
         * @returns {Array} - Array of intervals between consecutive occurrences
         */
        function calculateIntervals(occurrences) {
            const intervals = [];
            for (let i = 1; i < occurrences.length; i++) {
                intervals.push(occurrences[i] - occurrences[i-1]);
            }
            return intervals;
        }

        /**
         * Calculate memory effect M
         * M = (1/(f-1)) Σ [(τ_k - m)(τ_{k+1} - m)] / σ²
         *
         * @param {Array} intervals - Array of inter-event intervals
         * @returns {number} - Memory correlation coefficient
         */
        function calculateMemoryEffect(intervals) {
            if (intervals.length < 2) return 0;

            const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const variance = intervals.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / intervals.length;

            if (variance === 0) return 0;

            let correlation = 0;
            for (let k = 0; k < intervals.length - 1; k++) {
                correlation += (intervals[k] - mean) * (intervals[k+1] - mean);
            }

            const M = correlation / ((intervals.length - 1) * variance);
            return M;
        }

        /**
         * Generate interval-shuffled random textbook (IRT)
         * Randomizes the sequence but keeps interval distribution unchanged
         * @param {Array} occurrences - Original occurrence positions
         * @param {number} totalWords - Total words in document
         * @returns {Array} - Shuffled occurrence positions
         */
        function generateIRT(occurrences, totalWords) {
            if (occurrences.length === 0) return [];

            const intervals = calculateIntervals(occurrences);

            // Shuffle intervals
            const shuffledIntervals = [...intervals].sort(() => Math.random() - 0.5);

            // Reconstruct positions with shuffled intervals
            const newOccurrences = [Math.floor(Math.random() * totalWords)];
            for (const interval of shuffledIntervals) {
                const next = newOccurrences[newOccurrences.length - 1] + interval;
                if (next < totalWords) {
                    newOccurrences.push(next);
                }
            }

            return newOccurrences.sort((a, b) => a - b);
        }

        /**
         * Generate completely random textbook (CRT)
         * @param {number} frequency - Number of occurrences
         * @param {number} totalWords - Total words in document
         * @returns {Array} - Random occurrence positions
         */
        function generateCRT(frequency, totalWords) {
            const positions = [];
            for (let i = 0; i < frequency; i++) {
                positions.push(Math.floor(Math.random() * totalWords));
            }
            return positions.sort((a, b) => a - b);
        }

        /**
         * Decompose burstiness into variance and memory components
         * @param {Array} occurrences - Original occurrence positions
         * @param {number} totalWords - Total words
         * @returns {Object} - {μ_total, μ_variance, μ_memory, μ_base}
         */
        function decomposeBurstiness(occurrences, totalWords) {
            // Original burstiness
            const μ_total = calculateTemporalBurstiness(occurrences, totalWords);

            // IRT burstiness (memory removed, variance preserved)
            const irt = generateIRT(occurrences, totalWords);
            const μ_irt = calculateTemporalBurstiness(irt, totalWords);

            // CRT burstiness (both removed)
            const crt = generateCRT(occurrences.length, totalWords);
            const μ_crt = calculateTemporalBurstiness(crt, totalWords);

            // Decomposition
            const μ_memory = μ_total - μ_irt;
            const μ_variance = μ_irt - μ_crt;

            return {
                μ_total,
                μ_variance,
                μ_memory,
                μ_base: μ_crt,
                μ_irt
            };
        }

        /**
         * Calculate word association matrix using exponential decay
         * W_ab = (1/2ξ) Σ_m Σ_n e^(-|t_m - t_n|/ξ)
         *
         * @param {Object} wordPositions - Map of word -> positions
         * @param {number} xi - Characteristic decay length (default: 50 words ~ paragraph)
         * @returns {Object} - Association matrix and word list
         */
        function calculateWordAssociation(wordPositions, xi = 50) {
            const words = Object.keys(wordPositions).filter(w => wordPositions[w].length >= 3);
            const n = words.length;
            const W = Array(n).fill(0).map(() => Array(n).fill(0));

            // Calculate association matrix
            for (let i = 0; i < n; i++) {
                for (let j = i; j < n; j++) {
                    const posA = wordPositions[words[i]];
                    const posB = wordPositions[words[j]];

                    let association = 0;
                    for (const tm of posA) {
                        for (const tn of posB) {
                            association += Math.exp(-Math.abs(tm - tn) / xi);
                        }
                    }

                    W[i][j] = association / (2 * xi);
                    W[j][i] = W[i][j]; // Symmetric
                }
            }

            return { W, words };
        }

        /**
         * Classify words into 4 categories based on frequency and burstiness
         * C1: Fundamental (high freq, medium burst)
         * C2: Topical (medium freq, high burst)
         * C3: Special (low freq, high burst)
         * C4: Common (low freq, low burst)
         *
         * @param {number} frequency - Word frequency
         * @param {number} burstiness - Word burstiness μ
         * @param {Object} stats - Overall statistics {meanFreq, meanBurst}
         * @returns {string} - Category label (C1, C2, C3, or C4)
         */
        function classifyWord(frequency, burstiness, stats) {
            const highFreq = frequency > stats.medianFreq;
            const highBurst = burstiness > stats.medianBurst;

            if (highFreq && highBurst) return 'C1'; // Fundamental
            if (!highFreq && highBurst) return 'C2'; // Topical
            if (highFreq && !highBurst) return 'C3'; // Special
            return 'C4'; // Common
        }

        /**
         * Analyze burstiness for all words in a corpus
         * @param {Array} responses - Array of response objects with text
         * @returns {Object} - Comprehensive burstiness analysis
         */
        function analyzeBurstiness(responses) {
            // Combine all responses into one corpus with position tracking
            let globalPosition = 0;
            const globalWordPositions = {};
            const responseWordCounts = [];

            responses.forEach((response, idx) => {
                const { positions, totalWords } = trackWordPositions(response.text);
                responseWordCounts.push(totalWords);

                // Add to global positions with offset
                Object.entries(positions).forEach(([word, localPositions]) => {
                    if (!globalWordPositions[word]) {
                        globalWordPositions[word] = [];
                    }
                    // Add global offset to local positions
                    localPositions.forEach(pos => {
                        globalWordPositions[word].push(globalPosition + pos);
                    });
                });

                globalPosition += totalWords;
            });

            const totalWords = globalPosition;

            // Calculate burstiness for each word (limit to top words for performance)
            const wordAnalysis = [];
            const wordEntries = Object.entries(globalWordPositions)
                .filter(([word, occurrences]) => occurrences.length >= 3)
                .sort((a, b) => b[1].length - a[1].length) // Sort by frequency
                .slice(0, 100); // Limit to top 100 words for performance

            wordEntries.forEach(([word, occurrences]) => {
                const freq = occurrences.length;
                const decomp = decomposeBurstiness(occurrences, totalWords);
                const intervals = calculateIntervals(occurrences);
                const memory = calculateMemoryEffect(intervals);

                wordAnalysis.push({
                    word,
                    frequency: freq,
                    burstiness: decomp.μ_total,
                    μ_variance: decomp.μ_variance,
                    μ_memory: decomp.μ_memory,
                    memory_M: memory,
                    occurrences,
                    intervals
                });
            });

            // Calculate statistics for classification
            if (wordAnalysis.length === 0) {
                return {
                    words: [],
                    stats: {
                        totalWords,
                        uniqueWords: Object.keys(globalWordPositions).length,
                        analyzedWords: 0,
                        meanBurstiness: 0,
                        medianFreq: 0,
                        medianBurst: 0
                    },
                    wordPositions: globalWordPositions
                };
            }

            const frequencies = wordAnalysis.map(w => w.frequency);
            const bursts = wordAnalysis.map(w => w.burstiness);

            // Sort copies (not originals)
            const sortedFreq = [...frequencies].sort((a, b) => a - b);
            const sortedBurst = [...bursts].sort((a, b) => a - b);

            const medianFreq = sortedFreq[Math.floor(sortedFreq.length / 2)] || 0;
            const medianBurst = sortedBurst[Math.floor(sortedBurst.length / 2)] || 0;

            const stats = {
                totalWords,
                uniqueWords: Object.keys(globalWordPositions).length,
                analyzedWords: wordAnalysis.length,
                meanBurstiness: bursts.reduce((a, b) => a + b, 0) / bursts.length,
                medianFreq,
                medianBurst
            };

            // Classify each word
            wordAnalysis.forEach(w => {
                w.category = classifyWord(w.frequency, w.burstiness, stats);
            });

            // Sort by burstiness
            wordAnalysis.sort((a, b) => b.burstiness - a.burstiness);

            return {
                words: wordAnalysis,
                stats,
                wordPositions: globalWordPositions
            };
        }

        // ========== SIMILARITY PAIRS FUNCTIONS ==========

        let allSimilarityPairs = [];
        let currentRespondentMatches = [];
        let currentRespondent = null;
        let currentMatchIndex = 0;

        // Progress helper functions
        function showProgress(title) {
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressMessage').textContent = 'Initializing...';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressDetails').textContent = '';
            document.getElementById('cancelButton').disabled = false;
            document.getElementById('progressModal').style.display = 'block';
            cancelRequested = false;
        }

        function updateProgress(current, total, message, details = '') {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressMessage').textContent = message;
            document.getElementById('progressDetails').textContent = details;
        }

        function hideProgress() {
            document.getElementById('progressModal').style.display = 'none';
            analysisIsRunning = false;
            cancelRequested = false;
        }

        function cancelAnalysis() {
            cancelRequested = true;
            document.getElementById('progressMessage').textContent = 'Cancelling...';
            document.getElementById('cancelButton').disabled = true;
        }

        // Async sleep to allow UI updates
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ========== WEB WORKERS FOR PARALLEL PROCESSING ==========

        // Create worker from blob URL - keeps everything in a single file
        function createMetricsWorker() {
            const workerCode = `
                // ========== WORKER SCRIPT: All similarity calculation functions ==========

                function tokenize(text) {
                    return text.toLowerCase()
                        .replace(/[\\u2018\\u2019\\u201C\\u201D]/g, "'")
                        .replace(/[^\\w\\s']/g, ' ')
                        .split(/\\s+/)
                        .filter(w => w.length > 0);
                }

                function sentenceLengthVariance(text) {
                    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                    if (sentences.length === 0) return 0;
                    const lengths = sentences.map(s => s.trim().split(/\\s+/).length);
                    const mean = lengths.reduce((a,b) => a+b, 0) / lengths.length;
                    const variance = lengths.reduce((sum, len) => sum + Math.pow(len - mean, 2), 0) / lengths.length;
                    return variance;
                }

                function cosineSimilarity(text1, text2) {
                    const words1 = tokenize(text1);
                    const words2 = tokenize(text2);
                    const freq1 = {};
                    const freq2 = {};
                    const allWords = new Set([...words1, ...words2]);

                    words1.forEach(w => freq1[w] = (freq1[w] || 0) + 1);
                    words2.forEach(w => freq2[w] = (freq2[w] || 0) + 1);

                    let dotProduct = 0, mag1 = 0, mag2 = 0;
                    allWords.forEach(word => {
                        const v1 = freq1[word] || 0;
                        const v2 = freq2[word] || 0;
                        dotProduct += v1 * v2;
                        mag1 += v1 * v1;
                        mag2 += v2 * v2;
                    });

                    return (mag1 === 0 || mag2 === 0) ? 0 : dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));
                }

                function jaccardSimilarity(text1, text2) {
                    const set1 = new Set(tokenize(text1));
                    const set2 = new Set(tokenize(text2));
                    const intersection = new Set([...set1].filter(x => set2.has(x)));
                    const union = new Set([...set1, ...set2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function ngramSimilarity(text1, text2, n = 3) {
                    const getNgrams = (text) => {
                        const ngrams = new Set();
                        const clean = text.toLowerCase().replace(/[^\\w\\s]/g, '');
                        for (let i = 0; i <= clean.length - n; i++) {
                            ngrams.add(clean.substring(i, i + n));
                        }
                        return ngrams;
                    };

                    const ngrams1 = getNgrams(text1);
                    const ngrams2 = getNgrams(text2);
                    const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                    const union = new Set([...ngrams1, ...ngrams2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function ngram4Similarity(text1, text2) {
                    return ngramSimilarity(text1, text2, 4);
                }

                function ngram5Similarity(text1, text2) {
                    return ngramSimilarity(text1, text2, 5);
                }

                function ngramWithPunctuationSimilarity(text1, text2, n = 3) {
                    const getNgrams = (text) => {
                        const ngrams = new Set();
                        const clean = text.toLowerCase();
                        for (let i = 0; i <= clean.length - n; i++) {
                            ngrams.add(clean.substring(i, i + n));
                        }
                        return ngrams;
                    };

                    const ngrams1 = getNgrams(text1);
                    const ngrams2 = getNgrams(text2);
                    const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                    const union = new Set([...ngrams1, ...ngrams2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function wordNgramSimilarity(text1, text2, n = 3) {
                    const getWordNgrams = (text) => {
                        const words = tokenize(text);
                        const ngrams = new Set();
                        for (let i = 0; i <= words.length - n; i++) {
                            ngrams.add(words.slice(i, i + n).join(' ').toLowerCase());
                        }
                        return ngrams;
                    };

                    const ngrams1 = getWordNgrams(text1);
                    const ngrams2 = getWordNgrams(text2);
                    const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                    const union = new Set([...ngrams1, ...ngrams2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function sentenceVarianceSimilarity(text1, text2) {
                    const var1 = sentenceLengthVariance(text1);
                    const var2 = sentenceLengthVariance(text2);
                    if (var1 === 0 && var2 === 0) return 1;
                    return 1 - Math.abs(var1 - var2) / Math.max(var1, var2, 1);
                }

                function wordCountSimilarity(text1, text2) {
                    const count1 = text1.trim().split(/\\s+/).length;
                    const count2 = text2.trim().split(/\\s+/).length;
                    if (count1 === 0 && count2 === 0) return 1;
                    return 1 - Math.abs(count1 - count2) / Math.max(count1, count2);
                }

                function avgSentenceLengthSimilarity(text1, text2) {
                    const sentences1 = text1.split(/[.!?]+/).filter(s => s.trim().length > 0);
                    const sentences2 = text2.split(/[.!?]+/).filter(s => s.trim().length > 0);

                    const avg1 = sentences1.reduce((sum, s) => sum + s.trim().split(/\\s+/).length, 0) / sentences1.length;
                    const avg2 = sentences2.reduce((sum, s) => sum + s.trim().split(/\\s+/).length, 0) / sentences2.length;

                    if (!avg1 || !avg2) return 0;
                    return 1 - Math.abs(avg1 - avg2) / Math.max(avg1, avg2);
                }

                function pronounDensitySimilarity(text1, text2) {
                    const pronouns = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
                                    'you', 'your', 'yours', 'yourself', 'yourselves',
                                    'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
                                    'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
                                    'i\\'m', 'i\\'ve', 'i\\'d', 'i\\'ll', 'you\\'re', 'you\\'ve', 'you\\'d', 'you\\'ll',
                                    'he\\'s', 'he\\'d', 'he\\'ll', 'she\\'s', 'she\\'d', 'she\\'ll', 'it\\'s', 'it\\'d', 'it\\'ll',
                                    'we\\'re', 'we\\'ve', 'we\\'d', 'we\\'ll', 'they\\'re', 'they\\'ve', 'they\\'d', 'they\\'ll'];

                    const words1 = tokenize(text1);
                    const words2 = tokenize(text2);

                    const count1 = words1.filter(w => pronouns.includes(w.toLowerCase())).length;
                    const count2 = words2.filter(w => pronouns.includes(w.toLowerCase())).length;

                    const density1 = words1.length > 0 ? count1 / words1.length : 0;
                    const density2 = words2.length > 0 ? count2 / words2.length : 0;

                    if (density1 === 0 && density2 === 0) return 1;
                    const maxDensity = Math.max(density1, density2);
                    if (maxDensity === 0) return 1;
                    return 1 - Math.abs(density1 - density2) / maxDensity;
                }

                function transitionWordsSimilarity(text1, text2) {
                    const transitions = [
                        // Addition
                        'furthermore', 'moreover', 'additionally', 'also', 'besides', 'in addition', 'as well as',
                        // Example/Clarification
                        'for example', 'for instance', 'specifically', 'to illustrate', 'namely', 'in other words',
                        'that is', 'in particular', 'such as',
                        // Contrast/Opposition
                        'however', 'nevertheless', 'nonetheless', 'conversely', 'on the other hand', 'in contrast',
                        'yet', 'still', 'although', 'even though', 'despite', 'regardless', 'alternatively',
                        // Cause/Effect
                        'therefore', 'thus', 'consequently', 'as a result', 'accordingly', 'hence', 'for this reason',
                        'because of this', 'due to', 'since',
                        // Time/Sequence
                        'meanwhile', 'subsequently', 'finally', 'firstly', 'secondly', 'thirdly', 'then', 'next',
                        'afterward', 'previously', 'eventually', 'ultimately', 'later', 'initially', 'formerly',
                        // Conclusion/Summary
                        'in conclusion', 'to sum up', 'in summary', 'overall', 'all in all', 'in brief',
                        'to conclude', 'in the end',
                        // Emphasis
                        'indeed', 'in fact', 'certainly', 'undoubtedly', 'notably', 'especially', 'particularly',
                        'importantly', 'significantly',
                        // Comparison
                        'similarly', 'likewise', 'in the same way', 'equally', 'by comparison'
                    ];

                    const count1 = transitions.reduce((sum, word) =>
                        sum + (text1.toLowerCase().match(new RegExp('\\\\b' + word + '\\\\b', 'g')) || []).length, 0
                    );
                    const count2 = transitions.reduce((sum, word) =>
                        sum + (text2.toLowerCase().match(new RegExp('\\\\b' + word + '\\\\b', 'g')) || []).length, 0
                    );

                    const words1 = text1.trim().split(/\\s+/).length;
                    const words2 = text2.trim().split(/\\s+/).length;

                    const density1 = (count1 / words1) * 100;
                    const density2 = (count2 / words2) * 100;

                    if (density1 === 0 && density2 === 0) return 1;
                    return 1 - Math.abs(density1 - density2) / Math.max(density1, density2, 1);
                }

                function nerSimilarity(text1, text2) {
                    const extractEntities = (text) => {
                        const wordCount = tokenize(text).length;
                        const properNounPattern = /\\b[A-Z][A-Za-z]*(?:\\s+[A-Z][A-Za-z]*)*\\b/g;
                        const cleanText = text.replace(/([.!?;:,])/g, ' $1 ');
                        const matches = cleanText.match(properNounPattern) || [];
                        const commonWords = new Set(['The', 'This', 'That', 'These', 'Those', 'A', 'An', 'I', 'It', 'He', 'She', 'We', 'They']);

                        // Advanced filtering: Only include words that appear capitalized in mid-sentence positions
                        const sentenceBoundaryPattern = /[.!?]\\s+/g;
                        const sentences = text.split(sentenceBoundaryPattern);
                        const validEntities = new Set();

                        sentences.forEach(sentence => {
                            const sentenceMatches = sentence.match(/\\b[A-Z][A-Za-z]*(?:\\s+[A-Z][A-Za-z]*)*\\b/g) || [];
                            sentenceMatches.slice(1).forEach(match => {
                                if (match.length > 1 && !commonWords.has(match)) {
                                    validEntities.add(match);
                                }
                            });
                        });

                        const entities = matches.filter(m => validEntities.has(m));
                        const uniqueEntities = [...new Set(entities)];
                        const density = wordCount > 0 ? (uniqueEntities.length / wordCount) * 100 : 0;
                        return {
                            entities: new Set(uniqueEntities.map(e => e.toLowerCase())),
                            count: uniqueEntities.length,
                            density: density
                        };
                    };

                    const entities1 = extractEntities(text1);
                    const entities2 = extractEntities(text2);

                    const intersection = new Set([...entities1.entities].filter(x => entities2.entities.has(x)));
                    const union = new Set([...entities1.entities, ...entities2.entities]);
                    const contentSimilarity = union.size === 0 ? 0 : intersection.size / union.size;

                    const densitySimilarity = (() => {
                        if (entities1.density === 0 && entities2.density === 0) return 1;
                        const max = Math.max(entities1.density, entities2.density);
                        return max === 0 ? 0 : 1 - (Math.abs(entities1.density - entities2.density) / max);
                    })();

                    return (contentSimilarity * 0.6) + (densitySimilarity * 0.4);
                }

                // Levenshtein distance functions
                function levenshteinDistance(str1, str2) {
                    const len1 = str1.length;
                    const len2 = str2.length;
                    const matrix = [];

                    for (let i = 0; i <= len1; i++) {
                        matrix[i] = [i];
                    }
                    for (let j = 0; j <= len2; j++) {
                        matrix[0][j] = j;
                    }

                    for (let i = 1; i <= len1; i++) {
                        for (let j = 1; j <= len2; j++) {
                            if (str1[i - 1] === str2[j - 1]) {
                                matrix[i][j] = matrix[i - 1][j - 1];
                            } else {
                                matrix[i][j] = Math.min(
                                    matrix[i - 1][j - 1] + 1,
                                    matrix[i][j - 1] + 1,
                                    matrix[i - 1][j] + 1
                                );
                            }
                        }
                    }

                    return matrix[len1][len2];
                }

                function wordLevelLevenshteinDistance(phrase1, phrase2) {
                    const words1 = phrase1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);
                    const words2 = phrase2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);

                    const len1 = words1.length;
                    const len2 = words2.length;
                    const matrix = [];

                    for (let i = 0; i <= len1; i++) {
                        matrix[i] = [i];
                    }
                    for (let j = 0; j <= len2; j++) {
                        matrix[0][j] = j;
                    }

                    for (let i = 1; i <= len1; i++) {
                        for (let j = 1; j <= len2; j++) {
                            if (words1[i - 1] === words2[j - 1]) {
                                matrix[i][j] = matrix[i - 1][j - 1];
                            } else {
                                matrix[i][j] = Math.min(
                                    matrix[i - 1][j - 1] + 1,
                                    matrix[i][j - 1] + 1,
                                    matrix[i - 1][j] + 1
                                );
                            }
                        }
                    }

                    return matrix[len1][len2];
                }

                function fuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxDistance = 3) {
                    const words1 = text1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);
                    const words2 = text2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);

                    const ngrams1 = [];
                    const ngrams2 = [];

                    for (let i = 0; i <= words1.length - ngramSize; i++) {
                        ngrams1.push(words1.slice(i, i + ngramSize).join(' '));
                    }
                    for (let i = 0; i <= words2.length - ngramSize; i++) {
                        ngrams2.push(words2.slice(i, i + ngramSize).join(' '));
                    }

                    if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

                    const matches = new Set();

                    ngrams1.forEach((ng1, idx1) => {
                        ngrams2.forEach((ng2, idx2) => {
                            const distance = levenshteinDistance(ng1, ng2);
                            if (distance <= maxDistance) {
                                matches.add(\`\${idx1}-\${idx2}\`);
                            }
                        });
                    });

                    const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
                    return matches.size / totalNgrams;
                }

                function wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxWordDistance = 1) {
                    const words1 = text1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);
                    const words2 = text2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);

                    const ngrams1 = [];
                    const ngrams2 = [];

                    for (let i = 0; i <= words1.length - ngramSize; i++) {
                        ngrams1.push(words1.slice(i, i + ngramSize));
                    }
                    for (let i = 0; i <= words2.length - ngramSize; i++) {
                        ngrams2.push(words2.slice(i, i + ngramSize));
                    }

                    if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

                    const matches = new Set();

                    ngrams1.forEach((ng1, idx1) => {
                        ngrams2.forEach((ng2, idx2) => {
                            const distance = wordLevelLevenshteinDistance(ng1.join(' '), ng2.join(' '));
                            if (distance <= maxWordDistance) {
                                matches.add(\`\${idx1}-\${idx2}\`);
                            }
                        });
                    });

                    const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
                    return matches.size / totalNgrams;
                }

                // Temporal Burstiness functions
                function calculateTemporalBurstiness(occurrences, totalWords) {
                    if (occurrences.length === 0 || totalWords === 0) return 0;

                    const f = occurrences.length;
                    const T = totalWords;
                    const sortedOccurrences = [...occurrences].sort((a, b) => a - b);

                    let maxArea = 0;
                    const steps = Math.min(200, T);
                    const dt = T / steps;

                    for (let k = 0; k < Math.min(f, 20); k++) {
                        const tk = sortedOccurrences[k];
                        let area = 0;
                        let occIdx = 0;

                        for (let i = 0; i < steps; i++) {
                            const t = i * dt;
                            while (occIdx < f && sortedOccurrences[occIdx] <= t) {
                                occIdx++;
                            }
                            const Ct = occIdx;
                            // Note: Cui et al. (2017) paper uses (k-1) with 1-based indexing;
                            // we use k with 0-based indexing (mathematically equivalent, verified)
                            const linearValue = (f / T) * (t - tk) + k;
                            const diff = Math.abs(Ct - linearValue);
                            area += diff * dt;
                        }

                        if (area > maxArea) {
                            maxArea = area;
                        }
                    }

                    const normalized = (2 * maxArea) / (f * T);
                    return Math.min(1, normalized);
                }

                function temporalBurstinessSimilarity(text1, text2) {
                    const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i',
                                               'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
                                               'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she',
                                               'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their']);

                    const getWordPositions = (text) => {
                        const words = text.toLowerCase().match(/\\b[a-z]+\\b/g) || [];
                        const positions = {};
                        words.forEach((word, idx) => {
                            if (!stopWords.has(word) && word.length > 3) {
                                if (!positions[word]) positions[word] = [];
                                positions[word].push(idx);
                            }
                        });
                        return { positions, totalWords: words.length };
                    };

                    const data1 = getWordPositions(text1);
                    const data2 = getWordPositions(text2);

                    const commonWords = Object.keys(data1.positions).filter(word =>
                        data2.positions[word] &&
                        data1.positions[word].length >= 2 &&
                        data2.positions[word].length >= 2
                    );

                    if (commonWords.length === 0) return 0;

                    const burstinessScores = commonWords.map(word => {
                        const burst1 = calculateTemporalBurstiness(data1.positions[word], data1.totalWords);
                        const burst2 = calculateTemporalBurstiness(data2.positions[word], data2.totalWords);
                        return 1 - Math.abs(burst1 - burst2);
                    });

                    return burstinessScores.reduce((a, b) => a + b, 0) / burstinessScores.length;
                }

                // Calculate all metrics for given text pairs
                function calculateMetricsForPairs(pairs, selectedMetrics) {
                    return pairs.map(pair => {
                        const metrics = {};

                        selectedMetrics.forEach(metricId => {
                            switch(metricId) {
                                case 'cosine':
                                    metrics.cosine = cosineSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'jaccard':
                                    metrics.jaccard = jaccardSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'ngram':
                                    metrics.ngram = ngramSimilarity(pair.text1, pair.text2, 3);
                                    break;
                                case 'sentenceVariance':
                                    metrics.sentenceVariance = sentenceVarianceSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'wordCount':
                                    metrics.wordCount = wordCountSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'avgSentenceLength':
                                    metrics.avgSentenceLength = avgSentenceLengthSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'temporalBurstiness':
                                    metrics.temporalBurstiness = temporalBurstinessSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'pronounDensity':
                                    metrics.pronounDensity = pronounDensitySimilarity(pair.text1, pair.text2);
                                    break;
                                case 'transitionWords':
                                    metrics.transitionWords = transitionWordsSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'ngramPunctuation':
                                    metrics.ngramPunctuation = ngramWithPunctuationSimilarity(pair.text1, pair.text2, 3);
                                    break;
                                case 'wordNgram':
                                    metrics.wordNgram = wordNgramSimilarity(pair.text1, pair.text2, 3);
                                    break;
                                case 'ngram4':
                                    metrics.ngram4 = ngram4Similarity(pair.text1, pair.text2);
                                    break;
                                case 'ngram5':
                                    metrics.ngram5 = ngram5Similarity(pair.text1, pair.text2);
                                    break;
                                case 'ner':
                                    metrics.ner = nerSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'fuzzyNgram3':
                                    metrics.fuzzyNgram3 = fuzzyNgramSimilarity(pair.text1, pair.text2, 3, 5);
                                    break;
                                case 'fuzzyNgram6':
                                    metrics.fuzzyNgram6 = fuzzyNgramSimilarity(pair.text1, pair.text2, 6, 13);
                                    break;
                                case 'wordLevelFuzzy3':
                                    metrics.wordLevelFuzzy3 = wordLevelFuzzyNgramSimilarity(pair.text1, pair.text2, 3, 1);
                                    break;
                                case 'wordLevelFuzzy5':
                                    metrics.wordLevelFuzzy5 = wordLevelFuzzyNgramSimilarity(pair.text1, pair.text2, 5, 2);
                                    break;
                            }
                        });

                        return {
                            id1: pair.id1,
                            id2: pair.id2,
                            text1: pair.text1,
                            text2: pair.text2,
                            metrics: metrics
                        };
                    });
                }

                // Worker message handler
                self.onmessage = function(e) {
                    const { pairs, selectedMetrics, workerId } = e.data;
                    const results = calculateMetricsForPairs(pairs, selectedMetrics);
                    self.postMessage({ workerId, results });
                };
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // ========== PARALLELIZED CALCULATION FUNCTION ==========

        async function calculateSimilarityPairs(responses) {
            if (analysisIsRunning) {
                alert('Analysis is already running. Please wait or cancel the current analysis.');
                return;
            }

            analysisIsRunning = true;
            allSimilarityPairs = [];
            const n = responses.length;
            const totalPairs = (n * (n - 1)) / 2;
            const selectedMetrics = getSelectedMetrics();

            showProgress('Analyzing Corpus');

            const startTime = Date.now();
            const pairMetrics = []; // Store all individual metrics for normalization

            // PHASE 1: Calculate all individual metrics using Web Workers (parallel)
            updateProgress(0, totalPairs, 'Phase 1: Calculating individual metrics (parallel)...', 'Initializing workers...');
            await sleep(10);

            // Determine number of workers (use logical CPU cores, max 8)
            const numWorkers = Math.min(navigator.hardwareConcurrency || 4, 8);
            updateProgress(0, totalPairs, 'Phase 1: Calculating individual metrics (parallel)...', `Using ${numWorkers} parallel workers...`);
            await sleep(10);

            // Build all pairs
            const allPairs = [];
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    allPairs.push({
                        id1: responses[i].id,
                        id2: responses[j].id,
                        text1: responses[i].text,
                        text2: responses[j].text
                    });
                }
            }

            // Split pairs into batches for each worker
            const batchSize = Math.ceil(allPairs.length / numWorkers);
            const batches = [];
            for (let i = 0; i < numWorkers; i++) {
                const start = i * batchSize;
                const end = Math.min(start + batchSize, allPairs.length);
                if (start < allPairs.length) {
                    batches.push(allPairs.slice(start, end));
                }
            }

            // Create workers and track progress
            const workers = [];
            const workerPromises = [];
            let completedPairs = 0;

            for (let i = 0; i < batches.length; i++) {
                const worker = createMetricsWorker();
                workers.push(worker);

                const promise = new Promise((resolve, reject) => {
                    worker.onmessage = (e) => {
                        const { workerId, results } = e.data;
                        completedPairs += results.length;

                        // Update progress
                        const elapsed = (Date.now() - startTime) / 1000;
                        const rate = completedPairs / elapsed;
                        const remaining = (totalPairs - completedPairs) / rate;
                        const eta = remaining > 60 ? `${Math.round(remaining / 60)}m ${Math.round(remaining % 60)}s` : `${Math.round(remaining)}s`;

                        updateProgress(
                            completedPairs,
                            totalPairs,
                            `Phase 1: Processing with ${numWorkers} workers (${completedPairs}/${totalPairs} pairs)`,
                            `Elapsed: ${Math.round(elapsed)}s | Est. remaining: ${eta} | Rate: ${Math.round(rate)} pairs/sec`
                        );

                        resolve(results);
                    };

                    worker.onerror = (error) => {
                        console.error('Worker error:', error);
                        reject(error);
                    };

                    // Check for cancellation before starting
                    if (cancelRequested) {
                        worker.terminate();
                        reject(new Error('Cancelled'));
                        return;
                    }

                    // Send work to this worker
                    worker.postMessage({
                        pairs: batches[i],
                        selectedMetrics: selectedMetrics,
                        workerId: i
                    });
                });

                workerPromises.push(promise);
            }

            // Wait for all workers to complete
            try {
                const allResults = await Promise.all(workerPromises);

                // Check for cancellation
                if (cancelRequested) {
                    workers.forEach(w => w.terminate());
                    hideProgress();
                    analysisIsRunning = false;
                    cancelRequested = false;
                    alert('Analysis cancelled by user.');
                    return;
                }

                // Merge results from all workers
                allResults.forEach(results => {
                    pairMetrics.push(...results);
                });

                // Clean up workers
                workers.forEach(w => w.terminate());

            } catch (error) {
                console.error('Worker execution failed:', error);
                workers.forEach(w => w.terminate());

                if (cancelRequested) {
                    hideProgress();
                    analysisIsRunning = false;
                    cancelRequested = false;
                    alert('Analysis cancelled by user.');
                    return;
                }

                // Fall back to non-parallel processing
                alert('Parallel processing failed. Falling back to single-threaded mode.');
                hideProgress();
                analysisIsRunning = false;
                cancelRequested = false;
                return;
            }

            // PHASE 2: Calculate normalization parameters (min/max for each metric)
            updateProgress(totalPairs, totalPairs, 'Phase 2: Calculating normalization parameters...', 'Please wait...');
            await sleep(0);

            metricNormalizationParams = {};
            selectedMetrics.forEach(metricId => {
                const values = pairMetrics.map(pair => pair.metrics[metricId]).filter(v => v !== undefined);
                if (values.length > 0) {
                    metricNormalizationParams[metricId] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                }
            });

            // PHASE 3: Calculate combined normalized similarities
            updateProgress(totalPairs, totalPairs, 'Phase 3: Combining normalized metrics...', 'Please wait...');
            await sleep(0);

            const weights = getMetricWeights();
            pairMetrics.forEach(pair => {
                let weightedSum = 0;
                let totalWeight = 0;

                selectedMetrics.forEach(metric => {
                    if (pair.metrics[metric] !== undefined) {
                        const weight = weights[metric] || 1.0;
                        const normalizedScore = normalizeMetric(pair.metrics[metric], metric);
                        weightedSum += normalizedScore * weight;
                        totalWeight += weight;
                    }
                });

                const combinedSimilarity = totalWeight > 0 ? weightedSum / totalWeight : 0;

                allSimilarityPairs.push({
                    id1: pair.id1,
                    id2: pair.id2,
                    text1: pair.text1,
                    text2: pair.text2,
                    similarity: combinedSimilarity
                });
            });

            // Sort by similarity (highest first)
            updateProgress(totalPairs, totalPairs, 'Sorting results...', 'Please wait...');
            await sleep(0);
            allSimilarityPairs.sort((a, b) => b.similarity - a.similarity);

            hideProgress();
            analysisIsRunning = false;
            cancelRequested = false;
        }

        function updateThreshold(value) {
            document.getElementById('thresholdDisplay').textContent = value;

            const threshold = parseFloat(value);
            const filteredPairs = allSimilarityPairs.filter(p => p.similarity >= threshold);

            // Update pair count display
            document.getElementById('pairCountDisplay').textContent =
                `${filteredPairs.length} pairs above threshold`;

            renderSimilarityPairs(filteredPairs);
            renderFlaggedRespondents(filteredPairs);
            saveSession();
        }

        function renderSimilarityPairs(pairs) {
            const container = document.getElementById('similarityPairsList');

            if (pairs.length === 0) {
                container.innerHTML = `
                    <p style="color: #999; text-align: center; padding: 40px;">
                        No pairs found above the current threshold. Try lowering the threshold.
                    </p>
                `;
                return;
            }

            container.innerHTML = pairs.map(pair => {
                const scoreClass = pair.similarity >= 0.85 ? 'similarity-high' :
                                   pair.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';

                const preview = pair.text1.substring(0, 200) + (pair.text1.length > 200 ? '...' : '');

                return `
                    <div class="similarity-pair-item" onclick='showPairComparison(${JSON.stringify(pair).replace(/'/g, "\\'")} )'>
                        <div class="pair-header-row">
                            <span class="pair-ids">Respondent ${pair.id1} ↔ Respondent ${pair.id2}</span>
                            <span class="similarity-badge ${scoreClass}">${(pair.similarity * 100).toFixed(1)}%</span>
                        </div>
                        <div class="response-preview">${escapeHtml(preview)}</div>
                    </div>
                `;
            }).join('');
        }

        function renderFlaggedRespondents(pairs) {
            const panel = document.getElementById('frequentRespondentsPanel');
            const container = document.getElementById('frequentRespondentsList');

            if (pairs.length === 0) {
                panel.style.display = 'none';
                return;
            }

            // Count how many times each respondent appears
            const counts = {};
            const matches = {};

            pairs.forEach(pair => {
                // Count for id1
                if (!counts[pair.id1]) {
                    counts[pair.id1] = 0;
                    matches[pair.id1] = [];
                }
                counts[pair.id1]++;
                matches[pair.id1].push({ id: pair.id2, similarity: pair.similarity });

                // Count for id2
                if (!counts[pair.id2]) {
                    counts[pair.id2] = 0;
                    matches[pair.id2] = [];
                }
                counts[pair.id2]++;
                matches[pair.id2].push({ id: pair.id1, similarity: pair.similarity });
            });

            // Filter to respondents in 2+ pairs
            const flagged = Object.entries(counts)
                .filter(([id, count]) => count >= 2)
                .map(([id, count]) => ({ id, count, matches: matches[id] }))
                .sort((a, b) => b.count - a.count);

            if (flagged.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';

            container.innerHTML = flagged.map(respondent => {
                // Sort matches by similarity
                respondent.matches.sort((a, b) => b.similarity - a.similarity);

                // Escape single quotes in ID for onclick handler
                const escapedId = String(respondent.id).replace(/'/g, "\\'");

                return `
                    <div class="flagged-respondent-item" onclick="showFlaggedRespondentMatches('${escapedId}')">
                        <div class="flagged-header">
                            <strong style="color: #2c3e50; font-size: 15px;">Respondent ${respondent.id}</strong>
                            <span class="flag-count-badge">${respondent.count} matches</span>
                        </div>
                        <div class="match-chips">
                            ${respondent.matches.map(m => {
                                const scoreClass = m.similarity >= 0.85 ? 'similarity-high' :
                                                   m.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';
                                return `<span class="match-chip ${scoreClass}">
                                    #${m.id} (${(m.similarity * 100).toFixed(0)}%)
                                </span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');

            // Also render least flagged respondents
            renderLeastFlaggedRespondents();
        }

        function renderLeastFlaggedRespondents() {
            const container = document.getElementById('infrequentRespondentsList');

            if (!allSimilarityPairs || allSimilarityPairs.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center;">No data available</p>';
                return;
            }

            // Calculate average similarity for each respondent
            const respondentScores = {};
            const respondentPairs = {};

            allSimilarityPairs.forEach(pair => {
                // Track for id1
                if (!respondentScores[pair.id1]) {
                    respondentScores[pair.id1] = [];
                    respondentPairs[pair.id1] = [];
                }
                respondentScores[pair.id1].push(pair.similarity);
                respondentPairs[pair.id1].push({ id: pair.id2, similarity: pair.similarity });

                // Track for id2
                if (!respondentScores[pair.id2]) {
                    respondentScores[pair.id2] = [];
                    respondentPairs[pair.id2] = [];
                }
                respondentScores[pair.id2].push(pair.similarity);
                respondentPairs[pair.id2].push({ id: pair.id1, similarity: pair.similarity });
            });

            // Calculate average and sort by lowest
            const leastFlagged = Object.entries(respondentScores)
                .map(([id, scores]) => ({
                    id,
                    avgSimilarity: scores.reduce((a, b) => a + b, 0) / scores.length,
                    count: scores.length,
                    pairs: respondentPairs[id]
                }))
                .sort((a, b) => a.avgSimilarity - b.avgSimilarity)
                .slice(0, 10); // Show top 10 least similar

            container.innerHTML = leastFlagged.map(respondent => {
                // Sort pairs by similarity (lowest first for this view)
                respondent.pairs.sort((a, b) => a.similarity - b.similarity);

                const escapedId = String(respondent.id).replace(/'/g, "\\'");
                const avgPercent = (respondent.avgSimilarity * 100).toFixed(1);

                return `
                    <div class="flagged-respondent-item" onclick="showFlaggedRespondentMatches('${escapedId}', true)">
                        <div class="flagged-header">
                            <strong style="color: #2c3e50; font-size: 15px;">Respondent ${respondent.id}</strong>
                            <span class="flag-count-badge" style="background: #27ae60;">Avg: ${avgPercent}%</span>
                        </div>
                        <div class="match-chips">
                            ${respondent.pairs.slice(0, 5).map(m => {
                                const scoreClass = m.similarity >= 0.85 ? 'similarity-high' :
                                                   m.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';
                                return `<span class="match-chip ${scoreClass}">
                                    #${m.id} (${(m.similarity * 100).toFixed(0)}%)
                                </span>`;
                            }).join('')}
                            ${respondent.pairs.length > 5 ? `<span style="color: #999; font-size: 12px;">+${respondent.pairs.length - 5} more</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function switchFlaggedTab(tab) {
            const mostTab = document.getElementById('mostFlaggedTab');
            const leastTab = document.getElementById('leastFlaggedTab');
            const mostContent = document.getElementById('mostFlaggedContent');
            const leastContent = document.getElementById('leastFlaggedContent');

            if (tab === 'most') {
                mostTab.style.borderBottom = '3px solid #57068C';
                mostTab.style.color = '#57068C';
                leastTab.style.borderBottom = '3px solid transparent';
                leastTab.style.color = '#666';
                mostContent.style.display = 'block';
                leastContent.style.display = 'none';
            } else {
                leastTab.style.borderBottom = '3px solid #57068C';
                leastTab.style.color = '#57068C';
                mostTab.style.borderBottom = '3px solid transparent';
                mostTab.style.color = '#666';
                leastContent.style.display = 'block';
                mostContent.style.display = 'none';
            }
        }

        function showFlaggedRespondentMatches(respondentId, ignoreThreshold = false) {
            console.log('showFlaggedRespondentMatches called with ID:', respondentId);

            // Show loading spinner
            const spinner = document.getElementById('loadingSpinner');
            spinner.style.display = 'flex';

            // Use setTimeout to let the spinner render before processing
            setTimeout(() => {
                try {
                    // Find the respondent's full data
                    const responses = analysisResults.responses;
                    console.log('Available responses:', responses.map(r => r.id));

                    currentRespondent = responses.find(r => r.id === respondentId);
                    console.log('Found respondent:', currentRespondent);

                    if (!currentRespondent) {
                        console.error('Respondent not found with ID:', respondentId);
                        spinner.style.display = 'none';
                        return;
                    }

                    // Find all pairs involving this respondent
                    const threshold = parseFloat(document.getElementById('similarityThreshold').value);
                    currentRespondentMatches = allSimilarityPairs
                        .filter(p => {
                            const involvesRespondent = (p.id1 === respondentId || p.id2 === respondentId);
                            // For least flagged, show all pairs; for most flagged, respect threshold
                            return involvesRespondent && (ignoreThreshold || p.similarity >= threshold);
                        })
                        .map(p => {
                            // Normalize so currentRespondent is always the first one
                            if (p.id1 === respondentId) {
                                return { id: p.id2, text: p.text2, similarity: p.similarity };
                            } else {
                                return { id: p.id1, text: p.text1, similarity: p.similarity };
                            }
                        })
                        .sort((a, b) => {
                            // Least flagged: sort lowest to highest (to match list order)
                            // Most flagged: sort highest to lowest
                            return ignoreThreshold ? a.similarity - b.similarity : b.similarity - a.similarity;
                        });

                    if (currentRespondentMatches.length === 0) {
                        spinner.style.display = 'none';
                        return;
                    }

                    currentMatchIndex = 0;
                    renderCurrentMatch();

                    // Hide spinner after rendering
                    spinner.style.display = 'none';
                } catch (error) {
                    console.error('Error in showFlaggedRespondentMatches:', error);
                    spinner.style.display = 'none';
                }
            }, 10); // Small delay to ensure spinner shows
        }

        function renderCurrentMatch() {
            if (!currentRespondent || currentRespondentMatches.length === 0) return;

            const modal = document.getElementById('comparisonModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');

            const match = currentRespondentMatches[currentMatchIndex];
            const sharedPhrases = getCommonNgrams(currentRespondent.text, match.text);

            const scoreClass = match.similarity >= 0.85 ? 'similarity-high' :
                               match.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';

            // Highlight shared phrases
            const highlighted1 = highlightSharedPhrases(currentRespondent.text, sharedPhrases);
            const highlighted2 = highlightSharedPhrases(match.text, sharedPhrases);

            title.textContent = `Respondent ${currentRespondent.id} vs ${match.id} (${currentMatchIndex + 1} of ${currentRespondentMatches.length})`;

            body.innerHTML = `
                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px;">
                    ${generateMetricBadges(currentRespondent.text, match.text, match.similarity, currentRespondent.id, match.id)}
                </div>

                <div class="comparison-grid">
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${currentRespondent.id}</div>
                        <div class="comparison-text">${highlighted1}</div>
                    </div>
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${match.id}</div>
                        <div class="comparison-text">${highlighted2}</div>
                    </div>
                </div>

                ${sharedPhrases.length > 0 ? `
                    <div class="shared-phrases-box">
                        <h4>Shared Phrases (${sharedPhrases.length})
                            <span style="font-size: 11px; color: #666; font-weight: normal;">
                                - Yellow = exact, Orange = fuzzy (paraphrase)
                            </span>
                        </h4>
                        ${sharedPhrases.slice(0, 15).map(p =>
                            `<span class="phrase-chip" style="background: ${p.type === 'exact' ? '#ffeb3b' : '#ffe0b2'}; border: 1px solid ${p.type === 'exact' ? '#ffc107' : '#ff9800'};">
                                "${escapeHtml(p.text)}" (${p.length} words${p.type === 'fuzzy' ? ', ~' : ''})
                            </span>`
                        ).join('')}
                        ${sharedPhrases.length > 15 ? `<span class="phrase-chip">+${sharedPhrases.length - 15} more</span>` : ''}
                    </div>
                ` : ''}

                <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                    <button onclick="prevMatch()" ${currentMatchIndex === 0 ? 'disabled' : ''}
                        style="padding: 10px 30px; background: ${currentMatchIndex === 0 ? '#ccc' : '#57068C'}; color: white; border: none; border-radius: 5px; cursor: ${currentMatchIndex === 0 ? 'not-allowed' : 'pointer'}; font-weight: 600; font-size: 14px;">
                        ← Previous
                    </button>
                    <button onclick="nextMatch()" ${currentMatchIndex === currentRespondentMatches.length - 1 ? 'disabled' : ''}
                        style="padding: 10px 30px; background: ${currentMatchIndex === currentRespondentMatches.length - 1 ? '#ccc' : '#57068C'}; color: white; border: none; border-radius: 5px; cursor: ${currentMatchIndex === currentRespondentMatches.length - 1 ? 'not-allowed' : 'pointer'}; font-weight: 600; font-size: 14px;">
                        Next →
                    </button>
                </div>
            `;

            modal.style.display = 'block';
        }

        function prevMatch() {
            if (currentMatchIndex > 0) {
                currentMatchIndex--;
                renderCurrentMatch();
            }
        }

        function nextMatch() {
            if (currentMatchIndex < currentRespondentMatches.length - 1) {
                currentMatchIndex++;
                renderCurrentMatch();
            }
        }

        function showPairComparison(pair) {
            const modal = document.getElementById('comparisonModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');

            // Clear any stored comparison pair (we're viewing a fresh comparison)
            window.currentComparisonPair = null;

            title.textContent = `Respondent ${pair.id1} vs Respondent ${pair.id2}`;

            // Find shared phrases
            const sharedPhrases = getCommonNgrams(pair.text1, pair.text2);

            // Highlight shared phrases in both texts
            const highlighted1 = highlightSharedPhrases(pair.text1, sharedPhrases);
            const highlighted2 = highlightSharedPhrases(pair.text2, sharedPhrases);

            body.innerHTML = `
                <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                    ${generateMetricBadges(pair.text1, pair.text2, pair.similarity, pair.id1, pair.id2)}
                </div>

                <div class="comparison-grid">
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${pair.id1}</div>
                        <div class="comparison-text">${highlighted1}</div>
                    </div>
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${pair.id2}</div>
                        <div class="comparison-text">${highlighted2}</div>
                    </div>
                </div>

                ${sharedPhrases.length > 0 ? `
                    <div class="shared-phrases-box">
                        <h4>Shared Phrases (${sharedPhrases.length})
                            <span style="font-size: 11px; color: #666; font-weight: normal;">
                                - Yellow = exact, Orange = fuzzy (paraphrase)
                            </span>
                        </h4>
                        ${sharedPhrases.slice(0, 15).map(p =>
                            `<span class="phrase-chip" style="background: ${p.type === 'exact' ? '#ffeb3b' : '#ffe0b2'}; border: 1px solid ${p.type === 'exact' ? '#ffc107' : '#ff9800'};">
                                "${escapeHtml(p.text)}" (${p.length} words${p.type === 'fuzzy' ? ', ~' : ''})
                            </span>`
                        ).join('')}
                        ${sharedPhrases.length > 15 ? `<span class="phrase-chip">+${sharedPhrases.length - 15} more</span>` : ''}
                    </div>
                ` : ''}
            `;

            modal.style.display = 'block';
        }

        function getCommonNgrams(text1, text2) {
            // Split and strip punctuation from each word
            const words1 = text1.toLowerCase().split(/\s+/)
                .map(w => w.replace(/[^\w]/g, ''))
                .filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/)
                .map(w => w.replace(/[^\w]/g, ''))
                .filter(w => w.length > 0);

            const matches = [];

            // Find exact matching n-grams from 2 to 10 words
            for (let n = 2; n <= Math.min(10, words1.length, words2.length); n++) {
                const ngrams1 = new Set();
                for (let i = 0; i <= words1.length - n; i++) {
                    ngrams1.add(words1.slice(i, i + n).join(' '));
                }

                for (let i = 0; i <= words2.length - n; i++) {
                    const ngram = words2.slice(i, i + n).join(' ');
                    if (ngrams1.has(ngram)) {
                        matches.push({ text: ngram, length: n, type: 'exact' });
                    }
                }
            }

            // Find fuzzy matches using word-level Levenshtein distance
            // 3-word phrases with ≤1 word difference
            for (let i = 0; i <= words1.length - 3; i++) {
                const ngram1 = words1.slice(i, i + 3);
                for (let j = 0; j <= words2.length - 3; j++) {
                    const ngram2 = words2.slice(j, j + 3);
                    const distance = wordLevelLevenshteinDistance(ngram1.join(' '), ngram2.join(' '));
                    if (distance === 1) {  // Exactly 1 word different (fuzzy match)
                        const text = ngram2.join(' ');
                        matches.push({ text: text, length: 3, type: 'fuzzy' });
                    }
                }
            }

            // 5-word phrases with ≤2 word differences
            for (let i = 0; i <= words1.length - 5; i++) {
                const ngram1 = words1.slice(i, i + 5);
                for (let j = 0; j <= words2.length - 5; j++) {
                    const ngram2 = words2.slice(j, j + 5);
                    const distance = wordLevelLevenshteinDistance(ngram1.join(' '), ngram2.join(' '));
                    if (distance >= 1 && distance <= 2) {  // 1-2 words different (fuzzy match)
                        const text = ngram2.join(' ');
                        matches.push({ text: text, length: 5, type: 'fuzzy' });
                    }
                }
            }

            // Remove duplicates and substrings (keep longer/exact matches first)
            matches.sort((a, b) => {
                // Prioritize exact matches over fuzzy
                if (a.type === 'exact' && b.type !== 'exact') return -1;
                if (a.type !== 'exact' && b.type === 'exact') return 1;
                // Then sort by length
                return b.length - a.length;
            });

            const filtered = [];
            const seen = new Set();

            matches.forEach(match => {
                let isSubstring = false;
                for (const existing of filtered) {
                    if (existing.text.includes(match.text)) {
                        isSubstring = true;
                        break;
                    }
                }
                if (!isSubstring && !seen.has(match.text)) {
                    seen.add(match.text);
                    filtered.push(match);
                }
            });

            return filtered;
        }

        function highlightSharedPhrases(text, phrases) {
            if (!phrases || phrases.length === 0) return escapeHtml(text);

            let highlighted = text;

            // Sort by length (longest first) to avoid partial matches, prioritize exact over fuzzy
            const sorted = [...phrases].sort((a, b) => {
                if (a.type === 'exact' && b.type !== 'exact') return -1;
                if (a.type !== 'exact' && b.type === 'exact') return 1;
                return b.text.length - a.text.length;
            });

            sorted.forEach(phrase => {
                const highlightClass = phrase.type === 'exact' ? 'highlight-exact' : 'highlight-fuzzy';
                const regex = new RegExp(phrase.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                highlighted = highlighted.replace(regex, match => `<mark class="${highlightClass}">${match}</mark>`);
            });

            return highlighted;
        }

        function closeModal() {
            document.getElementById('comparisonModal').style.display = 'none';
        }

        function closeCalculationModal() {
            document.getElementById('calculationModal').style.display = 'none';
        }

        function closeModalAndReturnToComparison() {
            // If we have a stored comparison pair, return to it
            if (window.currentComparisonPair) {
                const pair = window.currentComparisonPair;
                // Find the full pair object from similarityPairs
                const fullPair = similarityPairs.find(p =>
                    (p.id1 === pair.id1 && p.id2 === pair.id2) ||
                    (p.id1 === pair.id2 && p.id2 === pair.id1)
                );

                if (fullPair) {
                    showPairComparison(fullPair);
                } else {
                    // Fallback: just close the modal
                    closeModal();
                }

                // Clear the stored pair
                window.currentComparisonPair = null;
            } else {
                // No stored pair, just close
                closeModal();
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('comparisonModal');
            if (modal.style.display !== 'block') return;

            if (e.key === 'Escape') {
                closeModal();
            } else if (e.key === 'ArrowLeft') {
                prevMatch();
            } else if (e.key === 'ArrowRight') {
                nextMatch();
            }
        });

        // ========== TAB SWITCHING ==========

        function switchTab(tabName) {
            // Only 'pairs' tab exists now
            if (tabName === 'pairs') {
                document.getElementById('pairs-tab').classList.add('active');
                document.querySelector('.tab-button').classList.add('active');
            }
        }
    </script>
</body>
</html>
