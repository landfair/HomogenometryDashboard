<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Homogenometry Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Montserrat', sans-serif;
            background: #f8f9fa;
            color: #2d2d2d;
            padding: 0;
            line-height: 1.7;
        }
        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background-color: white;
            border-bottom: 3px solid #57068c;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            padding: 0 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }
        .logo img {
            height: 60px;
            width: auto;
        }
        .header-title {
            color: #57068c;
            font-weight: 600;
            font-size: 1.4rem;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            letter-spacing: 0.5px;
        }
        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-left: auto;
            position: relative;
            z-index: 9999;
        }
        .header-menu {
            position: relative;
        }
        .menu-trigger {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            font-size: 1.5rem;
            color: #57068c;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }
        .menu-trigger:hover {
            background-color: #f0e6ff;
        }
        .header-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 200px;
            display: none;
            z-index: 10000;
            margin-top: 8px;
        }
        .header-dropdown.show {
            display: block;
        }
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            color: #2d2d2d;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-family: 'Montserrat', sans-serif;
        }
        .dropdown-item:first-child {
            border-radius: 8px 8px 0 0;
        }
        .dropdown-item:last-child {
            border-radius: 0 0 8px 8px;
        }
        .dropdown-item:hover {
            background-color: #f0e6ff;
            color: #57068c;
        }
        .dropdown-item i {
            width: 16px;
            color: #57068c;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 90px 20px 20px;
        }
        h1 {
            text-align: center;
            color: #57068c;
            margin-bottom: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .file-input {
            display: none;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            display: none;
        }
        .dashboard {
            display: none;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .metric-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        .panel-header {
            background: #57068c;
            color: white;
            padding: 15px 20px;
            font-weight: 600;
            font-size: 16px;
            letter-spacing: 0.3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-info {
            font-size: 12px;
            opacity: 0.9;
            font-weight: normal;
        }
        .panel-content {
            padding: 20px;
        }
        .metric-item {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .metric-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .metric-name {
            font-weight: 600;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 8px;
        }
        .metric-formula {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #7f8c8d;
            background: #f8f9fa;
            padding: 6px 10px;
            border-radius: 4px;
            margin-bottom: 8px;
            border-left: 3px solid #57068c;
        }
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #57068c;
            margin-bottom: 8px;
        }
        .metric-interpretation {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
        }
        .metric-bar {
            height: 12px;
            background: #ecf0f1;
            border-radius: 6px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        .metric-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #27ae60);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        .metric-bar-marker {
            position: absolute;
            top: -5px;
            width: 2px;
            height: 22px;
            background: #57068c;
        }
        .metric-bar-label {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
        }
        .stat-badge {
            display: inline-block;
            padding: 4px 10px;
            background: #ecf0f1;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 8px;
            margin-top: 5px;
        }
        .stat-badge.warning {
            background: #fff3cd;
            color: #856404;
        }
        .stat-badge.danger {
            background: #f8d7da;
            color: #721c24;
        }
        .stat-badge.success {
            background: #d4edda;
            color: #155724;
        }
        .phrase-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .phrase-item {
            padding: 12px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .phrase-item:hover {
            background: #f8f9fa;
        }
        .phrase-text {
            font-style: italic;
            color: #2c3e50;
            flex: 1;
        }
        .phrase-stats {
            display: flex;
            gap: 10px;
            font-size: 12px;
        }
        .phrase-count {
            background: #57068C;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .phrase-significance {
            background: #e74c3c;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }
        .distribution-viz {
            margin-top: 15px;
        }
        .histogram {
            display: flex;
            align-items: flex-end;
            height: 150px;
            gap: 3px;
            margin: 20px 0;
        }
        .histogram-bar {
            flex: 1;
            background: #57068C;
            border-radius: 3px 3px 0 0;
            min-width: 8px;
            position: relative;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .histogram-bar:hover {
            opacity: 0.7;
        }
        .histogram-bar.highlight {
            background: #e74c3c;
        }
        .histogram-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        .methodology {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #57068C;
        }
        .methodology h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .methodology p {
            font-size: 13px;
            line-height: 1.6;
            color: #555;
        }
        .methodology code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        .export-btn {
            background: #27ae60;
            color: white;
            padding: 10px 20px;
            border: 2px solid #27ae60;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            letter-spacing: 0.3px;
            margin-top: 10px;
            transition: all 0.2s ease;
        }
        .export-btn:hover {
            background: #229954;
            border-color: #229954;
        }
        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .pattern-chip {
            display: inline-block;
            padding: 6px 12px;
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 16px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 5px;
        }
        .pattern-chip:hover {
            background: #57068c;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(87,6,140,0.15);
        }
        .pattern-chip .count {
            background: rgba(0,0,0,0.1);
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 6px;
            font-size: 11px;
            font-weight: 600;
        }
        .correlation-result {
            margin-top: 20px;
            padding: 20px;
            background: #fff;
            border: 2px solid #57068c;
            border-radius: 8px;
        }
        .correlation-header {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        .correlation-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .corr-stat {
            background: #ecf0f1;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
        }
        .corr-stat strong {
            color: #e74c3c;
        }
        .respondent-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
        }
        .respondent-chip {
            background: #e74c3c;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .correlation-section {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .correlation-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }
        .word-correlation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .word-correlation-item:last-child {
            border-bottom: none;
        }
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: white;
            border: none;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.3px;
            color: #7f8c8d;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
        }
        .tab-button:hover {
            background: #f8f9fa;
        }
        .tab-button.active {
            color: #57068c;
            background: #f8f9fa;
            border-bottom: 3px solid #57068c;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .similarity-pair-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }
        .similarity-pair-item:hover {
            background: #f8f9fa;
        }
        .pair-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .pair-ids {
            font-weight: 600;
            color: #2c3e50;
            font-size: 15px;
        }
        .similarity-badge {
            padding: 6px 14px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
        }
        .similarity-high {
            background: #e74c3c;
            color: white;
        }
        .similarity-medium {
            background: #f39c12;
            color: white;
        }
        .similarity-low {
            background: #27ae60;
            color: white;
        }
        .response-preview {
            font-size: 13px;
            color: #666;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .flagged-respondent-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }
        .flagged-respondent-item:hover {
            background: #f8f9fa;
        }
        .flagged-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .flag-count-badge {
            background: #e74c3c;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        .match-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .match-chip {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }
        .modal-content {
            background: white;
            max-width: 1200px;
            margin: 40px auto;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .modal-header {
            background: #57068C;
            color: white;
            padding: 20px;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover {
            opacity: 0.7;
        }
        .modal-body {
            padding: 25px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .comparison-box {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        .comparison-header {
            background: #ecf0f1;
            padding: 10px 15px;
            font-weight: 600;
            color: #2c3e50;
        }
        .comparison-text {
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
        }
        .shared-phrases-box {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }
        .shared-phrases-box h4 {
            margin: 0 0 10px 0;
            color: #856404;
            font-size: 14px;
        }
        .phrase-chip {
            display: inline-block;
            background: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 4px;
            border: 1px solid #ffc107;
        }
        .highlight-match {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .highlight-exact {
            background: #ffeb3b;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }
        .highlight-fuzzy {
            background: #ffe0b2;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px dotted #ff9800;
        }
        .info-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            background: #57068C;
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            margin-left: 4px;
            position: relative;
        }
        .info-icon:hover {
            background: #440670;
        }
        .tooltip {
            visibility: hidden;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #57068C;
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #2c3e50;
        }
        .info-icon:hover .tooltip {
            visibility: visible;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .pattern-result-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }
        .pattern-result-item:hover {
            background: #f8f9fa;
        }
        .pattern-terms {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }
        .pattern-term-badge {
            background: #e3f2fd;
            color: #1565c0;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 600;
            border: 1px solid #90caf9;
        }
        .pattern-arrow {
            color: #999;
            font-size: 18px;
            display: flex;
            align-items: center;
        }
        .pattern-metrics {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .pattern-metric-badge {
            display: flex;
            flex-direction: column;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #57068C;
        }
        .pattern-metric-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .pattern-metric-value {
            font-size: 18px;
            font-weight: 700;
            color: #57068C;
        }
        .lift-badge {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 14px;
        }
        .lift-high {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        .lift-medium {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        .lift-low {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }
        .pattern-respondents {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
        .pattern-expandable {
            cursor: pointer;
        }
        .pattern-details {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #57068C;
        }
        .pattern-details.expanded {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Fixed Header -->
    <header class="fixed-header">
        <div class="logo">
            <img src="https://i.imgur.com/HpJ1Z46.png" alt="AI in Education VIP Logo" />
        </div>
        <div class="header-title">The Homogenometry Dashboard</div>
        <div class="header-right">
            <div class="header-menu">
                <button class="menu-trigger" onclick="toggleHeaderMenu()" aria-label="Menu">
                    <i class="fas fa-ellipsis-v"></i>
                </button>
                <div class="header-dropdown" id="header-dropdown">
                    <button class="dropdown-item" onclick="document.getElementById('csvFile').click(); toggleHeaderMenu();">
                        <i class="fas fa-upload"></i> Upload CSV File
                    </button>
                    <button class="dropdown-item" onclick="toggleMetricSettings(); toggleHeaderMenu();">
                        <i class="fas fa-cog"></i> Metric Settings
                    </button>
                    <button class="dropdown-item" onclick="toggleMethodologyModal(); toggleHeaderMenu();">
                        <i class="fas fa-info-circle"></i> About / Methodology
                    </button>
                    <button class="dropdown-item" onclick="clearSession(); toggleHeaderMenu();">
                        <i class="fas fa-trash-alt"></i> Clear Session
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Hidden file input -->
    <input type="file" id="csvFile" class="file-input" accept=".csv" style="display: none;">

    <div class="container">

        <!-- Welcome Screen -->
        <div id="welcomeScreen" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 60vh; text-align: center; padding: 40px 20px;">
            <div style="max-width: 600px;">
                <div style="font-size: 72px; margin-bottom: 20px;"></div>
                <h1 style="color: #57068C; font-size: 32px; margin-bottom: 16px; font-weight: 600;">Welcome to The Homogenometry Dashboard</h1>
                <p style="color: #666; font-size: 18px; line-height: 1.6; margin-bottom: 40px;">
                    Analyze corpus-internal homogeneity by measuring pairwise similarity between responses.
                    For detecting unusual convergence in survey responses, essays, homework exercises, or any other corpus of texts. 
                </p>
                <button onclick="document.getElementById('csvFile').click()"
                    style="padding: 16px 40px; background: #57068C; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 18px; box-shadow: 0 4px 12px rgba(87, 6, 140, 0.3); transition: all 0.3s;"
                    onmouseover="this.style.background='#6d0aac'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(87, 6, 140, 0.4)'"
                    onmouseout="this.style.background='#57068C'; this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(87, 6, 140, 0.3)'">
                    <i class="fas fa-upload"></i> Upload CSV File
                </button>
                <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #57068C; text-align: left;">
                    <h4 style="margin-top: 0; color: #2c3e50; font-size: 16px;">CSV Format Requirements</h4>
                    <ul style="color: #666; font-size: 14px; line-height: 1.8; margin: 10px 0;">
                        <li>First row should contain column headers</li>
                        <li>Include an ID column (e.g., "Respondent ID", "Name", "Email")</li>
                        <li>Include one or more text response columns to analyze</li>
                        <li>UTF-8 encoding recommended for special characters</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="controls" id="controls" style="display: none;">
            <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 25px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600; white-space: nowrap;">Question Column:</label>
                    <select id="columnSelect"></select>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: 600; white-space: nowrap;">
                        Threshold: <span id="thresholdDisplay" style="color: #e74c3c;">0.60</span>
                    </label>
                    <input type="range" id="similarityThreshold" min="0.30" max="0.95" step="0.05" value="0.60"
                        style="width: 150px; height: 6px;"
                        oninput="updateThreshold(this.value)">
                </div>
                <div>
                    <button onclick="toggleMetricSettings()"
                        style="padding: 8px 16px; background: #57068C; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; white-space: nowrap;">
                        <i class="fas fa-cog"></i> Metric Settings
                    </button>
                </div>
            </div>
        </div>

        <!-- Metric Settings Modal -->
        <div class="modal" id="metricSettings" style="display: none;" onclick="if(event.target===this) toggleMetricSettings()">
            <div class="modal-content" style="max-width: 900px;" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h3 style="margin: 0; color: white;">Similarity Metrics Configuration</h3>
                    <button class="modal-close" onclick="toggleMetricSettings()">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="margin: 0 0 10px 0; font-size: 13px; color: #666;">
                        Select metrics to include in the Combined similarity score and set their weights. Higher weights = more influence on final score.
                    </p>
                    <div style="margin-bottom: 20px; padding: 12px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                        <strong style="color: #1565c0;">Weight Guidelines:</strong>
                        <div style="font-size: 12px; color: #555; margin-top: 5px;">
                            High (3.0+): Strong evidence of copying/paraphrasing (fuzzy matching, n-grams)<br>
                            Medium (1.0): Content similarity (cosine, Jaccard, NER)<br>
                            Low (0.3): Structural similarity (word count, sentence length)
                        </div>
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <!-- Cosine Similarity -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_cosine" checked onchange="toggleMetricWeight('cosine')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Cosine Similarity</strong>
                                <div style="font-size: 12px; color: #666;">Word frequency patterns</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_cosine" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('cosine', this.value)">
                                <span id="weightDisplay_cosine" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Jaccard Index -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_jaccard" checked onchange="toggleMetricWeight('jaccard')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Jaccard Index</strong>
                                <div style="font-size: 12px; color: #666;">Vocabulary overlap</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_jaccard" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('jaccard', this.value)">
                                <span id="weightDisplay_jaccard" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- N-gram Overlap -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngram" checked onchange="toggleMetricWeight('ngram')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram Overlap</strong>
                                <div style="font-size: 12px; color: #666;">Character sequence similarity</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngram" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngram', this.value)">
                                <span id="weightDisplay_ngram" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Sentence Variance -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_sentenceVariance" checked onchange="toggleMetricWeight('sentenceVariance')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Sentence Variance</strong>
                                <div style="font-size: 12px; color: #666;">Similar variation in sentence lengths</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_sentenceVariance" min="0.1" max="5.0" step="0.1" value="0.3"
                                       style="flex: 1;" oninput="updateWeightDisplay('sentenceVariance', this.value)">
                                <span id="weightDisplay_sentenceVariance" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.3</span>
                            </div>
                        </div>

                        <!-- Word Count -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordCount" checked onchange="toggleMetricWeight('wordCount')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Word Count</strong>
                                <div style="font-size: 12px; color: #666;">Similar response length - LOW signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordCount" min="0.1" max="5.0" step="0.1" value="0.3"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordCount', this.value)">
                                <span id="weightDisplay_wordCount" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.3</span>
                            </div>
                        </div>

                        <!-- Avg Sentence Length -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_avgSentenceLength" checked onchange="toggleMetricWeight('avgSentenceLength')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Avg Sentence Length</strong>
                                <div style="font-size: 12px; color: #666;">Similar sentence complexity - LOW signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_avgSentenceLength" min="0.1" max="5.0" step="0.1" value="0.3"
                                       style="flex: 1;" oninput="updateWeightDisplay('avgSentenceLength', this.value)">
                                <span id="weightDisplay_avgSentenceLength" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.3</span>
                            </div>
                        </div>

                        <!-- Temporal Burstiness -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_temporalBurstiness" onchange="toggleMetricWeight('temporalBurstiness')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Temporal Burstiness</strong>
                                <div style="font-size: 12px; color: #666;">Word clustering patterns (Cui et al. 2017) - SLOW</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_temporalBurstiness" min="0.1" max="5.0" step="0.1" value="0.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('temporalBurstiness', this.value)">
                                <span id="weightDisplay_temporalBurstiness" style="min-width: 35px; font-weight: 600; font-size: 13px;">0.5</span>
                            </div>
                        </div>

                        <!-- Pronoun Density -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_pronounDensity" checked onchange="toggleMetricWeight('pronounDensity')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Pronoun Density</strong>
                                <div style="font-size: 12px; color: #666;">First-person usage patterns</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_pronounDensity" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('pronounDensity', this.value)">
                                <span id="weightDisplay_pronounDensity" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Transition Words -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_transitionWords" checked onchange="toggleMetricWeight('transitionWords')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Transition Words</strong>
                                <div style="font-size: 12px; color: #666;">Discourse marker usage</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_transitionWords" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('transitionWords', this.value)">
                                <span id="weightDisplay_transitionWords" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- N-gram with Punctuation -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngramPunctuation" checked onchange="toggleMetricWeight('ngramPunctuation')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram with Punctuation</strong>
                                <div style="font-size: 12px; color: #666;">3-char sequences keeping punctuation</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngramPunctuation" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngramPunctuation', this.value)">
                                <span id="weightDisplay_ngramPunctuation" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- 3-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordNgram" checked onchange="toggleMetricWeight('wordNgram')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>3-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Word-level n-grams - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordNgram" min="0.1" max="5.0" step="0.1" value="2.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordNgram', this.value)">
                                <span id="weightDisplay_wordNgram" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.0</span>
                            </div>
                        </div>

                        <!-- N-gram 4-char -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngram4" checked onchange="toggleMetricWeight('ngram4')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram 4-char</strong>
                                <div style="font-size: 12px; color: #666;">4-character sequences</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngram4" min="0.1" max="5.0" step="0.1" value="1.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngram4', this.value)">
                                <span id="weightDisplay_ngram4" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.5</span>
                            </div>
                        </div>

                        <!-- N-gram 5-char -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ngram5" checked onchange="toggleMetricWeight('ngram5')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>N-gram 5-char</strong>
                                <div style="font-size: 12px; color: #666;">5-character sequences - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ngram5" min="0.1" max="5.0" step="0.1" value="2.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ngram5', this.value)">
                                <span id="weightDisplay_ngram5" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.0</span>
                            </div>
                        </div>

                        <!-- Named Entity Recognition -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_ner" checked onchange="toggleMetricWeight('ner')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Named Entity Recognition</strong>
                                <div style="font-size: 12px; color: #666;">Extracts all capitalized sequences (proper nouns)</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_ner" min="0.1" max="5.0" step="0.1" value="1.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('ner', this.value)">
                                <span id="weightDisplay_ner" style="min-width: 35px; font-weight: 600; font-size: 13px;">1.0</span>
                            </div>
                        </div>

                        <!-- Fuzzy 3-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_fuzzyNgram3" onchange="toggleMetricWeight('fuzzyNgram3')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Fuzzy 3-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Levenshtein â‰¤5 edits - catches short paraphrasing - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_fuzzyNgram3" min="0.1" max="5.0" step="0.1" value="2.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('fuzzyNgram3', this.value)">
                                <span id="weightDisplay_fuzzyNgram3" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.5</span>
                            </div>
                        </div>

                        <!-- Fuzzy 6-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_fuzzyNgram6" onchange="toggleMetricWeight('fuzzyNgram6')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Fuzzy 6-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Levenshtein â‰¤13 edits - detects longer paraphrasing - MEDIUM-HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_fuzzyNgram6" min="0.1" max="5.0" step="0.1" value="2.5"
                                       style="flex: 1;" oninput="updateWeightDisplay('fuzzyNgram6', this.value)">
                                <span id="weightDisplay_fuzzyNgram6" style="min-width: 35px; font-weight: 600; font-size: 13px;">2.5</span>
                            </div>
                        </div>

                        <!-- Word-Level 3-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordLevelFuzzy3" checked onchange="toggleMetricWeight('wordLevelFuzzy3')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Word-Level 3-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Word substitutions â‰¤1 - catches "helping" â†’ "aiding" - VERY HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordLevelFuzzy3" min="0.1" max="5.0" step="0.1" value="3.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordLevelFuzzy3', this.value)">
                                <span id="weightDisplay_wordLevelFuzzy3" style="min-width: 35px; font-weight: 600; font-size: 13px;">3.0</span>
                            </div>
                        </div>

                        <!-- Word-Level 5-Word Phrases -->
                        <div style="display: flex; align-items: center; padding: 12px; border: 1px solid #e0e0e0; border-radius: 5px; background: #fafafa;">
                            <input type="checkbox" id="metric_wordLevelFuzzy5" checked onchange="toggleMetricWeight('wordLevelFuzzy5')">
                            <div style="flex: 1; margin-left: 10px;">
                                <strong>Word-Level 5-Word Phrases</strong>
                                <div style="font-size: 12px; color: #666;">Word substitutions â‰¤2 - detects phrase-level paraphrasing - VERY HIGH signal</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; min-width: 220px;">
                                <label style="font-size: 12px; color: #666; min-width: 60px;">Weight:</label>
                                <input type="range" id="weight_wordLevelFuzzy5" min="0.1" max="5.0" step="0.1" value="3.0"
                                       style="flex: 1;" oninput="updateWeightDisplay('wordLevelFuzzy5', this.value)">
                                <span id="weightDisplay_wordLevelFuzzy5" style="min-width: 35px; font-weight: 600; font-size: 13px;">3.0</span>
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-size: 13px; color: #666; font-style: italic;">
                            Click "Apply Metrics" to recalculate with your selected metrics
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveMetricSettings()"
                                style="padding: 10px 24px; background: #57068C; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 14px;">
                                Apply Metrics
                            </button>
                            <button onclick="toggleMetricSettings()"
                                style="padding: 10px 24px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 14px;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Methodology Modal -->
        <div class="modal" id="methodologyModal" style="display: none;" onclick="if(event.target===this) toggleMethodologyModal()">
            <div class="modal-content" style="max-width: 700px;" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h3 style="margin: 0; color: white;">About / Methodology</h3>
                    <button class="modal-close" onclick="toggleMethodologyModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <h4 style="margin-top: 0; color: #57068C;">The Homogenometry Dashboard</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        This tool measures <strong>corpus-internal homogeneity</strong> by computing pairwise similarity between all responses
                        in your dataset. A dataset may be a collection of student essays, homework exercises, Google Form responses, or any
                        set of text responses you wish to analyze. Rather than comparing against external benchmarks or looking for specific "tells" (like the word "delve"
                        or em dashes), it reveals which responses are unusually similar <em>to each other</em>. Each metric is calculated and
                        displayed separately for transparent interpretation.
                    </p>

                    <h4 style="color: #57068C; margin-top: 25px;">Why This Approach?</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        Traditional detection tools search for specific patterns or "fingerprints" (certain vocabulary, punctuation habits,
                        sentence structures). This approach has limitations:
                    </p>
                    <ul style="font-size: 14px; line-height: 1.8; color: #555;">
                        <li><strong>Model-specific:</strong> AI fingerprints change with each new model version</li>
                        <li><strong>False positives:</strong> Human writers may naturally use flagged words or patterns</li>
                        <li><strong>Narrow focus:</strong> Only detects one specific source (e.g., AI) rather than any form of similarity</li>
                    </ul>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        <strong>Homogeneity analysis is different:</strong> It doesn't care <em>why</em> responses are similarâ€”whether from
                        AI use, copying, collaboration, or shared sources. It simply identifies pairs showing unusual convergence in vocabulary,
                        phrasing, and structure. This makes it model-agnostic, future-proof, and equally effective at catching copying between
                        humans as AI-assisted writing.
                    </p>

                    <h4 style="color: #57068C; margin-top: 25px;">How It Works</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        The analyzer computes pairwise similarity between all responses using 18 distinct metrics, each capturing different
                        aspects of textual similarity. All metrics can be enabled/disabled and weighted via Metric Settings.
                    </p>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Lexical Similarity Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>1. Cosine Similarity</strong> - Measures similarity in word frequency patterns by treating each text as a vector
                            of word counts. High scores indicate similar vocabulary usage rates.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A: "The cat sat on the mat" (the=2, cat=1, sat=1...) vs Text B: "The dog sat on the rug"
                            (the=2, dog=1, sat=1...) - Similar frequency patterns despite different words.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>2. Jaccard Index</strong> - Calculates the proportion of shared unique words relative to total unique words.
                            Measures vocabulary overlap without considering word frequency.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A uses {education, reform, policy, students} and Text B uses {education, policy, teachers, funding}.
                            Shared: 2 words. Total unique: 6 words. Jaccard = 2/6 = 33.3%.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Character-Level N-gram Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>3. N-gram Similarity (3-character)</strong> - Compares sequences of 3 consecutive characters, ignoring punctuation.
                            Detects similar spelling patterns and word fragments.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "education" â†’ {edu, duc, uca, cat, ati, tio, ion}. Matches with "educational" which shares most
                            of these 3-grams.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>4. N-gram Similarity (4-character)</strong> - Same as above but using 4-character sequences for more specificity.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "therefore" â†’ {ther, here, eref, refo, efor, fore}. Catches longer spelling patterns.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>5. N-gram Similarity (5-character)</strong> - Uses 5-character sequences for even more specific pattern matching.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Useful for detecting copy-paste of unique phrases or technical terms like "photosynthesis."
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>6. N-gram with Punctuation</strong> - Same as 3-character n-grams but preserves punctuation, capturing formatting
                            and stylistic choices.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "don't" vs "dont" vs "do not" - preserved punctuation reveals exact stylistic matches.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Word-Level N-gram Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>7. Word N-gram (3-word phrases)</strong> - Identifies shared 3-word sequences. Excellent for detecting copied phrases
                            and sentence fragments.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "In other words" appears in both texts. "The main argument" appears in both. Indicates
                            similar phrasing patterns or direct copying.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Fuzzy Matching Metrics (Paraphrase Detection)</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>8. Fuzzy N-gram (3-word phrases, â‰¤5 character edits)</strong> - Compares 3-word phrases allowing up to 5 character
                            differences via Levenshtein distance. Catches light paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "the primary argument" matches "the main argument" (5 character changes: "primary" â†’ "main").
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>9. Fuzzy N-gram (6-word phrases, â‰¤13 character edits)</strong> - Longer phrases with more tolerance for changes.
                            Detects more extensive paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "In conclusion we can see that education" matches "In summary we observe that schooling"
                            (multiple word substitutions within tolerance).
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>10. Word-Level Fuzzy (3-word phrases, â‰¤1 word substitution)</strong> - Compares 3-word phrases allowing exactly
                            1 word to differ. Detects single-word paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "climate change impacts" matches "climate change effects" (1 word different: impacts â†’ effects).
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>11. Word-Level Fuzzy (5-word phrases, â‰¤2 word substitutions)</strong> - Longer phrases allowing up to 2 words
                            to differ. Catches multi-word paraphrasing.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> "the study reveals important findings about" matches "this research shows significant results regarding"
                            (2 words changed: studyâ†’research, revealsâ†’shows).
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Structural Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>12. Word Count Similarity</strong> - Measures similarity in total word count. Responses with similar length
                            requirements often have similar word counts.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A has 247 words, Text B has 251 words. Very similar lengths may indicate similar levels
                            of elaboration or adherence to length requirements.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>13. Average Sentence Length</strong> - Compares the mean number of words per sentence. Reflects writing style
                            and complexity.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A averages 18.3 words/sentence, Text B averages 18.7 words/sentence. Similar sentence
                            length patterns suggest similar writing styles or shared sources.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>14. Sentence Length Variance</strong> - Measures similarity in sentence length variability. Writers with consistent
                            sentence rhythms show similar variance patterns.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A has sentence lengths [10, 12, 9, 11] (low variance = consistent). Text B has [8, 22, 5, 19]
                            (high variance = varied). Different writing styles.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Stylistic Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>15. Pronoun Density</strong> - Compares the proportion of pronouns (I, you, he, she, it, we, they, etc.) in each text.
                            Reflects perspective and voice.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A: 12% pronouns (first-person narrative). Text B: 2% pronouns (formal academic). Very different
                            writing styles. Similarity indicates shared voice or perspective.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>16. Transition Words Density</strong> - Measures usage frequency of transition words and phrases (however, furthermore,
                            for example, in other words, etc.). Reflects rhetorical sophistication and organization.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A uses 15 transition phrases in 500 words (3.0%). Text B uses 14 in 480 words (2.9%). Similar
                            usage patterns suggest similar rhetorical training or shared source material.
                        </div>
                    </div>

                    <h5 style="color: #57068C; margin-top: 20px; margin-bottom: 10px; font-size: 15px;">Advanced Metrics</h5>

                    <div style="margin-left: 15px;">
                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>17. Named Entity Recognition (NER)</strong> - Identifies and compares proper nouns (people, places, organizations).
                            Shared entities indicate common source material or topics.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Both texts mention "Stanford University," "John Dewey," and "Department of Education." High entity
                            overlap suggests citing the same sources or discussing identical examples.
                        </div>

                        <p style="font-size: 13px; line-height: 1.6; color: #555; margin-bottom: 10px;">
                            <strong>18. Temporal Burstiness</strong> - Analyzes word positioning patterns using the burstiness metric from Cui et al. (2017).
                            Words that appear in concentrated "bursts" vs. evenly distributed show different usage patterns.
                        </p>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 12px; font-size: 12px; color: #666;">
                            <strong>Example:</strong> Text A uses "democracy" clustered in the introduction (bursty, Î¼=0.8). Text B uses "democracy"
                            evenly throughout (distributed, Î¼=0.2). Similar burstiness patterns suggest similar organizational strategies or copied structure.
                        </div>
                    </div>

                    <p style="font-size: 13px; line-height: 1.6; color: #555; margin-top: 20px; font-style: italic;">
                        All 18 metrics are combined using weighted averaging with min-max normalization. Configure which metrics to use
                        and their relative weights via the Metric Settings button in the header menu.
                    </p>

                    <h4 style="color: #57068C; margin-top: 25px;">Interpretation</h4>
                    <p style="font-size: 14px; line-height: 1.6; color: #555;">
                        High similarity scores indicate responses that share unusual amounts of vocabulary, phrasing, or structure.
                        While this doesn't prove misconduct, it flags pairs that warrant closer human review. Adjust the similarity
                        threshold to balance sensitivity and specificity for your use case.
                    </p>

                    <h4 style="color: #e74c3c; margin-top: 25px;">Important Limitations</h4>

                    <p style="font-size: 14px; line-height: 1.6; color: #555; margin-bottom: 15px;">
                        <strong>Scores are dataset-relative, not absolute.</strong> The tool uses min-max normalization to make metrics
                        comparable <em>within</em> each analysis session, but this means similarity scores cannot be meaningfully compared
                        <em>across</em> different datasets.
                    </p>

                    <div style="background: #fff3cd; padding: 15px; border-radius: 5px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <p style="font-size: 13px; margin: 0 0 10px 0; color: #856404;">
                            <strong>Why this matters:</strong> A 60% similarity score in one dataset may be more significant than a 75% score
                            in another, depending on the "natural" variance in that corpus.
                        </p>
                        <p style="font-size: 13px; margin: 0; color: #856404;">
                            <strong>Example:</strong> Responses to "Define photosynthesis" naturally cluster around similar definitions (high baseline
                            similarity). Responses to "Write a creative short story" show much greater diversity (low baseline). After normalization,
                            both datasets span 0-100%, but the underlying similarity levels are completely different.
                        </p>
                    </div>

                    <p style="font-size: 14px; line-height: 1.6; color: #555; margin-bottom: 8px;">
                        <strong>Factors affecting score interpretation:</strong>
                    </p>
                    <ul style="font-size: 14px; line-height: 1.8; color: #555; margin-top: 0;">
                        <li><strong>Population size:</strong> Smaller datasets may have narrower variance ranges, affecting normalization</li>
                        <li><strong>Genre conventions:</strong> Academic essays, technical writing, and formulaic responses naturally show higher baseline similarity than creative or open-ended writing</li>
                        <li><strong>Prompt specificity:</strong> Highly constrained prompts (e.g., "List the steps of mitosis") produce more homogeneous responses than open prompts</li>
                        <li><strong>Entry length:</strong> Shorter responses have fewer opportunities for divergence in vocabulary and structure</li>
                        <li><strong>Skill variance:</strong> Homogeneous skill levels (e.g., all advanced writers) produce different score distributions than mixed-ability groups</li>
                        <li><strong>Shared source material:</strong> If the assignment requires citing specific texts, legitimate responses will naturally share quoted material and terminology</li>
                    </ul>

                    <p style="font-size: 14px; line-height: 1.6; color: #555; margin-top: 15px;">
                        <strong>Best practice:</strong> Use similarity scores to compare pairs <em>within the same analysis session</em>, not across different
                        datasets or assignments. Establish context-appropriate thresholds based on the specific assignment type, expected diversity, and your
                        population's characteristics.
                    </p>

                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #17a2b8;">
                        <p style="font-size: 13px; margin: 0 0 8px 0; color: #0c5460;">
                            <strong>Additional limitations:</strong>
                        </p>
                        <ul style="font-size: 13px; margin: 0; color: #0c5460; line-height: 1.6;">
                            <li>The tool cannot determine <em>why</em> responses are similar (AI use, copying, collaboration, shared sources, or coincidence)</li>
                            <li>Short responses (&lt;50 words) may produce unreliable similarity scores due to limited text for comparison</li>
                            <li>Non-English text may not be properly tokenized, affecting accuracy of word-based metrics</li>
                            <li>Paraphrasing that preserves meaning while changing vocabulary may not be fully detected by lexical metrics</li>
                            <li>Statistical significance: With large datasets, even low similarity scores may represent genuine patterns requiring investigation</li>
                        </ul>
                    </div>

                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px; border-left: 4px solid #57068C;">
                        <p style="font-size: 13px; margin: 0; color: #666;">
                            <strong>Note:</strong> This tool is designed for academic integrity research and should be used as one component
                            of a comprehensive evaluation process, not as the sole determinant of academic misconduct.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="dashboard" id="dashboard" style="display: none;">
            <div id="pairs-tab" class="tab-content active">
                <!-- Flagged Respondents Panel with Tabs -->
                <div class="metric-panel" id="frequentRespondentsPanel" style="display: none;">
                    <div class="panel-header" style="background: linear-gradient(135deg, #57068c 0%, #7b1fa2 100%); padding: 18px 25px; box-shadow: 0 2px 8px rgba(87, 6, 140, 0.15);">
                        <!-- Toggle Switch (Left Side) -->
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <!-- Flagged Respondents Label -->
                            <label for="panelModeToggle" id="flaggedLabel" style="cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s; color: white; display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-flag" style="font-size: 14px;"></i>
                                <span>Flagged Respondents</span>
                            </label>

                            <!-- Toggle Switch -->
                            <label style="position: relative; display: inline-block; width: 52px; height: 28px; cursor: pointer;">
                                <input type="checkbox" id="panelModeToggle" onchange="togglePanelMode()" style="opacity: 0; width: 0; height: 0;">
                                <span id="toggleTrack" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.3); border-radius: 14px; transition: all 0.3s; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);"></span>
                                <span id="toggleSlider" style="position: absolute; content: ''; height: 22px; width: 22px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: all 0.3s; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></span>
                            </label>

                            <!-- Pattern Search Label -->
                            <label for="panelModeToggle" id="patternLabel" style="cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.3s; color: rgba(255,255,255,0.5); display: flex; align-items: center; gap: 8px;">
                                <i class="fas fa-search" style="font-size: 14px;"></i>
                                <span>Pattern Search</span>
                            </label>
                        </div>

                        <!-- Description (Right Side) -->
                        <span class="panel-info" id="panelModeInfo" style="font-size: 13px; opacity: 0.9; font-weight: 400;">
                            Analysis by similarity patterns
                        </span>
                    </div>
                    <div class="panel-content" id="flaggedRespondentsContent">
                        <!-- Tabs for Most/Least Flagged -->
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0;">
                            <button id="mostFlaggedTab" onclick="switchFlaggedTab('most')"
                                style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid #57068C; color: #57068C; font-weight: 600; cursor: pointer;">
                                Most Flagged
                            </button>
                            <button id="leastFlaggedTab" onclick="switchFlaggedTab('least')"
                                style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; color: #666; font-weight: 600; cursor: pointer;">
                                Least Flagged
                            </button>
                        </div>

                        <div id="mostFlaggedContent">
                            <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Respondents appearing in multiple high-similarity pairs</p>
                            <div id="frequentRespondentsList"></div>
                        </div>

                        <div id="leastFlaggedContent" style="display: none;">
                            <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Respondents with consistently low similarity to others</p>
                            <div id="infrequentRespondentsList"></div>
                        </div>
                    </div>
                    <div class="panel-content" id="patternSearchContent" style="display: none;">
                        <p style="font-size: 13px; color: #666; margin-bottom: 15px;">
                            Discover word and phrase combinations with unusually strong correlations.
                            Lift indicates how much more likely terms appear together than by chance.
                        </p>

                        <!-- Specific Term Search -->
                        <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 10px 0; color: #856404; font-size: 14px;">
                                ðŸ” Search for Specific Term Correlations
                            </h4>
                            <p style="font-size: 12px; color: #666; margin-bottom: 10px;">
                                Enter terms separated by commas (no limit). For a single term, discover what other words/phrases correlate with it.
                                For multiple terms, see if they appear together more than random chance would predict.
                                <strong>Use * as a wildcard</strong> to match word stems (e.g., "align*" matches align, aligns, alignment, etc.)
                            </p>
                            <div style="display: flex; gap: 10px; align-items: start;">
                                <div style="flex: 1;">
                                    <input type="text" id="specificTermsInput" placeholder="e.g., align* or learning environment, personal*"
                                        style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 5px; font-size: 14px;">
                                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                                        Examples: "align*" (single) or "align*, student*" (multiple) or "learn*, engage*, outcome*"
                                    </div>
                                </div>
                                <button onclick="searchSpecificTerms()"
                                    style="padding: 10px 20px; background: #ffc107; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; white-space: nowrap; height: fit-content;">
                                    <i class="fas fa-search"></i> Search
                                </button>
                            </div>
                            <div id="specificTermsResult" style="margin-top: 15px;"></div>
                        </div>

                        <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="font-weight: 600; white-space: nowrap;">Pattern Size:</label>
                                <select id="patternSizeSelect" onchange="updatePatternAnalysis()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 5px;">
                                    <option value="all">All Sizes</option>
                                    <option value="2" selected>Pairs (2 terms)</option>
                                    <option value="3">Trios (3 terms)</option>
                                    <option value="4">Quartets (4 terms)</option>
                                </select>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="font-weight: 600; white-space: nowrap;">
                                    Min Lift: <span id="minLiftDisplay" style="color: #e74c3c;">2.0</span>
                                </label>
                                <input type="range" id="minLiftSlider" min="1.5" max="5.0" step="0.5" value="2.0"
                                    style="width: 120px;" oninput="updateMinLiftDisplay(this.value)">
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="font-weight: 600; white-space: nowrap;">
                                    Min Support: <span id="minSupportDisplay" style="color: #e74c3c;">3</span>
                                </label>
                                <input type="range" id="minSupportSlider" min="2" max="10" step="1" value="3"
                                    style="width: 120px;" oninput="updateMinSupportDisplay(this.value)">
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="font-weight: 600; white-space: nowrap;">Sort By:</label>
                                <select id="patternSortSelect" onchange="updatePatternAnalysis()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 5px;">
                                    <option value="suspicion">Most Suspicious First</option>
                                    <option value="lift">Highest Lift First</option>
                                    <option value="support">Highest Support First</option>
                                </select>
                            </div>
                            <button onclick="analyzePatterns()"
                                style="padding: 8px 20px; background: #57068C; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; white-space: nowrap;">
                                <i class="fas fa-search"></i> Analyze Patterns
                            </button>
                        </div>

                        <div id="patternResultsContainer">
                            <div style="text-align: center; padding: 40px; color: #999;">
                                <i class="fas fa-chart-line" style="font-size: 48px; margin-bottom: 15px; opacity: 0.3;"></i>
                                <p>Click "Analyze Patterns" to discover correlations in your data</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Similarity Pairs List -->
                <div class="metric-panel" id="similarityPairsPanel">
                    <div class="panel-header">
                        High Similarity Pairs
                        <span class="panel-info" id="pairCountDisplay">0 pairs above threshold</span>
                    </div>
                    <div class="panel-content">
                        <div id="similarityPairsList">
                            <p style="color: #999; text-align: center; padding: 40px;">
                                Upload a file to see similarity analysis
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="export-btn" onclick="exportResults()">
                    ðŸ“¥ Export Analysis Report
                </button>
            </div>
        </div>

        <!-- Comparison Modal -->
        <div class="modal" id="comparisonModal" onclick="if(event.target===this) closeModal()">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modalTitle">Response Comparison</h3>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <div class="modal-body" id="modalBody"></div>
            </div>
        </div>

        <!-- Pattern Group Comparison Modal -->
        <div class="modal" id="patternGroupModal" onclick="if(event.target===this) closePatternGroupModal()">
            <div class="modal-content" style="max-width: 1400px;">
                <div class="modal-header" style="background: #57068C; color: white;">
                    <h3 id="patternGroupTitle" style="margin: 0; color: white;">Pattern Group Comparison</h3>
                    <button class="modal-close" onclick="closePatternGroupModal()">&times;</button>
                </div>
                <div class="modal-body" id="patternGroupBody" style="max-height: 80vh; overflow-y: auto; padding: 0;"></div>
            </div>
        </div>

        <!-- Progress Modal -->
        <div class="modal" id="progressModal" style="z-index: 10002; background: rgba(0,0,0,0.7);">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header" style="background: #57068C; color: white; padding: 20px;">
                    <h3 id="progressTitle" style="margin: 0; color: white;">Analyzing Corpus...</h3>
                </div>
                <div class="modal-body" style="padding: 30px;">
                    <div style="margin-bottom: 20px;">
                        <div id="progressMessage" style="font-size: 14px; color: #666; margin-bottom: 10px;">
                            Initializing...
                        </div>
                        <div style="background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden;">
                            <div id="progressBar" style="background: linear-gradient(90deg, #57068C, #8e44ad); height: 100%; width: 0%; transition: width 0.3s;">
                            </div>
                        </div>
                        <div id="progressPercent" style="text-align: center; margin-top: 8px; font-weight: bold; color: #57068C;">
                            0%
                        </div>
                    </div>
                    <div id="progressDetails" style="font-size: 13px; color: #999; margin-bottom: 20px; min-height: 40px;">
                    </div>
                    <div style="text-align: center;">
                        <button id="cancelButton" onclick="cancelAnalysis()"
                            style="padding: 10px 30px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Spinner -->
        <div id="loadingSpinner" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10003; justify-content: center; align-items: center;">
            <div style="text-align: center;">
                <div style="border: 8px solid #f3f3f3; border-top: 8px solid #57068C; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                <p style="color: white; margin-top: 20px; font-size: 16px; font-weight: 600;">Loading...</p>
            </div>
        </div>

        <!-- Calculation Details Modal (appears on top of comparison modal) -->
        <div class="modal" id="calculationModal" onclick="if(event.target===this) closeCalculationModal()" style="z-index: 10001;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="calculationTitle">Calculation Details</h3>
                    <button class="modal-close" onclick="closeCalculationModal()">&times;</button>
                </div>
                <div class="modal-body" id="calculationBody"></div>
            </div>
        </div>
    </div>

    <script>
        let csvData = [];
        let headers = [];
        let currentColumn = 0;
        let analysisResults = {};
        let responses = []; // Global responses array
        let analysisIsRunning = false;
        let cancelRequested = false;
        let isRestoringSession = false;
        let metricNormalizationParams = {}; // Stores min/max for each metric for normalization

        // ========== HEADER MENU ==========

        function toggleHeaderMenu() {
            const dropdown = document.getElementById('header-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('header-dropdown');
            const menuTrigger = document.querySelector('.menu-trigger');
            if (dropdown && !dropdown.contains(event.target) && !menuTrigger.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // ========== SESSION PERSISTENCE ==========

        // Helper function to compress data for localStorage
        function compressData(data) {
            try {
                const jsonString = JSON.stringify(data);
                // Use LZString compression (simple algorithm that works in all browsers)
                // For simplicity, we'll just store a subset of the data
                return jsonString;
            } catch (e) {
                console.error('Compression failed:', e);
                return null;
            }
        }

        // Helper function to save large data efficiently
        function saveLargeData(key, data) {
            try {
                const jsonString = JSON.stringify(data);
                const sizeInMB = (jsonString.length * 2) / (1024 * 1024); // Rough size in MB

                console.log(`ðŸ“¦ Attempting to save ${key}, size: ${sizeInMB.toFixed(2)}MB`);

                if (sizeInMB > 4) {
                    console.warn(`âš  ${key} is very large (${sizeInMB.toFixed(2)}MB), storing reduced dataset`);

                    // For similarity pairs, store only essential data
                    if (key.includes('similarityPairs') && Array.isArray(data)) {
                        const reducedData = data.map(pair => ({
                            i1: pair.id1,
                            i2: pair.id2,
                            s: Math.round(pair.similarity * 10000) / 10000  // Round to 4 decimals
                            // Omit text1 and text2 to save space
                        }));
                        localStorage.setItem(key, JSON.stringify(reducedData));
                        console.log(`âœ“ Saved ${key} (reduced format)`);
                        return true;
                    }
                }

                localStorage.setItem(key, jsonString);
                console.log(`âœ“ Saved ${key}`);
                return true;
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.error(`âŒ ${key} exceeded localStorage quota`);
                    return false;
                }
                throw e;
            }
        }

        function saveSession() {
            // Skip saving if we're in the middle of restoring a session
            if (isRestoringSession) {
                console.log('â¸ Skipping save during session restoration');
                return;
            }

            try {
                // Always save basic session data
                localStorage.setItem('homogeneityAnalyzer_csvData', JSON.stringify(csvData));
                localStorage.setItem('homogeneityAnalyzer_headers', JSON.stringify(headers));
                localStorage.setItem('homogeneityAnalyzer_currentColumn', currentColumn.toString());
                localStorage.setItem('homogeneityAnalyzer_threshold', document.getElementById('similarityThreshold')?.value || '0.60');

                // Save complete analysis state to avoid recalculation
                // Always save these, even if they're empty/null, to indicate state
                try {
                    if (analysisResults) {
                        localStorage.setItem('homogeneityAnalyzer_analysisResults', JSON.stringify(analysisResults));
                        console.log('âœ“ Saved analysisResults');
                    } else {
                        console.warn('âš  analysisResults is null/undefined, not saving');
                    }
                } catch (e) {
                    console.error('Failed to save analysisResults:', e.message);
                }

                try {
                    if (allSimilarityPairs && allSimilarityPairs.length > 0) {
                        saveLargeData('homogeneityAnalyzer_similarityPairs', allSimilarityPairs);
                    } else {
                        console.warn('âš  allSimilarityPairs is empty or undefined, not saving');
                    }
                } catch (e) {
                    console.error('Failed to save similarityPairs:', e.message);
                }

                try {
                    if (responses && responses.length > 0) {
                        localStorage.setItem('homogeneityAnalyzer_responses', JSON.stringify(responses));
                        console.log('âœ“ Saved', responses.length, 'responses');
                    } else {
                        console.warn('âš  responses is empty or undefined, not saving');
                    }
                } catch (e) {
                    console.error('Failed to save responses:', e.message);
                }

                // Save panel mode state (flagged vs pattern search)
                const panelToggle = document.getElementById('panelModeToggle');
                if (panelToggle) {
                    localStorage.setItem('homogeneityAnalyzer_panelMode', panelToggle.checked ? 'pattern' : 'flagged');
                }

                // Save pattern search terms if in pattern mode
                if (currentPatternSearchTerms && currentPatternSearchTerms.length > 0) {
                    localStorage.setItem('homogeneityAnalyzer_patternSearchTerms', JSON.stringify(currentPatternSearchTerms));
                }

                console.log('âœ“ Session save complete');
            } catch (e) {
                console.error('Failed to save session:', e);
                // If localStorage is full, try to clear old data
                if (e.name === 'QuotaExceededError') {
                    console.error('localStorage quota exceeded! Data is too large to save.');
                    alert('Warning: Your data is too large to save automatically. Analysis will need to be recalculated on page reload.');
                }
            }
        }

        function restoreSession() {
            try {
                isRestoringSession = true;  // Set flag to prevent saves during restoration
                console.log('ðŸ”„ Attempting to restore session...');
                const savedCsvData = localStorage.getItem('homogeneityAnalyzer_csvData');
                const savedHeaders = localStorage.getItem('homogeneityAnalyzer_headers');
                const savedColumn = localStorage.getItem('homogeneityAnalyzer_currentColumn');
                const savedThreshold = localStorage.getItem('homogeneityAnalyzer_threshold');

                if (savedCsvData && savedHeaders) {
                    console.log('âœ“ Found saved CSV data and headers');
                    csvData = JSON.parse(savedCsvData);
                    headers = JSON.parse(savedHeaders);
                    currentColumn = parseInt(savedColumn) || 1;

                    // Populate column selector
                    const select = document.getElementById('columnSelect');
                    select.innerHTML = '';
                    headers.forEach((header, i) => {
                        if (i > 0 && header.trim()) {
                            const option = document.createElement('option');
                            option.value = i;
                            option.textContent = header.length > 80 ? header.substring(0, 80) + '...' : header;
                            if (i === currentColumn) option.selected = true;
                            select.appendChild(option);
                        }
                    });

                    // Restore threshold
                    if (savedThreshold) {
                        document.getElementById('similarityThreshold').value = savedThreshold;
                        document.getElementById('thresholdDisplay').textContent = savedThreshold;
                    }

                    // Hide welcome screen and show app interface
                    document.getElementById('welcomeScreen').style.display = 'none';
                    document.getElementById('controls').style.display = 'block';
                    document.getElementById('dashboard').style.display = 'block';

                    // Try to restore saved analysis state to avoid recalculation
                    const savedAnalysisResults = localStorage.getItem('homogeneityAnalyzer_analysisResults');
                    const savedSimilarityPairs = localStorage.getItem('homogeneityAnalyzer_similarityPairs');
                    const savedResponses = localStorage.getItem('homogeneityAnalyzer_responses');

                    console.log('Checking saved analysis data:');
                    console.log('  - analysisResults:', savedAnalysisResults ? 'âœ“ exists' : 'âœ— missing');
                    console.log('  - similarityPairs:', savedSimilarityPairs ? 'âœ“ exists' : 'âœ— missing');
                    console.log('  - responses:', savedResponses ? 'âœ“ exists' : 'âœ— missing');

                    if (savedAnalysisResults && savedSimilarityPairs && savedResponses) {
                        // Restore saved analysis state
                        console.log('âœ“ All analysis data found, restoring without recalculation...');
                        analysisResults = JSON.parse(savedAnalysisResults);

                        // Parse similarity pairs and check if they're in reduced format
                        const parsedPairs = JSON.parse(savedSimilarityPairs);

                        // Check if data is in reduced format (has 'i1', 'i2', 's' instead of full format)
                        if (parsedPairs.length > 0 && parsedPairs[0].i1 !== undefined) {
                            console.log('ðŸ“¦ Restoring from reduced format...');
                            // Reconstruct full format by looking up text from responses
                            responses = JSON.parse(savedResponses);
                            const responseMap = {};
                            responses.forEach(r => {
                                responseMap[r.id] = r.text;
                            });

                            allSimilarityPairs = parsedPairs.map(p => ({
                                id1: p.i1,
                                id2: p.i2,
                                similarity: p.s,
                                text1: responseMap[p.i1] || '',
                                text2: responseMap[p.i2] || ''
                            }));
                            console.log('âœ“ Reconstructed', allSimilarityPairs.length, 'similarity pairs from reduced format');
                        } else {
                            // Full format
                            allSimilarityPairs = parsedPairs;
                            responses = JSON.parse(savedResponses);
                            console.log('âœ“ Restored', allSimilarityPairs.length, 'similarity pairs');
                        }

                        console.log('âœ“ Restored', responses.length, 'responses');

                        // Update display with restored data
                        updateThreshold(savedThreshold || '0.40');

                        showNotification('Session restored instantly! Your previous analysis has been loaded.');
                    } else {
                        // No saved analysis, recalculate
                        console.warn('âš  Incomplete analysis data, will recalculate corpus...');
                        analyzeCorpus();
                        showNotification('Session restored! Recalculating analysis...');
                    }

                    // Restore panel mode state
                    const savedPanelMode = localStorage.getItem('homogeneityAnalyzer_panelMode');
                    if (savedPanelMode === 'pattern') {
                        const toggle = document.getElementById('panelModeToggle');
                        if (toggle && !toggle.checked) {
                            toggle.checked = true;
                            togglePanelMode();
                        }

                        // Restore pattern search terms
                        const savedPatternTerms = localStorage.getItem('homogeneityAnalyzer_patternSearchTerms');
                        if (savedPatternTerms) {
                            currentPatternSearchTerms = JSON.parse(savedPatternTerms);
                            // Re-run the pattern search if we have saved terms
                            const specificTermsInput = document.getElementById('specificTermsInput');
                            if (specificTermsInput && currentPatternSearchTerms.length > 0) {
                                specificTermsInput.value = currentPatternSearchTerms.join(', ');
                                // Trigger the search after a short delay to ensure DOM is ready
                                setTimeout(() => {
                                    searchSpecificTerms();
                                }, 500);
                            }
                        }
                    }

                    // Clear the restoration flag after a short delay to ensure all async operations complete
                    setTimeout(() => {
                        isRestoringSession = false;
                        console.log('âœ“ Session restoration complete, saves re-enabled');
                    }, 1000);

                    return true;
                }
            } catch (e) {
                console.error('Failed to restore session:', e);
                isRestoringSession = false;  // Clear flag even on error
            }
            isRestoringSession = false;  // Clear flag if no saved data
            return false;
        }

        function clearSession() {
            if (confirm('Clear saved session data? This will reload the page.')) {
                localStorage.removeItem('homogeneityAnalyzer_csvData');
                localStorage.removeItem('homogeneityAnalyzer_headers');
                localStorage.removeItem('homogeneityAnalyzer_currentColumn');
                localStorage.removeItem('homogeneityAnalyzer_threshold');
                localStorage.removeItem('homogeneityAnalyzer_analysisResults');
                localStorage.removeItem('homogeneityAnalyzer_similarityPairs');
                localStorage.removeItem('homogeneityAnalyzer_responses');
                localStorage.removeItem('homogeneityAnalyzer_panelMode');
                localStorage.removeItem('homogeneityAnalyzer_patternSearchTerms');
                location.reload();
            }
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #27ae60;
                color: white;
                padding: 15px 25px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Try to restore session on page load
        window.addEventListener('DOMContentLoaded', () => {
            restoreSession();
            restoreMetricSettings();

            // Event Listeners
            document.getElementById('csvFile').addEventListener('change', handleFileUpload);
            document.getElementById('columnSelect').addEventListener('change', async (e) => {
                currentColumn = parseInt(e.target.value);
                await analyzeCorpus();
                saveSession();
            });
        });

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                parseCSV(event.target.result);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const rows = parseCSVText(text);
            if (rows.length === 0) return;

            headers = rows[0];
            csvData = [];

            for (let i = 1; i < rows.length; i++) {
                if (rows[i].length >= headers.length) {
                    csvData.push(rows[i]);
                }
            }

            // Populate column selector
            const select = document.getElementById('columnSelect');
            select.innerHTML = '';
            headers.forEach((header, i) => {
                if (i > 0 && header.trim()) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = header.length > 80 ? header.substring(0, 80) + '...' : header;
                    select.appendChild(option);
                }
            });

            currentColumn = 1;

            // Hide welcome screen and show app interface
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('dashboard').style.display = 'block';

            analyzeCorpus();
            saveSession();
        }

        function parseCSVText(text) {
            const rows = [];
            let currentRow = [];
            let currentField = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (inQuotes) {
                    if (char === '"' && nextChar === '"') {
                        currentField += '"';
                        i++;
                    } else if (char === '"') {
                        inQuotes = false;
                    } else {
                        currentField += char;
                    }
                } else {
                    if (char === '"') {
                        inQuotes = true;
                    } else if (char === ',') {
                        currentRow.push(currentField.trim());
                        currentField = '';
                    } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
                        if (char === '\r') i++;
                        currentRow.push(currentField.trim());
                        if (currentRow.some(field => field !== '')) {
                            rows.push(currentRow);
                        }
                        currentRow = [];
                        currentField = '';
                    } else if (char !== '\r') {
                        currentField += char;
                    }
                }
            }

            currentRow.push(currentField.trim());
            if (currentRow.some(field => field !== '')) {
                rows.push(currentRow);
            }

            return rows;
        }

        async function analyzeCorpus() {
            // Update global responses array
            responses = csvData.map(row => ({
                id: row[0],
                text: row[currentColumn] || ''
            })).filter(r => r.text.trim());

            if (responses.length === 0) return;

            console.log('ðŸ”„ Starting corpus analysis...');

            // Calculate similarity pairs FIRST with progress tracking
            await calculateSimilarityPairs(responses);
            console.log('âœ“ Similarity pairs calculation complete, count:', allSimilarityPairs.length);

            // Calculate all other metrics (using already-calculated similarity data)
            const diversity = calculateLexicalDiversity(responses);
            const phrases = analyzePhrases(responses);
            const similarity = analyzeSimilarity(responses);

            // Corpus-level temporal burstiness analysis (Cui et al. 2017)
            // Runs AFTER similarity to avoid interference
            let burstiness = null;
            try {
                burstiness = analyzeBurstiness(responses);
                console.log('Burstiness analysis completed:', burstiness.stats);
            } catch (error) {
                console.error('Burstiness analysis failed:', error);
                burstiness = null;
            }

            // Store results
            analysisResults = {
                diversity,
                phrases,
                similarity,
                burstiness,
                responses  // Keep for backwards compatibility
            };

            // Update display (this also calls saveSession via updateThreshold)
            updateThreshold(document.getElementById('similarityThreshold').value);

            // Note: saveSession is already called by updateThreshold above, no need to call again
            console.log('ðŸ“Š Analysis complete');
        }

        function calculateLexicalDiversity(responses) {
            const allWords = [];
            const wordFreq = {};
            const uniqueWordsPerResponse = [];

            responses.forEach(r => {
                const words = tokenize(r.text);
                allWords.push(...words);

                // Unique words in this response
                const uniqueInResponse = new Set(words);
                uniqueWordsPerResponse.push(uniqueInResponse.size);

                // Word frequency
                words.forEach(w => {
                    wordFreq[w] = (wordFreq[w] || 0) + 1;
                });
            });

            const totalWords = allWords.length;
            const uniqueWords = Object.keys(wordFreq).length;
            const ttr = uniqueWords / totalWords;

            // Hapax legomena (words appearing only once)
            const hapaxCount = Object.values(wordFreq).filter(count => count === 1).length;
            const hapaxRate = hapaxCount / uniqueWords;

            // Average unique words per response
            const avgUniqueWords = uniqueWordsPerResponse.reduce((a, b) => a + b, 0) / responses.length;

            return {
                totalWords,
                uniqueWords,
                ttr,
                hapaxCount,
                hapaxRate,
                avgUniqueWords
            };
        }

        function tokenize(text) {
            return text.toLowerCase()
                .replace(/[\u2018\u2019\u201C\u201D]/g, "'")  // Normalize smart quotes to straight quotes
                .replace(/[^\w\s']/g, ' ')  // Keep apostrophes for contractions
                .split(/\s+/)
                .filter(w => w.length > 0);  // Changed from > 2 to > 0 to allow pronouns like "i", "me", "we"
        }

        function analyzePhrases(responses) {
            const phraseCounts = {};
            const n = responses.length;

            // Extract n-grams from 2 to 8 words
            responses.forEach(r => {
                const words = r.text.toLowerCase().split(/\s+/).filter(w => w.length > 0);

                for (let ngramSize = 2; ngramSize <= Math.min(8, words.length); ngramSize++) {
                    for (let i = 0; i <= words.length - ngramSize; i++) {
                        const phrase = words.slice(i, i + ngramSize).join(' ');
                        if (!phraseCounts[phrase]) {
                            phraseCounts[phrase] = { count: 0, ids: new Set() };
                        }
                        phraseCounts[phrase].count++;
                        phraseCounts[phrase].ids.add(r.id);
                    }
                }
            });

            // Calculate statistics
            const allPhrases = Object.entries(phraseCounts).map(([phrase, data]) => ({
                text: phrase,
                count: data.ids.size, // Number of distinct responses containing it
                percentage: (data.ids.size / n) * 100,
                ids: Array.from(data.ids)
            }));

            // Filter to phrases appearing in multiple responses
            const repeatedPhrases = allPhrases.filter(p => p.count >= 2);

            // Sort by occurrence rate
            repeatedPhrases.sort((a, b) => b.count - a.count);

            // High frequency (>20% of responses)
            const highFreq = repeatedPhrases.filter(p => p.percentage > 20);

            // Calculate expected rate and find outliers
            // Simple model: expected rate decreases with phrase length
            const outliers = repeatedPhrases.filter(p => {
                const wordCount = p.text.split(' ').length;
                const expectedRate = Math.max(5, 30 / wordCount); // Rough heuristic
                return p.percentage > expectedRate * 2; // 2x expected = outlier
            });

            const maxPhraseRate = repeatedPhrases.length > 0 ? repeatedPhrases[0].percentage : 0;

            return {
                topPhrases: repeatedPhrases.slice(0, 50),
                highFreq,
                outliers,
                maxPhraseRate
            };
        }

        function analyzeSimilarity(responses) {
            // Use already-calculated similarity pairs instead of recalculating
            const similarities = allSimilarityPairs.map(pair => pair.similarity);

            if (similarities.length === 0) {
                return {
                    mean: 0,
                    stdDev: 0,
                    highSimilarity: 0,
                    highSimilarityPct: 0,
                    histogram: new Array(20).fill(0),
                    total: 0
                };
            }

            const mean = similarities.reduce((a, b) => a + b, 0) / similarities.length;
            const variance = similarities.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / similarities.length;
            const stdDev = Math.sqrt(variance);

            const highSimilarity = similarities.filter(s => s > 0.70).length;
            const highSimilarityPct = (highSimilarity / similarities.length) * 100;

            // Create histogram data
            const bins = 20;
            const histogram = new Array(bins).fill(0);
            similarities.forEach(sim => {
                const binIndex = Math.min(Math.floor(sim * bins), bins - 1);
                histogram[binIndex]++;
            });

            return {
                mean,
                stdDev,
                highSimilarity,
                highSimilarityPct,
                histogram,
                total: similarities.length
            };
        }

        // ========== NEW SIMILARITY METRICS ==========

        function sentenceLengthVariance(text) {
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            if (sentences.length === 0) return 0;
            const lengths = sentences.map(s => s.trim().split(/\s+/).length);
            const mean = lengths.reduce((a,b) => a+b, 0) / lengths.length;
            const variance = lengths.reduce((sum, len) => sum + Math.pow(len - mean, 2), 0) / lengths.length;
            return variance;
        }

        function sentenceVarianceSimilarity(text1, text2) {
            const var1 = sentenceLengthVariance(text1);
            const var2 = sentenceLengthVariance(text2);
            if (var1 === 0 && var2 === 0) return 1;
            return 1 - Math.abs(var1 - var2) / Math.max(var1, var2, 1);
        }

        function wordCountSimilarity(text1, text2) {
            const count1 = text1.trim().split(/\s+/).length;
            const count2 = text2.trim().split(/\s+/).length;
            if (count1 === 0 && count2 === 0) return 1;
            return 1 - Math.abs(count1 - count2) / Math.max(count1, count2);
        }

        function avgSentenceLengthSimilarity(text1, text2) {
            const sentences1 = text1.split(/[.!?]+/).filter(s => s.trim().length > 0);
            const sentences2 = text2.split(/[.!?]+/).filter(s => s.trim().length > 0);

            const avg1 = sentences1.reduce((sum, s) => sum + s.trim().split(/\s+/).length, 0) / sentences1.length;
            const avg2 = sentences2.reduce((sum, s) => sum + s.trim().split(/\s+/).length, 0) / sentences2.length;

            if (!avg1 || !avg2) return 0;
            return 1 - Math.abs(avg1 - avg2) / Math.max(avg1, avg2);
        }

        // OLD BURSTINESS FUNCTIONS REMOVED
        // Replaced with corpus-level temporal burstiness analysis from Cui et al. 2017

        function pronounDensitySimilarity(text1, text2) {
            const pronouns = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
                            'you', 'your', 'yours', 'yourself', 'yourselves',
                            'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
                            'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
                            'i\'m', 'i\'ve', 'i\'d', 'i\'ll', 'you\'re', 'you\'ve', 'you\'d', 'you\'ll',
                            'he\'s', 'he\'d', 'he\'ll', 'she\'s', 'she\'d', 'she\'ll', 'it\'s', 'it\'d', 'it\'ll',
                            'we\'re', 'we\'ve', 'we\'d', 'we\'ll', 'they\'re', 'they\'ve', 'they\'d', 'they\'ll'];

            const words1 = tokenize(text1);
            const words2 = tokenize(text2);

            const count1 = words1.filter(w => pronouns.includes(w.toLowerCase())).length;
            const count2 = words2.filter(w => pronouns.includes(w.toLowerCase())).length;

            const density1 = words1.length > 0 ? count1 / words1.length : 0;
            const density2 = words2.length > 0 ? count2 / words2.length : 0;

            if (density1 === 0 && density2 === 0) return 1;
            const maxDensity = Math.max(density1, density2);
            if (maxDensity === 0) return 1;
            return 1 - Math.abs(density1 - density2) / maxDensity;
        }

        function transitionWordsSimilarity(text1, text2) {
            const transitions = [
                // Addition
                'furthermore', 'moreover', 'additionally', 'also', 'besides', 'in addition', 'as well as',
                // Example/Clarification
                'for example', 'for instance', 'specifically', 'to illustrate', 'namely', 'in other words',
                'that is', 'in particular', 'such as',
                // Contrast/Opposition
                'however', 'nevertheless', 'nonetheless', 'conversely', 'on the other hand', 'in contrast',
                'yet', 'still', 'although', 'even though', 'despite', 'regardless', 'alternatively',
                // Cause/Effect
                'therefore', 'thus', 'consequently', 'as a result', 'accordingly', 'hence', 'for this reason',
                'because of this', 'due to', 'since',
                // Time/Sequence
                'meanwhile', 'subsequently', 'finally', 'firstly', 'secondly', 'thirdly', 'then', 'next',
                'afterward', 'previously', 'eventually', 'ultimately', 'later', 'initially', 'formerly',
                // Conclusion/Summary
                'in conclusion', 'to sum up', 'in summary', 'overall', 'all in all', 'in brief',
                'to conclude', 'in the end',
                // Emphasis
                'indeed', 'in fact', 'certainly', 'undoubtedly', 'notably', 'especially', 'particularly',
                'importantly', 'significantly',
                // Comparison
                'similarly', 'likewise', 'in the same way', 'equally', 'by comparison'
            ];

            const count1 = transitions.reduce((sum, word) =>
                sum + (text1.toLowerCase().match(new RegExp('\\b' + word + '\\b', 'g')) || []).length, 0
            );
            const count2 = transitions.reduce((sum, word) =>
                sum + (text2.toLowerCase().match(new RegExp('\\b' + word + '\\b', 'g')) || []).length, 0
            );

            const words1 = text1.trim().split(/\s+/).length;
            const words2 = text2.trim().split(/\s+/).length;

            const density1 = (count1 / words1) * 100;
            const density2 = (count2 / words2) * 100;

            if (density1 === 0 && density2 === 0) return 1;
            return 1 - Math.abs(density1 - density2) / Math.max(density1, density2, 1);
        }

        function temporalBurstinessSimilarity(text1, text2) {
            // Pairwise temporal burstiness comparison using word positions
            const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i',
                                       'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
                                       'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she',
                                       'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their']);

            // Track word positions for each text
            const getWordPositions = (text) => {
                const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
                const positions = {};
                words.forEach((word, idx) => {
                    if (!stopWords.has(word) && word.length > 3) {
                        if (!positions[word]) positions[word] = [];
                        positions[word].push(idx);
                    }
                });
                return { positions, totalWords: words.length };
            };

            const data1 = getWordPositions(text1);
            const data2 = getWordPositions(text2);

            // Find common significant words (appear at least 2 times in each)
            const commonWords = Object.keys(data1.positions).filter(word =>
                data2.positions[word] &&
                data1.positions[word].length >= 2 &&
                data2.positions[word].length >= 2
            );

            if (commonWords.length === 0) return 0; // No shared repeated words = no similarity

            // Calculate burstiness for common words in each text
            const burstinessScores = commonWords.map(word => {
                const burst1 = calculateTemporalBurstiness(data1.positions[word], data1.totalWords);
                const burst2 = calculateTemporalBurstiness(data2.positions[word], data2.totalWords);

                // Similarity is 1 minus the absolute difference
                return 1 - Math.abs(burst1 - burst2);
            });

            // Return average similarity across all common words
            return burstinessScores.reduce((a, b) => a + b, 0) / burstinessScores.length;
        }

        // Calculate all individual metric scores for a pair of texts
        function calculateAllMetrics(text1, text2, selectedMetrics) {
            const metrics = {};

            selectedMetrics.forEach(metricId => {
                switch(metricId) {
                    case 'cosine':
                        metrics.cosine = cosineSimilarity(text1, text2);
                        break;
                    case 'jaccard':
                        metrics.jaccard = jaccardSimilarity(text1, text2);
                        break;
                    case 'ngram':
                        metrics.ngram = ngramSimilarity(text1, text2, 3);
                        break;
                    case 'sentenceVariance':
                        metrics.sentenceVariance = sentenceVarianceSimilarity(text1, text2);
                        break;
                    case 'wordCount':
                        metrics.wordCount = wordCountSimilarity(text1, text2);
                        break;
                    case 'avgSentenceLength':
                        metrics.avgSentenceLength = avgSentenceLengthSimilarity(text1, text2);
                        break;
                    case 'temporalBurstiness':
                        metrics.temporalBurstiness = temporalBurstinessSimilarity(text1, text2);
                        break;
                    case 'pronounDensity':
                        metrics.pronounDensity = pronounDensitySimilarity(text1, text2);
                        break;
                    case 'transitionWords':
                        metrics.transitionWords = transitionWordsSimilarity(text1, text2);
                        break;
                    case 'ngramPunctuation':
                        metrics.ngramPunctuation = ngramWithPunctuationSimilarity(text1, text2, 3);
                        break;
                    case 'wordNgram':
                        metrics.wordNgram = wordNgramSimilarity(text1, text2, 3);
                        break;
                    case 'ngram4':
                        metrics.ngram4 = ngram4Similarity(text1, text2);
                        break;
                    case 'ngram5':
                        metrics.ngram5 = ngram5Similarity(text1, text2);
                        break;
                    case 'ner':
                        metrics.ner = nerSimilarity(text1, text2);
                        break;
                    case 'fuzzyNgram3':
                        metrics.fuzzyNgram3 = fuzzyNgramSimilarity(text1, text2, 3, 5);
                        break;
                    case 'fuzzyNgram6':
                        metrics.fuzzyNgram6 = fuzzyNgramSimilarity(text1, text2, 6, 13);
                        break;
                    case 'wordLevelFuzzy3':
                        metrics.wordLevelFuzzy3 = wordLevelFuzzyNgramSimilarity(text1, text2, 3, 1);
                        break;
                    case 'wordLevelFuzzy5':
                        metrics.wordLevelFuzzy5 = wordLevelFuzzyNgramSimilarity(text1, text2, 5, 2);
                        break;
                }
            });

            return metrics;
        }

        // Normalize a metric score using min-max normalization
        function normalizeMetric(score, metricId) {
            const params = metricNormalizationParams[metricId];
            if (!params || params.max === params.min) {
                return score; // No normalization if params don't exist or range is zero
            }
            return (score - params.min) / (params.max - params.min);
        }

        function calculateCombinedSimilarity(text1, text2) {
            // Get selected metrics from settings
            const selected = getSelectedMetrics();

            // Calculate all individual metric scores
            const metrics = calculateAllMetrics(text1, text2, selected);

            // Get metric weights
            const weights = getMetricWeights();

            // Calculate weighted average of NORMALIZED metrics
            let weightedSum = 0;
            let totalWeight = 0;

            selected.forEach(metric => {
                if (metrics[metric] !== undefined) {
                    const weight = weights[metric] || 1.0;
                    const normalizedScore = normalizeMetric(metrics[metric], metric);
                    weightedSum += normalizedScore * weight;
                    totalWeight += weight;
                }
            });

            return totalWeight > 0 ? weightedSum / totalWeight : 0;
        }

        function getSelectedMetrics() {
            const metricIds = ['cosine', 'jaccard', 'ngram', 'sentenceVariance', 'wordCount',
                              'avgSentenceLength', 'temporalBurstiness', 'pronounDensity', 'transitionWords',
                              'ngramPunctuation', 'wordNgram', 'ngram4', 'ngram5', 'ner', 'fuzzyNgram3', 'fuzzyNgram6',
                              'wordLevelFuzzy3', 'wordLevelFuzzy5'];
            return metricIds.filter(id => {
                const checkbox = document.getElementById('metric_' + id);
                return checkbox && checkbox.checked;
            });
        }

        function toggleMetricSettings() {
            const modal = document.getElementById('metricSettings');
            if (modal.style.display === 'none' || modal.style.display === '') {
                modal.style.display = 'flex';
            } else {
                modal.style.display = 'none';
            }
        }

        function toggleMethodologyModal() {
            const modal = document.getElementById('methodologyModal');
            if (modal.style.display === 'none' || modal.style.display === '') {
                modal.style.display = 'flex';
            } else {
                modal.style.display = 'none';
            }
        }

        function updateWeightDisplay(metricId, value) {
            const display = document.getElementById(`weightDisplay_${metricId}`);
            if (display) {
                display.textContent = parseFloat(value).toFixed(1);
            }
        }

        function toggleMetricWeight(metricId) {
            const checkbox = document.getElementById(`metric_${metricId}`);
            const weightSlider = document.getElementById(`weight_${metricId}`);
            const weightDisplay = document.getElementById(`weightDisplay_${metricId}`);

            if (weightSlider) {
                weightSlider.disabled = !checkbox.checked;
            }
            if (weightDisplay) {
                weightDisplay.style.opacity = checkbox.checked ? '1' : '0.4';
            }
        }

        function getMetricWeights() {
            const weights = {};
            const metricIds = ['cosine', 'jaccard', 'ngram', 'sentenceVariance', 'wordCount', 'avgSentenceLength',
                              'temporalBurstiness', 'pronounDensity', 'transitionWords', 'ngramPunctuation', 'wordNgram',
                              'ngram4', 'ngram5', 'ner', 'fuzzyNgram3', 'fuzzyNgram6', 'wordLevelFuzzy3', 'wordLevelFuzzy5'];

            metricIds.forEach(id => {
                const slider = document.getElementById(`weight_${id}`);
                if (slider) {
                    weights[id] = parseFloat(slider.value);
                }
            });

            return weights;
        }

        async function saveMetricSettings() {
            const selected = getSelectedMetrics();
            const weights = getMetricWeights();

            localStorage.setItem('homogeneityAnalyzer_selectedMetrics', JSON.stringify(selected));
            localStorage.setItem('homogeneityAnalyzer_metricWeights', JSON.stringify(weights));

            // Close the modal
            toggleMetricSettings();

            // Recalculate similarity pairs with new metric selection and weights
            if (responses.length > 0) {
                await calculateSimilarityPairs(responses);
                // Re-apply the current threshold to update the display
                const currentThreshold = document.getElementById('similarityThreshold')?.value || '0.4';
                updateThreshold(currentThreshold);
            }
        }

        function restoreMetricSettings() {
            // Restore selected metrics
            const saved = localStorage.getItem('homogeneityAnalyzer_selectedMetrics');
            if (saved) {
                const selected = JSON.parse(saved);
                const metricIds = ['cosine', 'jaccard', 'ngram', 'sentenceVariance', 'wordCount',
                                  'avgSentenceLength', 'temporalBurstiness', 'pronounDensity', 'transitionWords',
                                  'ngramPunctuation', 'wordNgram', 'ngram4', 'ngram5', 'ner', 'fuzzyNgram3', 'fuzzyNgram6',
                                  'wordLevelFuzzy3', 'wordLevelFuzzy5'];
                metricIds.forEach(id => {
                    const checkbox = document.getElementById('metric_' + id);
                    if (checkbox) {
                        checkbox.checked = selected.includes(id);
                    }
                });
            }

            // Restore metric weights
            const savedWeights = localStorage.getItem('homogeneityAnalyzer_metricWeights');
            if (savedWeights) {
                const weights = JSON.parse(savedWeights);
                Object.keys(weights).forEach(id => {
                    const slider = document.getElementById(`weight_${id}`);
                    const display = document.getElementById(`weightDisplay_${id}`);
                    if (slider) {
                        slider.value = weights[id];
                        if (display) {
                            display.textContent = parseFloat(weights[id]).toFixed(1);
                        }
                    }
                });
            }
        }

        function generateMetricBadges(text1, text2, combinedScore, id1, id2) {
            // Get selected metrics to only calculate what's needed
            const selectedIds = getSelectedMetrics();

            // Only calculate the selected metrics
            const metricValues = {};
            selectedIds.forEach(metricId => {
                switch(metricId) {
                    case 'cosine':
                        metricValues['Cosine'] = cosineSimilarity(text1, text2);
                        break;
                    case 'jaccard':
                        metricValues['Jaccard'] = jaccardSimilarity(text1, text2);
                        break;
                    case 'ngram':
                        metricValues['N-gram'] = ngramSimilarity(text1, text2, 3);
                        break;
                    case 'sentenceVariance':
                        metricValues['Sentence Variance'] = sentenceVarianceSimilarity(text1, text2);
                        break;
                    case 'wordCount':
                        metricValues['Word Count'] = wordCountSimilarity(text1, text2);
                        break;
                    case 'avgSentenceLength':
                        metricValues['Avg Sentence Length'] = avgSentenceLengthSimilarity(text1, text2);
                        break;
                    case 'temporalBurstiness':
                        metricValues['Temporal Burstiness'] = temporalBurstinessSimilarity(text1, text2);
                        break;
                    case 'pronounDensity':
                        metricValues['Pronoun Density'] = pronounDensitySimilarity(text1, text2);
                        break;
                    case 'transitionWords':
                        metricValues['Transition Words'] = transitionWordsSimilarity(text1, text2);
                        break;
                    case 'ngramPunctuation':
                        metricValues['N-gram with Punctuation'] = ngramWithPunctuationSimilarity(text1, text2, 3);
                        break;
                    case 'wordNgram':
                        metricValues['3-Word Phrases'] = wordNgramSimilarity(text1, text2, 3);
                        break;
                    case 'ngram4':
                        metricValues['N-gram 4-char'] = ngram4Similarity(text1, text2);
                        break;
                    case 'ngram5':
                        metricValues['N-gram 5-char'] = ngram5Similarity(text1, text2);
                        break;
                    case 'ner':
                        metricValues['Named Entity Recognition'] = nerSimilarity(text1, text2);
                        break;
                    case 'fuzzyNgram3':
                        metricValues['Fuzzy 3-Word Phrases'] = fuzzyNgramSimilarity(text1, text2, 3, 5);
                        break;
                    case 'fuzzyNgram6':
                        metricValues['Fuzzy 6-Word Phrases'] = fuzzyNgramSimilarity(text1, text2, 6, 13);
                        break;
                    case 'wordLevelFuzzy3':
                        metricValues['Word-Level 3-Word'] = wordLevelFuzzyNgramSimilarity(text1, text2, 3, 1);
                        break;
                    case 'wordLevelFuzzy5':
                        metricValues['Word-Level 5-Word'] = wordLevelFuzzyNgramSimilarity(text1, text2, 5, 2);
                        break;
                }
            });

            // Map metric IDs to display names
            const metricIdToName = {
                'cosine': 'Cosine',
                'jaccard': 'Jaccard',
                'ngram': 'N-gram',
                'sentenceVariance': 'Sentence Variance',
                'wordCount': 'Word Count',
                'avgSentenceLength': 'Avg Sentence Length',
                'temporalBurstiness': 'Temporal Burstiness',
                'pronounDensity': 'Pronoun Density',
                'transitionWords': 'Transition Words',
                'ngramPunctuation': 'N-gram with Punctuation',
                'wordNgram': '3-Word Phrases',
                'ngram4': 'N-gram 4-char',
                'ngram5': 'N-gram 5-char',
                'ner': 'Named Entity Recognition',
                'fuzzyNgram3': 'Fuzzy 3-Word Phrases',
                'fuzzyNgram6': 'Fuzzy 6-Word Phrases',
                'wordLevelFuzzy3': 'Word-Level 3-Word',
                'wordLevelFuzzy5': 'Word-Level 5-Word'
            };

            const metricTooltips = {
                'Cosine': 'Word frequency similarity (click to see calculation)',
                'Jaccard': 'Vocabulary overlap (click to see details)',
                'N-gram': 'Character sequence similarity (click to see shared n-grams)',
                'Sentence Variance': 'Sentence length variation patterns (click for details)',
                'Word Count': 'Total word count similarity (click for breakdown)',
                'Avg Sentence Length': 'Average sentence length (click for details)',
                'Temporal Burstiness': 'Word temporal clustering patterns (click to see word-by-word analysis)',
                'Pronoun Density': 'Pronoun usage frequency (click for breakdown)',
                'Transition Words': 'Transition word usage (click to see which words)',
                'N-gram with Punctuation': '3-char sequences with punctuation (click to see patterns)',
                '3-Word Phrases': 'Word-level n-grams (click to see shared phrases)',
                'N-gram 4-char': '4-character sequences (click to see patterns)',
                'N-gram 5-char': '5-character sequences (click to see patterns)',
                'Named Entity Recognition': 'Named entity similarity (people, places, organizations) - click for breakdown',
                'Fuzzy 3-Word Phrases': 'Levenshtein â‰¤5 edits on 3-word phrases - catches short paraphrasing (click for details)',
                'Fuzzy 6-Word Phrases': 'Levenshtein â‰¤13 edits on 6-word phrases - detects longer paraphrasing (click for details)',
                'Word-Level 3-Word': 'Word substitutions â‰¤1 - detects single word changes (click for details)',
                'Word-Level 5-Word': 'Word substitutions â‰¤2 - detects multi-word paraphrasing (click for details)'
            };

            const selectedNames = selectedIds.map(id => metricIdToName[id]).filter(n => n);

            // Always show Combined first, then only selected metrics
            const metrics = [
                {
                    name: 'Combined',
                    value: combinedScore,
                    tooltip: 'Average of selected metrics (click to see breakdown)'
                },
                ...selectedNames.map(name => ({
                    name: name,
                    value: metricValues[name],
                    tooltip: metricTooltips[name]
                }))
            ];

            // We need to store texts globally for the click handlers to access
            window.currentComparisonTexts = { text1, text2, id1, id2 };

            return metrics.map(m => `
                <div class="stat-badge" onclick='showMetricDetails("${m.name}", window.currentComparisonTexts.text1, window.currentComparisonTexts.text2, "${id1}", "${id2}")'
                     style="cursor: pointer; transition: transform 0.2s;"
                     onmouseover="this.style.transform='scale(1.05)'"
                     onmouseout="this.style.transform='scale(1)'">
                    ${m.name}: <strong>${(m.value * 100).toFixed(1)}%</strong>
                    <span class="info-icon">?
                        <span class="tooltip">${m.tooltip}</span>
                    </span>
                </div>
            `).join('');
        }

        function showMetricDetails(metricName, text1, text2, id1, id2) {
            const modal = document.getElementById('calculationModal');
            const title = document.getElementById('calculationTitle');
            const body = document.getElementById('calculationBody');

            title.textContent = `${metricName} - Calculation Details`;

            let detailsHTML = '';

            switch(metricName) {
                case 'Cosine':
                    detailsHTML = generateCosineDetails(text1, text2, id1, id2);
                    break;
                case 'Jaccard':
                    detailsHTML = generateJaccardDetails(text1, text2, id1, id2);
                    break;
                case 'N-gram':
                    detailsHTML = generateNgramDetails(text1, text2, id1, id2);
                    break;
                case 'Sentence Variance':
                    detailsHTML = generateSentenceVarianceDetails(text1, text2, id1, id2);
                    break;
                case 'Word Count':
                    detailsHTML = generateWordCountDetails(text1, text2, id1, id2);
                    break;
                case 'Avg Sentence Length':
                    detailsHTML = generateAvgSentenceLengthDetails(text1, text2, id1, id2);
                    break;
                case 'Temporal Burstiness':
                    detailsHTML = generateBurstinessDetails(text1, text2, id1, id2);
                    break;
                case 'Pronoun Density':
                    detailsHTML = generatePronounDensityDetails(text1, text2, id1, id2);
                    break;
                case 'Transition Words':
                    detailsHTML = generateTransitionWordsDetails(text1, text2, id1, id2);
                    break;
                case 'N-gram with Punctuation':
                    detailsHTML = generateNgramPunctuationDetails(text1, text2, id1, id2);
                    break;
                case '3-Word Phrases':
                    detailsHTML = generateWordNgramDetails(text1, text2, id1, id2);
                    break;
                case 'N-gram 4-char':
                    detailsHTML = generateNgram4Details(text1, text2, id1, id2);
                    break;
                case 'N-gram 5-char':
                    detailsHTML = generateNgram5Details(text1, text2, id1, id2);
                    break;
                case 'Named Entity Recognition':
                    detailsHTML = generateNERDetails(text1, text2, id1, id2);
                    break;
                case 'Fuzzy 3-Word Phrases':
                    detailsHTML = generateFuzzyNgram3Details(text1, text2, id1, id2);
                    break;
                case 'Fuzzy 6-Word Phrases':
                    detailsHTML = generateFuzzyNgram6Details(text1, text2, id1, id2);
                    break;
                case 'Word-Level 3-Word':
                    detailsHTML = generateWordLevelFuzzy3Details(text1, text2, id1, id2);
                    break;
                case 'Word-Level 5-Word':
                    detailsHTML = generateWordLevelFuzzy5Details(text1, text2, id1, id2);
                    break;
                case 'Combined':
                    detailsHTML = generateCombinedDetails(text1, text2, id1, id2);
                    break;
            }

            body.innerHTML = detailsHTML + `
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="closeCalculationModal()"
                        style="padding: 10px 30px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                        Close
                    </button>
                </div>
            `;

            modal.style.display = 'block';
        }

        function generateCosineDetails(text1, text2, id1, id2) {
            const words1 = tokenize(text1);
            const words2 = tokenize(text2);
            const freq1 = {};
            const freq2 = {};
            const allWords = new Set([...words1, ...words2]);

            words1.forEach(w => freq1[w] = (freq1[w] || 0) + 1);
            words2.forEach(w => freq2[w] = (freq2[w] || 0) + 1);

            let dotProduct = 0, mag1 = 0, mag2 = 0;
            const wordDetails = [];
            allWords.forEach(word => {
                const v1 = freq1[word] || 0;
                const v2 = freq2[word] || 0;
                if (v1 > 0 || v2 > 0) {
                    wordDetails.push({ word, v1, v2, product: v1 * v2 });
                }
                dotProduct += v1 * v2;
                mag1 += v1 * v1;
                mag2 += v2 * v2;
            });

            const similarity = (mag1 === 0 || mag2 === 0) ? 0 : dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));

            wordDetails.sort((a, b) => b.product - a.product);
            const topWords = wordDetails.slice(0, 20);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Cosine Similarity Formula</h3>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px;">
                        similarity = (A Â· B) / (||A|| Ã— ||B||)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Dot Product (A Â· B)</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${dotProduct.toFixed(2)}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Magnitude ||A||</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${Math.sqrt(mag1).toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">âˆš${mag1.toFixed(2)}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Magnitude ||B||</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${Math.sqrt(mag2).toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">âˆš${mag2.toFixed(2)}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${dotProduct.toFixed(2)} / (${Math.sqrt(mag1).toFixed(2)} Ã— ${Math.sqrt(mag2).toFixed(2)}) =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Top Contributing Words (by dot product contribution)</h4>
                <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 13px;">
                    <strong>Note:</strong> The cosine similarity calculation above uses <strong>every single word</strong> from both texts (${allWords.size} unique words total).
                    This table shows only the <strong>top 20 words</strong> that contributed most to the dot product, ranked by their contribution (frequency in text A Ã— frequency in text B).
                </div>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #57068C; color: white;">
                            <th style="padding: 10px; text-align: left;">Word</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id1}</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id2}</th>
                            <th style="padding: 10px; text-align: center;">Product</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${topWords.map((w, i) => `
                            <tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'};">
                                <td style="padding: 8px; font-weight: 600;">${escapeHtml(w.word)}</td>
                                <td style="padding: 8px; text-align: center;">${w.v1}</td>
                                <td style="padding: 8px; text-align: center;">${w.v2}</td>
                                <td style="padding: 8px; text-align: center; font-weight: bold;">${w.product}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function generateJaccardDetails(text1, text2, id1, id2) {
            const set1 = new Set(tokenize(text1));
            const set2 = new Set(tokenize(text2));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const only1 = [...set1].filter(x => !set2.has(x));
            const only2 = [...set2].filter(x => !set1.has(x));
            const shared = [...intersection];

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Jaccard Similarity Formula</h3>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px;">
                        similarity = |intersection| / |union| = |A âˆ© B| / |A âˆª B|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Unique Words in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${set1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Unique Words in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${set2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared Words</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                </div>

                <div style="background: #fadbd8; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Total Unique Words (Union)</h4>
                    <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <div>
                        <h4>Only in Respondent ${id1} (${only1.length})</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">
                            ${only1.slice(0, 50).join(', ')}${only1.length > 50 ? '...' : ''}
                        </div>
                    </div>
                    <div>
                        <h4>Shared Words (${shared.length})</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #d5f4e6; padding: 10px; border-radius: 5px; font-size: 12px;">
                            ${shared.slice(0, 50).join(', ')}${shared.length > 50 ? '...' : ''}
                        </div>
                    </div>
                    <div>
                        <h4>Only in Respondent ${id2} (${only2.length})</h4>
                        <div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">
                            ${only2.slice(0, 50).join(', ')}${only2.length > 50 ? '...' : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        function generateNgramDetails(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 3; i++) {
                    ngrams.add(clean.substring(i, i + 3));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram Similarity (3-character sequences)</h3>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px;">
                        similarity = |shared 3-grams| / |total unique 3-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 3-character Sequences (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(ng)}"</span>`).join(' ')}
                </div>
            `;
        }

        function generateNgram4Details(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 4; i++) {
                    ngrams.add(clean.substring(i, i + 4));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram 4-char Similarity (4-character sequences)</h3>
                    <p>Uses <strong>4-character n-grams</strong> instead of 3. Longer n-grams are more specific and less likely to match by chance, making them better at detecting deliberate copying or template use.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 4-grams| / |total unique 4-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">4-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">4-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 4-character Sequences (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(ng)}"</span>`).join(' ')}
                </div>
            `;
        }

        function generateNgram5Details(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 5; i++) {
                    ngrams.add(clean.substring(i, i + 5));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram 5-char Similarity (5-character sequences)</h3>
                    <p>Uses <strong>5-character n-grams</strong> for even more specificity. These longer sequences are highly distinctive and excellent for catching exact phrase matches and template reuse. Random matches are extremely rare at this length.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 5-grams| / |total unique 5-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">5-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">5-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 5-character Sequences (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(ng)}"</span>`).join(' ')}
                </div>
            `;
        }

        function generateNERDetails(text1, text2, id1, id2) {
            // Extract entities from both texts - all capitalized sequences (proper nouns)
            const extractEntities = (text) => {
                const wordCount = tokenize(text).length;

                // Extract sequences of capitalized words (proper nouns)
                // Updated to handle mixed case like "EdTech" or "iPhone"
                // Also handles abbreviations like "Mr. Smith", "Mt. Edna", "Rodeo Dr."
                const properNounPattern = /\b[A-Z][A-Za-z]*\.?(?:\s+[A-Z][A-Za-z]*\.?)*\b/g;

                // Remove punctuation from the text before matching to avoid "EdTech." vs "EdTech" issues
                const cleanText = text.replace(/([.!?;:,])/g, ' $1 ');
                const matches = cleanText.match(properNounPattern) || [];

                // Filter out common sentence-starting words and single letters
                const commonWords = new Set(['The', 'This', 'That', 'These', 'Those', 'A', 'An', 'I', 'It', 'He', 'She', 'We', 'They']);

                // Advanced filtering: Only include words that appear capitalized in mid-sentence positions
                // This prevents sentence-initial capitalization from being treated as named entities
                const sentenceBoundaryPattern = /[.!?]\s+/g;
                const sentences = text.split(sentenceBoundaryPattern);

                const validEntities = new Set();

                // Find words that appear in mid-sentence positions
                sentences.forEach(sentence => {
                    const sentenceMatches = sentence.match(/\b[A-Z][A-Za-z]*\.?(?:\s+[A-Z][A-Za-z]*\.?)*\b/g) || [];

                    // All words after the first are mid-sentence
                    sentenceMatches.slice(1).forEach(match => {
                        if (match.length > 1 && !commonWords.has(match)) {
                            validEntities.add(match);
                        }
                    });
                });

                // Now filter the original matches to only include valid entities
                const entities = matches.filter(m => validEntities.has(m));

                // Deduplicate
                const uniqueEntities = [...new Set(entities)];

                // Calculate density (per 100 words)
                const density = wordCount > 0 ? (uniqueEntities.length / wordCount) * 100 : 0;

                return {
                    entities: new Set(uniqueEntities.map(e => e.toLowerCase())),
                    entityList: uniqueEntities,
                    count: uniqueEntities.length,
                    density: density,
                    wordCount: wordCount
                };
            };

            const entities1 = extractEntities(text1);
            const entities2 = extractEntities(text2);

            // Find shared entities
            const sharedEntities = [...entities1.entities].filter(x => entities2.entities.has(x));

            const similarity = nerSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Named Entity Recognition (NER) Similarity</h3>
                    <p>Extracts all capitalized sequences (proper nouns) from both texts and compares them. Based on MIT 2024 study showing LLM-assisted writing has distinct NER patterns (Cramer's V = 0.55 vs 0.27 for human-only).</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Detection Method:</strong> Extracts all capitalized word sequences (e.g., "John Smith", "New York University", "MIT")
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Similarity Formula:</strong> Combines content similarity (60% weight - shared entities) with density similarity (40% weight - usage rate patterns)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Named Entity Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Metric</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;"><strong>Respondent ${id1}</strong></div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;"><strong>Respondent ${id2}</strong></div>
                        </div>

                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px;">Total Entities</div>
                        <div style="padding: 8px; background: #e8f4f8; border-radius: 3px; text-align: center; font-weight: bold;">${entities1.count}</div>
                        <div style="padding: 8px; background: #fef5e7; border-radius: 3px; text-align: center; font-weight: bold;">${entities2.count}</div>

                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px;">Density (per 100 words)</div>
                        <div style="padding: 8px; background: #e8f4f8; border-radius: 3px; text-align: center; font-weight: bold;">${entities1.density.toFixed(2)}</div>
                        <div style="padding: 8px; background: #fef5e7; border-radius: 3px; text-align: center; font-weight: bold;">${entities2.density.toFixed(2)}</div>

                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px;">Shared Entities</div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center; font-weight: bold; grid-column: 2 / 4;">${sharedEntities.length}</div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                </div>

                ${sharedEntities.length > 0 ? `
                <div style="background: #e8f5e9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0; color: #2e7d32;">âœ“ Shared Named Entities (${sharedEntities.length})</h4>
                    <div style="font-size: 14px; line-height: 1.8;">
                        ${sharedEntities.map(e => `<span style="background: #c8e6c9; padding: 5px 10px; margin: 3px; border-radius: 4px; display: inline-block; font-weight: 500;">${escapeHtml(e)}</span>`).join(' ')}
                    </div>
                </div>
                ` : '<div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; color: #666; font-style: italic; text-align: center;">No shared named entities found</div>'}

                <h4 style="margin: 20px 0 15px 0;">All Named Entities by Respondent</h4>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #e8f4f8; border-radius: 5px; text-align: center;">Respondent ${id1} (${entities1.count} entities)</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            <div style="font-size: 14px; line-height: 1.8;">
                                ${entities1.count > 0
                                    ? entities1.entityList.map(e => `<span style="background: #e3f2fd; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">${escapeHtml(e)}</span>`).join(' ')
                                    : '<span style="color: #666; font-style: italic;">No named entities found</span>'}
                            </div>
                        </div>
                    </div>

                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #fef5e7; border-radius: 5px; text-align: center;">Respondent ${id2} (${entities2.count} entities)</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            <div style="font-size: 14px; line-height: 1.8;">
                                ${entities2.count > 0
                                    ? entities2.entityList.map(e => `<span style="background: #fff3e0; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">${escapeHtml(e)}</span>`).join(' ')
                                    : '<span style="color: #666; font-style: italic;">No named entities found</span>'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function generateFuzzyNgram3Details(text1, text2, id1, id2) {
            const ngramSize = 3;
            const maxDistance = 5;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }

            // Find fuzzy matches with their Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = levenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = fuzzyNgramSimilarity(text1, text2, ngramSize, maxDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Fuzzy 3-Word Phrase Matching (Levenshtein Distance)</h3>
                    <p>Uses the Levenshtein distance algorithm to detect paraphrasing by finding 3-word phrases that are nearly identical with minor word substitutions. Based on MIT 2024 study's n-gram analysis approach.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Levenshtein distance measures the minimum number of single-character edits (insertions, deletions, substitutions) needed to transform one string into another. We apply this to 3-word phrases with a maximum edit distance of ${maxDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Why This Matters:</strong> Catches short paraphrasing like "helping students learn" vs "aiding students learn" or "working with people" vs "working with individuals"
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                    <p style="font-size: 13px; color: #666; margin: 10px 0 0 0;">
                        Calculated as: (total matches) / max(phrases in text 1, phrases in text 2)
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">âœ“ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                                <div style="font-size: 12px; color: #666; margin-top: 3px;">Distance: ${match.distance} (identical)</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">âš¡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Similar phrases with edit distance â‰¤ ${maxDistance} (potential paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">dist: ${match.distance}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 3-word phrases within edit distance of ${maxDistance})
                </div>
                ` : ''}
            `;
        }

        function generateFuzzyNgram6Details(text1, text2, id1, id2) {
            const ngramSize = 6;
            const maxDistance = 13;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    index: i
                });
            }

            // Find fuzzy matches with their Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = levenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = fuzzyNgramSimilarity(text1, text2, ngramSize, maxDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Fuzzy 6-Word Phrase Matching (Levenshtein Distance)</h3>
                    <p>Uses the Levenshtein distance algorithm to detect paraphrasing by finding 6-word phrases that are nearly identical with word substitutions. Based on MIT 2024 study's n-gram analysis approach.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Levenshtein distance measures the minimum number of single-character edits (insertions, deletions, substitutions) needed to transform one string into another. We apply this to 6-word phrases with a maximum edit distance of ${maxDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Why This Matters:</strong> Detects longer, more complex paraphrasing patterns like "passionate about helping students succeed in school" vs "passionate about supporting students succeed in college" (captures sentence-level similarities)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">6-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">6-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                    <p style="font-size: 13px; color: #666; margin: 10px 0 0 0;">
                        Calculated as: (total matches) / max(phrases in text 1, phrases in text 2)
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">âœ“ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                                <div style="font-size: 12px; color: #666; margin-top: 3px;">Distance: ${match.distance} (identical)</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">âš¡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Similar phrases with edit distance â‰¤ ${maxDistance} (potential paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">dist: ${match.distance}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 6-word phrases within edit distance of ${maxDistance})
                </div>
                ` : ''}
            `;
        }

        function generateWordLevelFuzzy3Details(text1, text2, id1, id2) {
            const ngramSize = 3;
            const maxWordDistance = 1;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    words: words1.slice(i, i + ngramSize),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    words: words2.slice(i, i + ngramSize),
                    index: i
                });
            }

            // Find fuzzy matches with their word-level Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = wordLevelLevenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxWordDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize, maxWordDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Word-Level 3-Word Phrase Matching</h3>
                    <p>Uses <strong>word-level</strong> Levenshtein distance to detect paraphrasing by counting word substitutions. Perfect for catching single-word changes like "helping" â†’ "aiding".</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Compares 3-word phrases and counts the minimum number of <em>word</em> substitutions/insertions/deletions needed to transform one phrase into another. Maximum word distance = ${maxWordDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Example:</strong> "helping students learn" vs "aiding students learn" = distance of <strong>1</strong> (one word substitution: helpingâ†’aiding)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">3-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">âœ“ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">âš¡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Phrases with â‰¤${maxWordDistance} word difference (likely paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">${match.distance} word${match.distance > 1 ? 's' : ''}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 3-word phrases within ${maxWordDistance} word substitution)
                </div>
                ` : ''}
            `;
        }

        function generateWordLevelFuzzy5Details(text1, text2, id1, id2) {
            const ngramSize = 5;
            const maxWordDistance = 2;

            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push({
                    text: words1.slice(i, i + ngramSize).join(' '),
                    words: words1.slice(i, i + ngramSize),
                    index: i
                });
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push({
                    text: words2.slice(i, i + ngramSize).join(' '),
                    words: words2.slice(i, i + ngramSize),
                    index: i
                });
            }

            // Find fuzzy matches with their word-level Levenshtein distances
            const fuzzyMatches = [];
            const exactMatches = [];
            const seenPairs = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = wordLevelLevenshteinDistance(ng1.text, ng2.text);
                    const pairKey = `${ng1.text}|||${ng2.text}`;

                    if (distance === 0 && !seenPairs.has(pairKey)) {
                        exactMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    } else if (distance > 0 && distance <= maxWordDistance && !seenPairs.has(pairKey)) {
                        fuzzyMatches.push({
                            phrase1: ng1.text,
                            phrase2: ng2.text,
                            words1: ng1.words,
                            words2: ng2.words,
                            distance: distance
                        });
                        seenPairs.add(pairKey);
                    }
                });
            });

            // Sort by distance (closest matches first)
            fuzzyMatches.sort((a, b) => a.distance - b.distance);

            const similarity = wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize, maxWordDistance);
            const totalMatches = exactMatches.length + fuzzyMatches.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Word-Level 5-Word Phrase Matching</h3>
                    <p>Uses <strong>word-level</strong> Levenshtein distance to detect multi-word paraphrasing. Counts word substitutions across longer phrases to catch sentence-level similarities.</p>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Algorithm:</strong> Compares 5-word phrases and counts the minimum number of <em>word</em> substitutions/insertions/deletions needed. Maximum word distance = ${maxWordDistance}.
                    </div>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0;">
                        <strong>Example:</strong> "passionate about helping students succeed" vs "passionate about supporting students excel" = distance of <strong>2</strong> (two word substitutions)
                    </div>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Fuzzy Match Statistics</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">5-Word Phrases (Text 1)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams1.length}</div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">5-Word Phrases (Text 2)</div>
                            <div style="font-weight: bold; font-size: 18px;">${ngrams2.length}</div>
                        </div>
                        <div style="padding: 8px; background: #d5f4e6; border-radius: 3px; text-align: center;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Total Matches (exact + fuzzy)</div>
                            <div style="font-weight: bold; font-size: 18px; color: #2e7d32;">${totalMatches}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                        ${(similarity * 100).toFixed(1)}%
                    </p>
                </div>

                ${exactMatches.length > 0 ? `
                <div style="background: #c8e6c9; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #1b5e20;">âœ“ Exact Matches (${exactMatches.length})</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${exactMatches.slice(0, 50).map(match => `
                            <div style="background: #e8f5e9; padding: 8px 12px; margin: 5px 0; border-radius: 4px; border-left: 4px solid #4caf50;">
                                <div style="font-weight: 500; color: #2e7d32;">"${escapeHtml(match.phrase1)}"</div>
                            </div>
                        `).join('')}
                        ${exactMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${exactMatches.length - 50} more exact matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${fuzzyMatches.length > 0 ? `
                <div style="background: #fff3e0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 15px 0; color: #e65100;">âš¡ Fuzzy Matches (${fuzzyMatches.length})</h4>
                    <p style="font-size: 13px; color: #666; margin-bottom: 15px;">Phrases with â‰¤${maxWordDistance} word differences (likely paraphrasing)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        ${fuzzyMatches.slice(0, 50).map(match => `
                            <div style="background: #fff8e1; padding: 10px 12px; margin: 8px 0; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: center;">
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase1)}"</div>
                                    <div style="background: #ff9800; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">${match.distance} word${match.distance > 1 ? 's' : ''}</div>
                                    <div style="font-weight: 500;">"${escapeHtml(match.phrase2)}"</div>
                                </div>
                            </div>
                        `).join('')}
                        ${fuzzyMatches.length > 50 ? `<div style="text-align: center; padding: 10px; color: #666; font-style: italic;">... and ${fuzzyMatches.length - 50} more fuzzy matches</div>` : ''}
                    </div>
                </div>
                ` : ''}

                ${totalMatches === 0 ? `
                <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; text-align: center; color: #666; font-style: italic;">
                    No fuzzy matches found (no 5-word phrases within ${maxWordDistance} word substitutions)
                </div>
                ` : ''}
            `;
        }

        function generateSentenceVarianceDetails(text1, text2, id1, id2) {
            const getSentenceLengths = (text) => {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                return sentences.map(s => s.trim().split(/\s+/).length);
            };

            const lengths1 = getSentenceLengths(text1);
            const lengths2 = getSentenceLengths(text2);

            const variance1 = sentenceLengthVariance(text1);
            const variance2 = sentenceLengthVariance(text2);
            const similarity = sentenceVarianceSimilarity(text1, text2);

            const mean1 = lengths1.reduce((a,b) => a+b, 0) / lengths1.length;
            const mean2 = lengths2.reduce((a,b) => a+b, 0) / lengths2.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Sentence Variance Similarity</h3>
                    <p>Compares how sentence lengths vary within each text. Higher similarity means both texts have similar patterns of sentence length variation.</p>

                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 13px;">
                        <strong>How Variance is Calculated:</strong>
                        <ol style="margin: 5px 0 0 20px; padding: 0;">
                            <li>Calculate the mean (average) sentence length</li>
                            <li>For each sentence, find the difference from the mean and square it: (length - mean)Â²</li>
                            <li>Sum all the squared differences</li>
                            <li>Divide by the number of sentences</li>
                        </ol>
                        <p style="margin: 5px 0 0 0; font-family: monospace;">variance = Î£(length - mean)Â² / n</p>
                    </div>

                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = 1 - |variance_A - variance_B| / max(variance_A, variance_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p><strong>Sentences:</strong> ${lengths1.length}</p>
                        <p><strong>Mean Length:</strong> ${mean1.toFixed(2)} words</p>
                        <p><strong>Variance:</strong> ${variance1.toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666;">Sentence lengths: ${lengths1.join(', ')}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p><strong>Sentences:</strong> ${lengths2.length}</p>
                        <p><strong>Mean Length:</strong> ${mean2.toFixed(2)} words</p>
                        <p><strong>Variance:</strong> ${variance2.toFixed(2)}</p>
                        <p style="font-size: 12px; color: #666;">Sentence lengths: ${lengths2.join(', ')}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        1 - |${variance1.toFixed(2)} - ${variance2.toFixed(2)}| / ${Math.max(variance1, variance2).toFixed(2)} =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>
            `;
        }

        function generateWordCountDetails(text1, text2, id1, id2) {
            const count1 = tokenize(text1).length;
            const count2 = tokenize(text2).length;
            const similarity = wordCountSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Word Count Similarity</h3>
                    <p>Compares total word counts between texts.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = 1 - |count_A - count_B| / max(count_A, count_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${count1} words</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${count2} words</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        Difference: ${Math.abs(count1 - count2)} words<br>
                        1 - ${Math.abs(count1 - count2)} / ${Math.max(count1, count2)} =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>
            `;
        }

        function generateAvgSentenceLengthDetails(text1, text2, id1, id2) {
            const getAvg = (text) => {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                const lengths = sentences.map(s => s.trim().split(/\s+/).length);
                return lengths.reduce((a,b) => a+b, 0) / lengths.length;
            };

            const avg1 = getAvg(text1);
            const avg2 = getAvg(text2);
            const similarity = avgSentenceLengthSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Average Sentence Length Similarity</h3>
                    <p>Compares the average number of words per sentence.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = 1 - |avg_A - avg_B| / max(avg_A, avg_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${avg1.toFixed(2)} words/sentence</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p style="font-size: 32px; font-weight: bold; margin: 10px 0;">${avg2.toFixed(2)} words/sentence</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        1 - |${avg1.toFixed(2)} - ${avg2.toFixed(2)}| / ${Math.max(avg1, avg2).toFixed(2)} =
                        <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>
            `;
        }

        function generateBurstinessDetails(text1, text2, id1, id2) {
            const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i',
                                       'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
                                       'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she',
                                       'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their']);

            // Track word positions for each text
            const getWordPositions = (text) => {
                const words = text.toLowerCase().match(/\b[a-z]+\b/g) || [];
                const positions = {};
                words.forEach((word, idx) => {
                    if (!stopWords.has(word) && word.length > 3) {
                        if (!positions[word]) positions[word] = [];
                        positions[word].push(idx);
                    }
                });
                return { positions, totalWords: words.length };
            };

            const data1 = getWordPositions(text1);
            const data2 = getWordPositions(text2);

            // Find common significant words (appear at least 2 times in each)
            const commonWords = Object.keys(data1.positions).filter(word =>
                data2.positions[word] &&
                data1.positions[word].length >= 2 &&
                data2.positions[word].length >= 2
            ).slice(0, 20);

            const burstScores = commonWords.map(word => {
                const b1 = calculateTemporalBurstiness(data1.positions[word], data1.totalWords);
                const b2 = calculateTemporalBurstiness(data2.positions[word], data2.totalWords);
                return {
                    word,
                    b1,
                    b2,
                    count1: data1.positions[word].length,
                    count2: data2.positions[word].length,
                    diff: Math.abs(b1 - b2),
                    sim: 1 - Math.abs(b1 - b2)
                };
            });

            const similarity = temporalBurstinessSimilarity(text1, text2);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Temporal Burstiness Similarity (Cui et al. 2017)</h3>
                    <p>Measures temporal clustering of words using word positions throughout the text.</p>
                    <div style="font-family: monospace; background: white; padding: 12px; border-radius: 3px; margin: 10px 0; font-size: 13px; line-height: 1.8;">
                        <strong>Calculating Î¼ for each word in each respondent:</strong><br><br>
                        <div style="background: #f8f9fa; padding: 8px; margin: 8px 0; border-left: 3px solid #57068C;">
                        <strong>Example:</strong> "The cat sat on <u>the</u> mat and <u>the</u> cat ran"<br>
                        Total words (T) = 10, word "the" at positions [0, 4, 7], frequency (f) = 3
                        </div>
                        1. <strong>Scan positions t</strong> from 0 to T (each word index)<br>
                        2. <strong>At each position t</strong>, count occurrences so far: C(t)<br>
                        <span style="font-size: 11px; color: #666; margin-left: 15px;">
                        t=0: C(0)=1, t=1: C(1)=1, t=4: C(4)=2, t=7: C(7)=3...
                        </span><br>
                        3. <strong>Compare to uniform</strong>: Linear reference = (f/T) Ã— t<br>
                        4. <strong>Calculate area</strong> between C(t) and linear reference<br>
                        5. <strong>Î¼ = (2 Ã— max_area) / (f Ã— T)</strong><br><br>
                        <strong>Î¼ = 1</strong>: Word appears in concentrated bursts<br>
                        <strong>Î¼ = 0</strong>: Word distributed uniformly<br><br>
                        <strong>Similarity</strong> = 1 - |Î¼_A - Î¼_B|<br>
                        <strong>Final</strong> = average across ${commonWords.length} common words
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Temporal Burstiness Similarity</h4>
                    <p style="font-size: 24px; font-weight: bold; margin: 0;"><strong>${(similarity * 100).toFixed(1)}%</strong></p>
                    <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Based on ${commonWords.length} common words</p>
                </div>

                <h4>Temporal Burstiness Scores for Common Words</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #57068C; color: white;">
                            <th style="padding: 10px; text-align: left;">Word</th>
                            <th style="padding: 10px; text-align: center;">Count</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id1} Î¼</th>
                            <th style="padding: 10px; text-align: center;">Count</th>
                            <th style="padding: 10px; text-align: center;">Respondent ${id2} Î¼</th>
                            <th style="padding: 10px; text-align: center;">Difference</th>
                            <th style="padding: 10px; text-align: center;">Similarity</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${burstScores.map((s, i) => `
                            <tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'};">
                                <td style="padding: 8px; font-weight: 600;">${escapeHtml(s.word)}</td>
                                <td style="padding: 8px; text-align: center; color: #666;">${s.count1}</td>
                                <td style="padding: 8px; text-align: center;">${s.b1.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: center; color: #666;">${s.count2}</td>
                                <td style="padding: 8px; text-align: center;">${s.b2.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: center;">${s.diff.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: center; font-weight: bold;">${(s.sim * 100).toFixed(1)}%</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function generatePronounDensityDetails(text1, text2, id1, id2) {
            const pronouns = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
                            'you', 'your', 'yours', 'yourself', 'yourselves',
                            'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
                            'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
                            'i\'m', 'i\'ve', 'i\'d', 'i\'ll', 'you\'re', 'you\'ve', 'you\'d', 'you\'ll',
                            'he\'s', 'he\'d', 'he\'ll', 'she\'s', 'she\'d', 'she\'ll', 'it\'s', 'it\'d', 'it\'ll',
                            'we\'re', 'we\'ve', 'we\'d', 'we\'ll', 'they\'re', 'they\'ve', 'they\'d', 'they\'ll'];

            const words1 = tokenize(text1);
            const words2 = tokenize(text2);

            // Find actual pronouns used in each text
            const foundPronouns1 = words1.filter(w => pronouns.includes(w.toLowerCase()));
            const foundPronouns2 = words2.filter(w => pronouns.includes(w.toLowerCase()));

            // Get unique pronouns and their counts
            const pronounFreq1 = {};
            const pronounFreq2 = {};
            foundPronouns1.forEach(p => {
                const lower = p.toLowerCase();
                pronounFreq1[lower] = (pronounFreq1[lower] || 0) + 1;
            });
            foundPronouns2.forEach(p => {
                const lower = p.toLowerCase();
                pronounFreq2[lower] = (pronounFreq2[lower] || 0) + 1;
            });

            const pronounCount1 = foundPronouns1.length;
            const pronounCount2 = foundPronouns2.length;

            const density1 = words1.length > 0 ? pronounCount1 / words1.length : 0;
            const density2 = words2.length > 0 ? pronounCount2 / words2.length : 0;

            const similarity = pronounDensitySimilarity(text1, text2);

            // Sort pronouns by frequency for display
            const sortedPronouns1 = Object.entries(pronounFreq1).sort((a, b) => b[1] - a[1]);
            const sortedPronouns2 = Object.entries(pronounFreq2).sort((a, b) => b[1] - a[1]);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Pronoun Density Similarity</h3>
                    <p>Compares the proportion of pronouns (I, me, you, he, she, it, they, etc.) in each text.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        density = pronoun_count / total_words<br>
                        similarity = 1 - |density_A - density_B| / max(density_A, density_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p><strong>Total Words:</strong> ${words1.length}</p>
                        <p><strong>Pronouns:</strong> ${pronounCount1}</p>
                        <p><strong>Density:</strong> ${(density1 * 100).toFixed(2)}%</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p><strong>Total Words:</strong> ${words2.length}</p>
                        <p><strong>Pronouns:</strong> ${pronounCount2}</p>
                        <p><strong>Density:</strong> ${(density2 * 100).toFixed(2)}%</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Overall Similarity</h4>
                    ${density1 === 0 && density2 === 0 ? `
                        <p style="font-size: 16px; margin: 0 0 10px 0;">
                            Both texts have 0 pronouns â†’ Perfect similarity
                        </p>
                        <p style="font-size: 24px; margin: 0; font-weight: bold; color: #2e7d32;">
                            100.0%
                        </p>
                    ` : `
                        <p style="font-size: 16px; margin: 0 0 10px 0;">
                            1 - |${(density1 * 100).toFixed(2)} - ${(density2 * 100).toFixed(2)}| / ${(Math.max(density1, density2) * 100).toFixed(2)} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                        </p>
                    `}
                </div>

                <h4 style="margin: 20px 0 15px 0;">Pronouns Found in Each Text</h4>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #e8f4f8; border-radius: 5px; text-align: center;">Respondent ${id1}</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            ${sortedPronouns1.length > 0 ? `
                                <div style="font-size: 14px; line-height: 1.8;">
                                    ${sortedPronouns1.map(([pronoun, count]) =>
                                        `<span style="background: #e3f2fd; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">
                                            ${escapeHtml(pronoun)} <span style="color: #666; font-size: 12px;">(${count})</span>
                                        </span>`
                                    ).join(' ')}
                                </div>
                            ` : '<span style="color: #666; font-style: italic;">No pronouns found</span>'}
                        </div>
                    </div>

                    <div>
                        <h4 style="margin: 0 0 15px 0; padding: 12px; background: #fef5e7; border-radius: 5px; text-align: center;">Respondent ${id2}</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; min-height: 100px;">
                            ${sortedPronouns2.length > 0 ? `
                                <div style="font-size: 14px; line-height: 1.8;">
                                    ${sortedPronouns2.map(([pronoun, count]) =>
                                        `<span style="background: #fff3e0; padding: 4px 10px; margin: 3px; border-radius: 3px; display: inline-block;">
                                            ${escapeHtml(pronoun)} <span style="color: #666; font-size: 12px;">(${count})</span>
                                        </span>`
                                    ).join(' ')}
                                </div>
                            ` : '<span style="color: #666; font-style: italic;">No pronouns found</span>'}
                        </div>
                    </div>
                </div>
            `;
        }

        function generateTransitionWordsDetails(text1, text2, id1, id2) {
            const transitionWords = ['however', 'therefore', 'moreover', 'furthermore', 'nevertheless',
                                   'consequently', 'thus', 'hence', 'accordingly', 'meanwhile',
                                   'additionally', 'likewise', 'similarly', 'conversely', 'instead',
                                   'otherwise', 'namely', 'specifically', 'indeed', 'certainly'];

            const words1 = tokenize(text1);
            const words2 = tokenize(text2);

            const transCount1 = words1.filter(w => transitionWords.includes(w.toLowerCase())).length;
            const transCount2 = words2.filter(w => transitionWords.includes(w.toLowerCase())).length;

            const density1 = words1.length > 0 ? transCount1 / words1.length : 0;
            const density2 = words2.length > 0 ? transCount2 / words2.length : 0;

            const similarity = transitionWordsSimilarity(text1, text2);

            // Find which specific transition words were used
            const used1 = transitionWords.filter(tw => words1.some(w => w.toLowerCase() === tw));
            const used2 = transitionWords.filter(tw => words2.some(w => w.toLowerCase() === tw));

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Transition Words Similarity</h3>
                    <p>Compares the use of transition words (however, therefore, moreover, etc.) in each text.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        density = transition_word_count / total_words<br>
                        similarity = 1 - |density_A - density_B| / max(density_A, density_B)
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id1}</h4>
                        <p><strong>Total Words:</strong> ${words1.length}</p>
                        <p><strong>Transition Words:</strong> ${transCount1}</p>
                        <p><strong>Density:</strong> ${(density1 * 100).toFixed(2)}%</p>
                        <p style="font-size: 11px; color: #666; margin-top: 10px;"><strong>Used:</strong> ${used1.length > 0 ? used1.join(', ') : 'none'}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Respondent ${id2}</h4>
                        <p><strong>Total Words:</strong> ${words2.length}</p>
                        <p><strong>Transition Words:</strong> ${transCount2}</p>
                        <p><strong>Density:</strong> ${(density2 * 100).toFixed(2)}%</p>
                        <p style="font-size: 11px; color: #666; margin-top: 10px;"><strong>Used:</strong> ${used2.length > 0 ? used2.join(', ') : 'none'}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${density1 === 0 && density2 === 0 ?
                            'Both texts have 0 transition words = <strong>100% similar</strong>' :
                            `1 - |${(density1 * 100).toFixed(2)} - ${(density2 * 100).toFixed(2)}| / ${(Math.max(density1, density2) * 100).toFixed(2)} =
                            <strong>${(similarity * 100).toFixed(1)}%</strong>`
                        }
                    </p>
                </div>
            `;
        }

        function generateCombinedDetails(text1, text2, id1, id2) {
            const selected = getSelectedMetrics();

            // Calculate all metrics (raw scores for display)
            const metrics = {
                cosine: cosineSimilarity(text1, text2),
                jaccard: jaccardSimilarity(text1, text2),
                ngram: ngramSimilarity(text1, text2, 3),
                sentenceVariance: sentenceVarianceSimilarity(text1, text2),
                wordCount: wordCountSimilarity(text1, text2),
                avgSentenceLength: avgSentenceLengthSimilarity(text1, text2),
                // burstiness: removed - using corpus-level analysis instead
                pronounDensity: pronounDensitySimilarity(text1, text2),
                transitionWords: transitionWordsSimilarity(text1, text2),
                ngramPunctuation: ngramWithPunctuationSimilarity(text1, text2, 3),
                wordNgram: wordNgramSimilarity(text1, text2, 3),
                ngram4: ngram4Similarity(text1, text2),
                ngram5: ngram5Similarity(text1, text2),
                ner: nerSimilarity(text1, text2),
                temporalBurstiness: temporalBurstinessSimilarity(text1, text2),
                fuzzyNgram3: fuzzyNgramSimilarity(text1, text2, 3, 5),
                fuzzyNgram6: fuzzyNgramSimilarity(text1, text2, 6, 13),
                wordLevelFuzzy3: wordLevelFuzzyNgramSimilarity(text1, text2, 3, 1),
                wordLevelFuzzy5: wordLevelFuzzyNgramSimilarity(text1, text2, 5, 2)
            };

            const metricNames = {
                cosine: 'Cosine',
                jaccard: 'Jaccard',
                ngram: 'N-gram',
                sentenceVariance: 'Sentence Variance',
                wordCount: 'Word Count',
                avgSentenceLength: 'Avg Sentence Length',
                burstiness: 'Burstiness',
                pronounDensity: 'Pronoun Density',
                transitionWords: 'Transition Words',
                ngramPunctuation: 'N-gram with Punctuation',
                wordNgram: '3-Word Phrases',
                ngram4: 'N-gram 4-char',
                ngram5: 'N-gram 5-char',
                ner: 'Named Entities',
                temporalBurstiness: 'Temporal Burstiness',
                fuzzyNgram3: 'Fuzzy 3-Word',
                fuzzyNgram6: 'Fuzzy 6-Word',
                wordLevelFuzzy3: 'Word-Level 3-Word',
                wordLevelFuzzy5: 'Word-Level 5-Word'
            };

            // Find the actual pair in allSimilarityPairs to get the pre-calculated combined similarity
            let combined = 0;
            const actualPair = allSimilarityPairs.find(p =>
                (p.id1 === id1 && p.id2 === id2) || (p.id1 === id2 && p.id2 === id1)
            );

            if (actualPair) {
                // Use the pre-calculated similarity from the analysis
                combined = actualPair.similarity;
            } else {
                // Fallback: calculate it (shouldn't normally happen)
                combined = calculateCombinedSimilarity(text1, text2);
            }

            const count = selected.length;

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">Combined Similarity Score</h3>
                    <p>The combined score uses <strong>normalized, weighted averaging</strong> of selected metrics:</p>
                    <div style="font-family: monospace; background: white; padding: 12px; border-radius: 3px; margin: 10px 0; font-size: 13px; line-height: 1.8;">
                        <strong>Step 1: Normalize each metric</strong><br>
                        normalized = (score - min) / (max - min)<br>
                        <span style="font-size: 11px; color: #666;">Scales all metrics to [0,1] using min/max across all pairs</span><br><br>
                        <strong>Step 2: Apply weights</strong><br>
                        combined = Î£(normalized Ã— weight) / Î£(weight)<br>
                        <span style="font-size: 11px; color: #666;">Higher weights = more influence on final score</span>
                    </div>
                    <p style="font-size: 12px; color: #666; margin: 10px 0 0 0;">
                        This ensures high-signal metrics (e.g., fuzzy matching) aren't drowned out by low-signal metrics (e.g., word count). Configure metrics and weights via Metric Settings.
                    </p>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Combined Score</h4>
                    <p style="font-size: 32px; font-weight: bold; margin: 0;"><strong>${(combined * 100).toFixed(1)}%</strong></p>
                    <p style="font-size: 12px; color: #666; margin: 5px 0 0 0;">Based on ${count} selected metrics</p>
                </div>

                <h4>Individual Metric Contributions</h4>
                <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
                    <thead>
                        <tr style="background: #57068C; color: white;">
                            <th style="padding: 10px; text-align: left;">Metric</th>
                            <th style="padding: 10px; text-align: center;">Score</th>
                            <th style="padding: 10px; text-align: center;">Selected?</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${Object.keys(metrics).map((key, i) => `
                            <tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'}; ${selected.includes(key) ? 'font-weight: bold;' : 'opacity: 0.5;'}">
                                <td style="padding: 8px;">${metricNames[key]}</td>
                                <td style="padding: 8px; text-align: center;">${(metrics[key] * 100).toFixed(1)}%</td>
                                <td style="padding: 8px; text-align: center;">${selected.includes(key) ? 'âœ“' : 'âœ—'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>

                <div style="background: #fff3cd; padding: 15px; border-radius: 5px;">
                    <p style="margin: 0; font-size: 14px;">
                        <strong>Calculation:</strong> (${selected.map(m => (metrics[m] * 100).toFixed(1)).join(' + ')}) / ${count} = ${(combined * 100).toFixed(1)}%
                    </p>
                </div>
            `;
        }

        function generateNgramPunctuationDetails(text1, text2, id1, id2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase();
                for (let i = 0; i <= clean.length - 3; i++) {
                    ngrams.add(clean.substring(i, i + 3));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 100);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">N-gram with Punctuation (3-character sequences)</h3>
                    <p>This metric is identical to regular N-gram but <strong>keeps punctuation patterns</strong>. This can reveal similarities in writing style, formatting habits, and punctuation usage that might indicate AI-generated text or template use.</p>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 3-grams| / |total unique 3-grams|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">3-grams in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Sample of Shared 3-character Sequences with Punctuation (${Math.min(100, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px;">
                    ${shared.map(ng => {
                        const display = ng.replace(/\s/g, 'Â·'); // Show spaces as middle dots
                        return `<span style="background: #d5f4e6; padding: 2px 6px; margin: 2px; border-radius: 3px; display: inline-block;">"${escapeHtml(display)}"</span>`;
                    }).join(' ')}
                </div>
            `;
        }

        function generateWordNgramDetails(text1, text2, id1, id2) {
            const getWordNgrams = (text) => {
                const words = tokenize(text);
                const ngrams = new Set();
                for (let i = 0; i <= words.length - 3; i++) {
                    ngrams.add(words.slice(i, i + 3).join(' ').toLowerCase());
                }
                return ngrams;
            };

            const ngrams1 = getWordNgrams(text1);
            const ngrams2 = getWordNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            const similarity = union.size === 0 ? 0 : intersection.size / union.size;

            const shared = [...intersection].slice(0, 50);

            return `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">3-Word Phrase Similarity</h3>
                    <p>This metric analyzes <strong>word-level n-grams</strong> (sequences of 3 consecutive words) rather than character sequences. This is excellent for detecting:</p>
                    <ul style="margin: 5px 0 0 20px;">
                        <li>Copy-pasted sentences or paragraphs</li>
                        <li>Template phrases or boilerplate text</li>
                        <li>Common AI-generated phrase patterns</li>
                        <li>Semantic similarity beyond just vocabulary overlap</li>
                    </ul>
                    <p style="font-family: monospace; background: white; padding: 10px; border-radius: 3px; margin: 10px 0 0 0;">
                        similarity = |shared 3-word phrases| / |total unique 3-word phrases|
                    </p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div style="background: #e8f4f8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Phrases in A</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams1.size}</p>
                    </div>
                    <div style="background: #fef5e7; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Phrases in B</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${ngrams2.size}</p>
                    </div>
                    <div style="background: #d5f4e6; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Shared</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${intersection.size}</p>
                    </div>
                    <div style="background: #fadbd8; padding: 15px; border-radius: 5px;">
                        <h4 style="margin: 0 0 10px 0;">Total Unique</h4>
                        <p style="font-size: 24px; font-weight: bold; margin: 0;">${union.size}</p>
                    </div>
                </div>

                <div style="background: #d5f4e6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px 0;">Final Result</h4>
                    <p style="font-size: 20px; margin: 0;">
                        ${intersection.size} / ${union.size} = <strong>${(similarity * 100).toFixed(1)}%</strong>
                    </p>
                </div>

                <h4>Shared 3-Word Phrases (${Math.min(50, shared.length)} of ${intersection.size})</h4>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 300px; overflow-y: auto;">
                    ${shared.map((phrase, i) => `
                        <div style="background: ${i % 2 === 0 ? '#e8f8f5' : 'white'}; padding: 8px; margin: 5px 0; border-left: 3px solid #27ae60; border-radius: 3px;">
                            "${escapeHtml(phrase)}"
                        </div>
                    `).join('')}
                </div>

                ${intersection.size > 50 ? `
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-top: 15px; font-size: 13px;">
                        <strong>Note:</strong> Showing first 50 of ${intersection.size} shared phrases. High phrase overlap often indicates copy-paste, templates, or AI generation.
                    </div>
                ` : ''}
            `;
        }

        function cosineSimilarity(text1, text2) {
            const words1 = tokenize(text1);
            const words2 = tokenize(text2);
            const freq1 = {};
            const freq2 = {};
            const allWords = new Set([...words1, ...words2]);

            words1.forEach(w => freq1[w] = (freq1[w] || 0) + 1);
            words2.forEach(w => freq2[w] = (freq2[w] || 0) + 1);

            let dotProduct = 0, mag1 = 0, mag2 = 0;
            allWords.forEach(word => {
                const v1 = freq1[word] || 0;
                const v2 = freq2[word] || 0;
                dotProduct += v1 * v2;
                mag1 += v1 * v1;
                mag2 += v2 * v2;
            });

            return (mag1 === 0 || mag2 === 0) ? 0 : dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));
        }

        function jaccardSimilarity(text1, text2) {
            const set1 = new Set(tokenize(text1));
            const set2 = new Set(tokenize(text2));
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngramSimilarity(text1, text2, n = 3) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - n; i++) {
                    ngrams.add(clean.substring(i, i + n));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngramWithPunctuationSimilarity(text1, text2, n = 3) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase(); // Keep punctuation, just lowercase
                for (let i = 0; i <= clean.length - n; i++) {
                    ngrams.add(clean.substring(i, i + n));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function wordNgramSimilarity(text1, text2, n = 3) {
            const getWordNgrams = (text) => {
                const words = tokenize(text); // Use existing tokenize function
                const ngrams = new Set();
                for (let i = 0; i <= words.length - n; i++) {
                    ngrams.add(words.slice(i, i + n).join(' ').toLowerCase());
                }
                return ngrams;
            };

            const ngrams1 = getWordNgrams(text1);
            const ngrams2 = getWordNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngram4Similarity(text1, text2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 4; i++) {
                    ngrams.add(clean.substring(i, i + 4));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function ngram5Similarity(text1, text2) {
            const getNgrams = (text) => {
                const ngrams = new Set();
                const clean = text.toLowerCase().replace(/[^\w\s]/g, '');
                for (let i = 0; i <= clean.length - 5; i++) {
                    ngrams.add(clean.substring(i, i + 5));
                }
                return ngrams;
            };

            const ngrams1 = getNgrams(text1);
            const ngrams2 = getNgrams(text2);
            const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
            const union = new Set([...ngrams1, ...ngrams2]);
            return union.size === 0 ? 0 : intersection.size / union.size;
        }

        function nerSimilarity(text1, text2) {
            // Extract named entities - all capitalized sequences (proper nouns)
            const extractEntities = (text) => {
                const wordCount = tokenize(text).length;

                // Extract sequences of capitalized words (proper nouns)
                // Matches: "John Smith", "New York University", "MIT", "EdTech", etc.
                // Updated to handle mixed case like "EdTech" or "iPhone"
                const properNounPattern = /\b[A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)*\b/g;

                // Remove punctuation from the text before matching to avoid "EdTech." vs "EdTech" issues
                const cleanText = text.replace(/([.!?;:,])/g, ' $1 ');
                const matches = cleanText.match(properNounPattern) || [];

                // Filter out common sentence-starting words and single letters
                const commonWords = new Set(['The', 'This', 'That', 'These', 'Those', 'A', 'An', 'I', 'It', 'He', 'She', 'We', 'They']);

                // Advanced filtering: Only include words that appear capitalized in mid-sentence positions
                // This prevents sentence-initial capitalization from being treated as named entities
                const sentenceBoundaryPattern = /[.!?]\s+/g;
                const sentences = text.split(sentenceBoundaryPattern);

                const validEntities = new Set();

                // Find words that appear in mid-sentence positions
                sentences.forEach(sentence => {
                    const sentenceMatches = sentence.match(/\b[A-Z][A-Za-z]*(?:\s+[A-Z][A-Za-z]*)*\b/g) || [];

                    // All words after the first are mid-sentence
                    sentenceMatches.slice(1).forEach(match => {
                        if (match.length > 1 && !commonWords.has(match)) {
                            validEntities.add(match);
                        }
                    });
                });

                // Now filter the original matches to only include valid entities
                const entities = matches.filter(m => validEntities.has(m));

                // Deduplicate
                const uniqueEntities = [...new Set(entities)];

                // Calculate density (per 100 words)
                const density = wordCount > 0 ? (uniqueEntities.length / wordCount) * 100 : 0;

                return {
                    entities: new Set(uniqueEntities.map(e => e.toLowerCase())),
                    entityList: uniqueEntities,
                    count: uniqueEntities.length,
                    density: density,
                    wordCount: wordCount
                };
            };

            const entities1 = extractEntities(text1);
            const entities2 = extractEntities(text2);

            // Calculate Jaccard similarity
            const intersection = new Set([...entities1.entities].filter(x => entities2.entities.has(x)));
            const union = new Set([...entities1.entities, ...entities2.entities]);
            const contentSimilarity = union.size === 0 ? 0 : intersection.size / union.size;

            // Calculate density similarity (how similar are the usage rates?)
            const densitySimilarity = (() => {
                if (entities1.density === 0 && entities2.density === 0) return 1;
                const max = Math.max(entities1.density, entities2.density);
                return max === 0 ? 0 : 1 - (Math.abs(entities1.density - entities2.density) / max);
            })();

            // Weighted average: 60% content similarity (shared entities), 40% density similarity (usage patterns)
            return (contentSimilarity * 0.6) + (densitySimilarity * 0.4);
        }

        // Levenshtein distance - minimum edits needed to transform one string into another
        // Character-level Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            // Initialize matrix
            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            // Fill matrix
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1[i - 1] === str2[j - 1]) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            matrix[i][j - 1] + 1,     // insertion
                            matrix[i - 1][j] + 1      // deletion
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        // Word-level Levenshtein distance - counts word substitutions/insertions/deletions
        function wordLevelLevenshteinDistance(phrase1, phrase2) {
            const words1 = phrase1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = phrase2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const len1 = words1.length;
            const len2 = words2.length;
            const matrix = [];

            // Initialize matrix
            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            // Fill matrix - comparing words instead of characters
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (words1[i - 1] === words2[j - 1]) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // word substitution
                            matrix[i][j - 1] + 1,     // word insertion
                            matrix[i - 1][j] + 1      // word deletion
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        // Fuzzy n-gram matching using character-level Levenshtein distance
        function fuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxDistance = 3) {
            // Extract word-level n-grams
            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push(words1.slice(i, i + ngramSize).join(' '));
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push(words2.slice(i, i + ngramSize).join(' '));
            }

            if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

            // Find fuzzy matches using Levenshtein distance
            const matches = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    const distance = levenshteinDistance(ng1, ng2);
                    // Match if distance is within threshold
                    if (distance <= maxDistance) {
                        matches.add(`${idx1}-${idx2}`);
                    }
                });
            });

            // Calculate similarity as proportion of n-grams that have fuzzy matches
            const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
            return matches.size / totalNgrams;
        }

        // Word-level fuzzy n-gram matching - detects paraphrasing by counting word substitutions
        function wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxWordDistance = 1) {
            // Extract word-level n-grams
            const words1 = text1.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/).filter(w => w.length > 0);

            const ngrams1 = [];
            const ngrams2 = [];

            // Create n-grams (arrays of words)
            for (let i = 0; i <= words1.length - ngramSize; i++) {
                ngrams1.push(words1.slice(i, i + ngramSize));
            }
            for (let i = 0; i <= words2.length - ngramSize; i++) {
                ngrams2.push(words2.slice(i, i + ngramSize));
            }

            if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

            // Find fuzzy matches using word-level Levenshtein distance
            const matches = new Set();

            ngrams1.forEach((ng1, idx1) => {
                ngrams2.forEach((ng2, idx2) => {
                    // Compare word arrays
                    const distance = wordLevelLevenshteinDistance(ng1.join(' '), ng2.join(' '));
                    // Match if word-level distance is within threshold
                    if (distance <= maxWordDistance) {
                        matches.add(`${idx1}-${idx2}`);
                    }
                });
            });

            // Calculate similarity as proportion of n-grams that have fuzzy matches
            const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
            return matches.size / totalNgrams;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function exportResults() {
            const report = {
                timestamp: new Date().toISOString(),
                column: headers[currentColumn],
                totalResponses: analysisResults.responses.length,
                metrics: {
                    lexicalDiversity: analysisResults.diversity,
                    phraseAnalysis: {
                        highFrequencyCount: analysisResults.phrases.highFreq.length,
                        outlierCount: analysisResults.phrases.outliers.length,
                        maxPhraseRate: analysisResults.phrases.maxPhraseRate,
                        topPhrases: analysisResults.phrases.topPhrases.slice(0, 20)
                    },
                    similarity: {
                        mean: analysisResults.similarity.mean,
                        stdDev: analysisResults.similarity.stdDev,
                        highSimilarityCount: analysisResults.similarity.highSimilarity,
                        highSimilarityPct: analysisResults.similarity.highSimilarityPct
                    }
                }
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `homogeneity-analysis-${Date.now()}.json`;
            a.click();
        }

        // ========== DYNAMIC BURSTINESS ANALYSIS ==========
        // Based on: "Dynamic burstiness of word-occurrence and network modularity in textbook systems"
        // Cui et al., Physica A, 2017

        /**
         * Track word occurrences with position information
         * @param {string} text - The text to analyze
         * @returns {Object} - Map of word -> array of positions
         */
        function trackWordPositions(text) {
            const words = text.toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(w => w.length > 2);

            const positions = {};
            words.forEach((word, index) => {
                if (!positions[word]) {
                    positions[word] = [];
                }
                positions[word].push(index);
            });

            return { positions, totalWords: words.length };
        }

        /**
         * Calculate cumulative count C(t) for a word
         * @param {Array} occurrences - Array of occurrence positions
         * @param {number} totalWords - Total number of words in document
         * @returns {Function} - Function that returns cumulative count at position t
         */
        function getCumulativeCount(occurrences, totalWords) {
            return function(t) {
                return occurrences.filter(pos => pos <= t).length;
            };
        }

        /**
         * Calculate core temporal burstiness measure Î¼ (Cui et al. 2017)
         * Î¼ = max_k { (1/fT) âˆ« |C(t) - [f/T(t - t_k) + k - 1]| dt }
         *
         * @param {Array} occurrences - Sorted array of occurrence positions
         * @param {number} totalWords - Total number of words
         * @returns {number} - Burstiness measure (0 to 1)
         */
        function calculateTemporalBurstiness(occurrences, totalWords) {
            if (occurrences.length === 0 || totalWords === 0) return 0;

            const f = occurrences.length; // frequency
            const T = totalWords;

            // Pre-compute cumulative count for efficiency (avoid repeated filtering)
            const sortedOccurrences = [...occurrences].sort((a, b) => a - b);

            let maxArea = 0;

            // Limit steps for performance - use fewer steps for larger documents
            const steps = Math.min(200, T); // Reduced from 1000 to 200
            const dt = T / steps;

            // For each occurrence k, calculate area
            for (let k = 0; k < Math.min(f, 20); k++) { // Limit to first 20 occurrence points
                const tk = sortedOccurrences[k];
                let area = 0;

                // Pre-calculate cumulative counts at sampled points
                let occIdx = 0;
                for (let i = 0; i < steps; i++) {
                    const t = i * dt;

                    // Efficient cumulative count using sorted array
                    while (occIdx < f && sortedOccurrences[occIdx] <= t) {
                        occIdx++;
                    }
                    const Ct = occIdx;

                    // Linear interpolation: f/T * (t - tk) + k
                    // Note: Cui et al. (2017) paper uses (k-1) with 1-based indexing;
                    // we use k with 0-based indexing (mathematically equivalent, verified)
                    const linearValue = (f / T) * (t - tk) + k;

                    // |C(t) - linear|
                    const diff = Math.abs(Ct - linearValue);
                    area += diff * dt;
                }

                if (area > maxArea) {
                    maxArea = area;
                }
            }

            // Normalize by fT/2 (area of half square)
            const normalized = (2 * maxArea) / (f * T);

            return Math.min(1, normalized); // Clamp to [0, 1]
        }

        /**
         * Calculate inter-event intervals (Ï„)
         * @param {Array} occurrences - Sorted array of occurrence positions
         * @returns {Array} - Array of intervals between consecutive occurrences
         */
        function calculateIntervals(occurrences) {
            const intervals = [];
            for (let i = 1; i < occurrences.length; i++) {
                intervals.push(occurrences[i] - occurrences[i-1]);
            }
            return intervals;
        }

        /**
         * Calculate memory effect M
         * M = (1/(f-1)) Î£ [(Ï„_k - m)(Ï„_{k+1} - m)] / ÏƒÂ²
         *
         * @param {Array} intervals - Array of inter-event intervals
         * @returns {number} - Memory correlation coefficient
         */
        function calculateMemoryEffect(intervals) {
            if (intervals.length < 2) return 0;

            const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const variance = intervals.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / intervals.length;

            if (variance === 0) return 0;

            let correlation = 0;
            for (let k = 0; k < intervals.length - 1; k++) {
                correlation += (intervals[k] - mean) * (intervals[k+1] - mean);
            }

            const M = correlation / ((intervals.length - 1) * variance);
            return M;
        }

        /**
         * Generate interval-shuffled random textbook (IRT)
         * Randomizes the sequence but keeps interval distribution unchanged
         * @param {Array} occurrences - Original occurrence positions
         * @param {number} totalWords - Total words in document
         * @returns {Array} - Shuffled occurrence positions
         */
        function generateIRT(occurrences, totalWords) {
            if (occurrences.length === 0) return [];

            const intervals = calculateIntervals(occurrences);

            // Shuffle intervals
            const shuffledIntervals = [...intervals].sort(() => Math.random() - 0.5);

            // Reconstruct positions with shuffled intervals
            const newOccurrences = [Math.floor(Math.random() * totalWords)];
            for (const interval of shuffledIntervals) {
                const next = newOccurrences[newOccurrences.length - 1] + interval;
                if (next < totalWords) {
                    newOccurrences.push(next);
                }
            }

            return newOccurrences.sort((a, b) => a - b);
        }

        /**
         * Generate completely random textbook (CRT)
         * @param {number} frequency - Number of occurrences
         * @param {number} totalWords - Total words in document
         * @returns {Array} - Random occurrence positions
         */
        function generateCRT(frequency, totalWords) {
            const positions = [];
            for (let i = 0; i < frequency; i++) {
                positions.push(Math.floor(Math.random() * totalWords));
            }
            return positions.sort((a, b) => a - b);
        }

        /**
         * Decompose burstiness into variance and memory components
         * @param {Array} occurrences - Original occurrence positions
         * @param {number} totalWords - Total words
         * @returns {Object} - {Î¼_total, Î¼_variance, Î¼_memory, Î¼_base}
         */
        function decomposeBurstiness(occurrences, totalWords) {
            // Original burstiness
            const Î¼_total = calculateTemporalBurstiness(occurrences, totalWords);

            // IRT burstiness (memory removed, variance preserved)
            const irt = generateIRT(occurrences, totalWords);
            const Î¼_irt = calculateTemporalBurstiness(irt, totalWords);

            // CRT burstiness (both removed)
            const crt = generateCRT(occurrences.length, totalWords);
            const Î¼_crt = calculateTemporalBurstiness(crt, totalWords);

            // Decomposition
            const Î¼_memory = Î¼_total - Î¼_irt;
            const Î¼_variance = Î¼_irt - Î¼_crt;

            return {
                Î¼_total,
                Î¼_variance,
                Î¼_memory,
                Î¼_base: Î¼_crt,
                Î¼_irt
            };
        }

        /**
         * Calculate word association matrix using exponential decay
         * W_ab = (1/2Î¾) Î£_m Î£_n e^(-|t_m - t_n|/Î¾)
         *
         * @param {Object} wordPositions - Map of word -> positions
         * @param {number} xi - Characteristic decay length (default: 50 words ~ paragraph)
         * @returns {Object} - Association matrix and word list
         */
        function calculateWordAssociation(wordPositions, xi = 50) {
            const words = Object.keys(wordPositions).filter(w => wordPositions[w].length >= 3);
            const n = words.length;
            const W = Array(n).fill(0).map(() => Array(n).fill(0));

            // Calculate association matrix
            for (let i = 0; i < n; i++) {
                for (let j = i; j < n; j++) {
                    const posA = wordPositions[words[i]];
                    const posB = wordPositions[words[j]];

                    let association = 0;
                    for (const tm of posA) {
                        for (const tn of posB) {
                            association += Math.exp(-Math.abs(tm - tn) / xi);
                        }
                    }

                    W[i][j] = association / (2 * xi);
                    W[j][i] = W[i][j]; // Symmetric
                }
            }

            return { W, words };
        }

        /**
         * Classify words into 4 categories based on frequency and burstiness
         * C1: Fundamental (high freq, medium burst)
         * C2: Topical (medium freq, high burst)
         * C3: Special (low freq, high burst)
         * C4: Common (low freq, low burst)
         *
         * @param {number} frequency - Word frequency
         * @param {number} burstiness - Word burstiness Î¼
         * @param {Object} stats - Overall statistics {meanFreq, meanBurst}
         * @returns {string} - Category label (C1, C2, C3, or C4)
         */
        function classifyWord(frequency, burstiness, stats) {
            const highFreq = frequency > stats.medianFreq;
            const highBurst = burstiness > stats.medianBurst;

            if (highFreq && highBurst) return 'C1'; // Fundamental
            if (!highFreq && highBurst) return 'C2'; // Topical
            if (highFreq && !highBurst) return 'C3'; // Special
            return 'C4'; // Common
        }

        /**
         * Analyze burstiness for all words in a corpus
         * @param {Array} responses - Array of response objects with text
         * @returns {Object} - Comprehensive burstiness analysis
         */
        function analyzeBurstiness(responses) {
            // Combine all responses into one corpus with position tracking
            let globalPosition = 0;
            const globalWordPositions = {};
            const responseWordCounts = [];

            responses.forEach((response, idx) => {
                const { positions, totalWords } = trackWordPositions(response.text);
                responseWordCounts.push(totalWords);

                // Add to global positions with offset
                Object.entries(positions).forEach(([word, localPositions]) => {
                    if (!globalWordPositions[word]) {
                        globalWordPositions[word] = [];
                    }
                    // Add global offset to local positions
                    localPositions.forEach(pos => {
                        globalWordPositions[word].push(globalPosition + pos);
                    });
                });

                globalPosition += totalWords;
            });

            const totalWords = globalPosition;

            // Calculate burstiness for each word (limit to top words for performance)
            const wordAnalysis = [];
            const wordEntries = Object.entries(globalWordPositions)
                .filter(([word, occurrences]) => occurrences.length >= 3)
                .sort((a, b) => b[1].length - a[1].length) // Sort by frequency
                .slice(0, 100); // Limit to top 100 words for performance

            wordEntries.forEach(([word, occurrences]) => {
                const freq = occurrences.length;
                const decomp = decomposeBurstiness(occurrences, totalWords);
                const intervals = calculateIntervals(occurrences);
                const memory = calculateMemoryEffect(intervals);

                wordAnalysis.push({
                    word,
                    frequency: freq,
                    burstiness: decomp.Î¼_total,
                    Î¼_variance: decomp.Î¼_variance,
                    Î¼_memory: decomp.Î¼_memory,
                    memory_M: memory,
                    occurrences,
                    intervals
                });
            });

            // Calculate statistics for classification
            if (wordAnalysis.length === 0) {
                return {
                    words: [],
                    stats: {
                        totalWords,
                        uniqueWords: Object.keys(globalWordPositions).length,
                        analyzedWords: 0,
                        meanBurstiness: 0,
                        medianFreq: 0,
                        medianBurst: 0
                    },
                    wordPositions: globalWordPositions
                };
            }

            const frequencies = wordAnalysis.map(w => w.frequency);
            const bursts = wordAnalysis.map(w => w.burstiness);

            // Sort copies (not originals)
            const sortedFreq = [...frequencies].sort((a, b) => a - b);
            const sortedBurst = [...bursts].sort((a, b) => a - b);

            const medianFreq = sortedFreq[Math.floor(sortedFreq.length / 2)] || 0;
            const medianBurst = sortedBurst[Math.floor(sortedBurst.length / 2)] || 0;

            const stats = {
                totalWords,
                uniqueWords: Object.keys(globalWordPositions).length,
                analyzedWords: wordAnalysis.length,
                meanBurstiness: bursts.reduce((a, b) => a + b, 0) / bursts.length,
                medianFreq,
                medianBurst
            };

            // Classify each word
            wordAnalysis.forEach(w => {
                w.category = classifyWord(w.frequency, w.burstiness, stats);
            });

            // Sort by burstiness
            wordAnalysis.sort((a, b) => b.burstiness - a.burstiness);

            return {
                words: wordAnalysis,
                stats,
                wordPositions: globalWordPositions
            };
        }

        // ========== SIMILARITY PAIRS FUNCTIONS ==========

        let allSimilarityPairs = [];
        let currentRespondentMatches = [];
        let currentRespondent = null;
        let currentMatchIndex = 0;

        // Progress helper functions
        function showProgress(title) {
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressMessage').textContent = 'Initializing...';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressPercent').textContent = '0%';
            document.getElementById('progressDetails').textContent = '';
            document.getElementById('cancelButton').disabled = false;
            document.getElementById('progressModal').style.display = 'block';
            cancelRequested = false;
        }

        function updateProgress(current, total, message, details = '') {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressMessage').textContent = message;
            document.getElementById('progressDetails').textContent = details;
        }

        function hideProgress() {
            document.getElementById('progressModal').style.display = 'none';
            analysisIsRunning = false;
            cancelRequested = false;
        }

        function cancelAnalysis() {
            cancelRequested = true;
            document.getElementById('progressMessage').textContent = 'Cancelling...';
            document.getElementById('cancelButton').disabled = true;
        }

        // Async sleep to allow UI updates
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ========== WEB WORKERS FOR PARALLEL PROCESSING ==========

        // Create worker from blob URL - keeps everything in a single file
        function createMetricsWorker() {
            const workerCode = `
                // ========== WORKER SCRIPT: All similarity calculation functions ==========

                function tokenize(text) {
                    return text.toLowerCase()
                        .replace(/[\\u2018\\u2019\\u201C\\u201D]/g, "'")
                        .replace(/[^\\w\\s']/g, ' ')
                        .split(/\\s+/)
                        .filter(w => w.length > 0);
                }

                function sentenceLengthVariance(text) {
                    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                    if (sentences.length === 0) return 0;
                    const lengths = sentences.map(s => s.trim().split(/\\s+/).length);
                    const mean = lengths.reduce((a,b) => a+b, 0) / lengths.length;
                    const variance = lengths.reduce((sum, len) => sum + Math.pow(len - mean, 2), 0) / lengths.length;
                    return variance;
                }

                function cosineSimilarity(text1, text2) {
                    const words1 = tokenize(text1);
                    const words2 = tokenize(text2);
                    const freq1 = {};
                    const freq2 = {};
                    const allWords = new Set([...words1, ...words2]);

                    words1.forEach(w => freq1[w] = (freq1[w] || 0) + 1);
                    words2.forEach(w => freq2[w] = (freq2[w] || 0) + 1);

                    let dotProduct = 0, mag1 = 0, mag2 = 0;
                    allWords.forEach(word => {
                        const v1 = freq1[word] || 0;
                        const v2 = freq2[word] || 0;
                        dotProduct += v1 * v2;
                        mag1 += v1 * v1;
                        mag2 += v2 * v2;
                    });

                    return (mag1 === 0 || mag2 === 0) ? 0 : dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));
                }

                function jaccardSimilarity(text1, text2) {
                    const set1 = new Set(tokenize(text1));
                    const set2 = new Set(tokenize(text2));
                    const intersection = new Set([...set1].filter(x => set2.has(x)));
                    const union = new Set([...set1, ...set2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function ngramSimilarity(text1, text2, n = 3) {
                    const getNgrams = (text) => {
                        const ngrams = new Set();
                        const clean = text.toLowerCase().replace(/[^\\w\\s]/g, '');
                        for (let i = 0; i <= clean.length - n; i++) {
                            ngrams.add(clean.substring(i, i + n));
                        }
                        return ngrams;
                    };

                    const ngrams1 = getNgrams(text1);
                    const ngrams2 = getNgrams(text2);
                    const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                    const union = new Set([...ngrams1, ...ngrams2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function ngram4Similarity(text1, text2) {
                    return ngramSimilarity(text1, text2, 4);
                }

                function ngram5Similarity(text1, text2) {
                    return ngramSimilarity(text1, text2, 5);
                }

                function ngramWithPunctuationSimilarity(text1, text2, n = 3) {
                    const getNgrams = (text) => {
                        const ngrams = new Set();
                        const clean = text.toLowerCase();
                        for (let i = 0; i <= clean.length - n; i++) {
                            ngrams.add(clean.substring(i, i + n));
                        }
                        return ngrams;
                    };

                    const ngrams1 = getNgrams(text1);
                    const ngrams2 = getNgrams(text2);
                    const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                    const union = new Set([...ngrams1, ...ngrams2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function wordNgramSimilarity(text1, text2, n = 3) {
                    const getWordNgrams = (text) => {
                        const words = tokenize(text);
                        const ngrams = new Set();
                        for (let i = 0; i <= words.length - n; i++) {
                            ngrams.add(words.slice(i, i + n).join(' ').toLowerCase());
                        }
                        return ngrams;
                    };

                    const ngrams1 = getWordNgrams(text1);
                    const ngrams2 = getWordNgrams(text2);
                    const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                    const union = new Set([...ngrams1, ...ngrams2]);
                    return union.size === 0 ? 0 : intersection.size / union.size;
                }

                function sentenceVarianceSimilarity(text1, text2) {
                    const var1 = sentenceLengthVariance(text1);
                    const var2 = sentenceLengthVariance(text2);
                    if (var1 === 0 && var2 === 0) return 1;
                    return 1 - Math.abs(var1 - var2) / Math.max(var1, var2, 1);
                }

                function wordCountSimilarity(text1, text2) {
                    const count1 = text1.trim().split(/\\s+/).length;
                    const count2 = text2.trim().split(/\\s+/).length;
                    if (count1 === 0 && count2 === 0) return 1;
                    return 1 - Math.abs(count1 - count2) / Math.max(count1, count2);
                }

                function avgSentenceLengthSimilarity(text1, text2) {
                    const sentences1 = text1.split(/[.!?]+/).filter(s => s.trim().length > 0);
                    const sentences2 = text2.split(/[.!?]+/).filter(s => s.trim().length > 0);

                    const avg1 = sentences1.reduce((sum, s) => sum + s.trim().split(/\\s+/).length, 0) / sentences1.length;
                    const avg2 = sentences2.reduce((sum, s) => sum + s.trim().split(/\\s+/).length, 0) / sentences2.length;

                    if (!avg1 || !avg2) return 0;
                    return 1 - Math.abs(avg1 - avg2) / Math.max(avg1, avg2);
                }

                function pronounDensitySimilarity(text1, text2) {
                    const pronouns = ['i', 'me', 'my', 'mine', 'myself', 'we', 'us', 'our', 'ours', 'ourselves',
                                    'you', 'your', 'yours', 'yourself', 'yourselves',
                                    'he', 'him', 'his', 'himself', 'she', 'her', 'hers', 'herself',
                                    'it', 'its', 'itself', 'they', 'them', 'their', 'theirs', 'themselves',
                                    'i\\'m', 'i\\'ve', 'i\\'d', 'i\\'ll', 'you\\'re', 'you\\'ve', 'you\\'d', 'you\\'ll',
                                    'he\\'s', 'he\\'d', 'he\\'ll', 'she\\'s', 'she\\'d', 'she\\'ll', 'it\\'s', 'it\\'d', 'it\\'ll',
                                    'we\\'re', 'we\\'ve', 'we\\'d', 'we\\'ll', 'they\\'re', 'they\\'ve', 'they\\'d', 'they\\'ll'];

                    const words1 = tokenize(text1);
                    const words2 = tokenize(text2);

                    const count1 = words1.filter(w => pronouns.includes(w.toLowerCase())).length;
                    const count2 = words2.filter(w => pronouns.includes(w.toLowerCase())).length;

                    const density1 = words1.length > 0 ? count1 / words1.length : 0;
                    const density2 = words2.length > 0 ? count2 / words2.length : 0;

                    if (density1 === 0 && density2 === 0) return 1;
                    const maxDensity = Math.max(density1, density2);
                    if (maxDensity === 0) return 1;
                    return 1 - Math.abs(density1 - density2) / maxDensity;
                }

                function transitionWordsSimilarity(text1, text2) {
                    const transitions = [
                        // Addition
                        'furthermore', 'moreover', 'additionally', 'also', 'besides', 'in addition', 'as well as',
                        // Example/Clarification
                        'for example', 'for instance', 'specifically', 'to illustrate', 'namely', 'in other words',
                        'that is', 'in particular', 'such as',
                        // Contrast/Opposition
                        'however', 'nevertheless', 'nonetheless', 'conversely', 'on the other hand', 'in contrast',
                        'yet', 'still', 'although', 'even though', 'despite', 'regardless', 'alternatively',
                        // Cause/Effect
                        'therefore', 'thus', 'consequently', 'as a result', 'accordingly', 'hence', 'for this reason',
                        'because of this', 'due to', 'since',
                        // Time/Sequence
                        'meanwhile', 'subsequently', 'finally', 'firstly', 'secondly', 'thirdly', 'then', 'next',
                        'afterward', 'previously', 'eventually', 'ultimately', 'later', 'initially', 'formerly',
                        // Conclusion/Summary
                        'in conclusion', 'to sum up', 'in summary', 'overall', 'all in all', 'in brief',
                        'to conclude', 'in the end',
                        // Emphasis
                        'indeed', 'in fact', 'certainly', 'undoubtedly', 'notably', 'especially', 'particularly',
                        'importantly', 'significantly',
                        // Comparison
                        'similarly', 'likewise', 'in the same way', 'equally', 'by comparison'
                    ];

                    const count1 = transitions.reduce((sum, word) =>
                        sum + (text1.toLowerCase().match(new RegExp('\\\\b' + word + '\\\\b', 'g')) || []).length, 0
                    );
                    const count2 = transitions.reduce((sum, word) =>
                        sum + (text2.toLowerCase().match(new RegExp('\\\\b' + word + '\\\\b', 'g')) || []).length, 0
                    );

                    const words1 = text1.trim().split(/\\s+/).length;
                    const words2 = text2.trim().split(/\\s+/).length;

                    const density1 = (count1 / words1) * 100;
                    const density2 = (count2 / words2) * 100;

                    if (density1 === 0 && density2 === 0) return 1;
                    return 1 - Math.abs(density1 - density2) / Math.max(density1, density2, 1);
                }

                function nerSimilarity(text1, text2) {
                    const extractEntities = (text) => {
                        const wordCount = tokenize(text).length;
                        const properNounPattern = /\\b[A-Z][A-Za-z]*(?:\\s+[A-Z][A-Za-z]*)*\\b/g;
                        const cleanText = text.replace(/([.!?;:,])/g, ' $1 ');
                        const matches = cleanText.match(properNounPattern) || [];
                        const commonWords = new Set(['The', 'This', 'That', 'These', 'Those', 'A', 'An', 'I', 'It', 'He', 'She', 'We', 'They']);

                        // Advanced filtering: Only include words that appear capitalized in mid-sentence positions
                        const sentenceBoundaryPattern = /[.!?]\\s+/g;
                        const sentences = text.split(sentenceBoundaryPattern);
                        const validEntities = new Set();

                        sentences.forEach(sentence => {
                            const sentenceMatches = sentence.match(/\\b[A-Z][A-Za-z]*(?:\\s+[A-Z][A-Za-z]*)*\\b/g) || [];
                            sentenceMatches.slice(1).forEach(match => {
                                if (match.length > 1 && !commonWords.has(match)) {
                                    validEntities.add(match);
                                }
                            });
                        });

                        const entities = matches.filter(m => validEntities.has(m));
                        const uniqueEntities = [...new Set(entities)];
                        const density = wordCount > 0 ? (uniqueEntities.length / wordCount) * 100 : 0;
                        return {
                            entities: new Set(uniqueEntities.map(e => e.toLowerCase())),
                            count: uniqueEntities.length,
                            density: density
                        };
                    };

                    const entities1 = extractEntities(text1);
                    const entities2 = extractEntities(text2);

                    const intersection = new Set([...entities1.entities].filter(x => entities2.entities.has(x)));
                    const union = new Set([...entities1.entities, ...entities2.entities]);
                    const contentSimilarity = union.size === 0 ? 0 : intersection.size / union.size;

                    const densitySimilarity = (() => {
                        if (entities1.density === 0 && entities2.density === 0) return 1;
                        const max = Math.max(entities1.density, entities2.density);
                        return max === 0 ? 0 : 1 - (Math.abs(entities1.density - entities2.density) / max);
                    })();

                    return (contentSimilarity * 0.6) + (densitySimilarity * 0.4);
                }

                // Levenshtein distance functions
                function levenshteinDistance(str1, str2) {
                    const len1 = str1.length;
                    const len2 = str2.length;
                    const matrix = [];

                    for (let i = 0; i <= len1; i++) {
                        matrix[i] = [i];
                    }
                    for (let j = 0; j <= len2; j++) {
                        matrix[0][j] = j;
                    }

                    for (let i = 1; i <= len1; i++) {
                        for (let j = 1; j <= len2; j++) {
                            if (str1[i - 1] === str2[j - 1]) {
                                matrix[i][j] = matrix[i - 1][j - 1];
                            } else {
                                matrix[i][j] = Math.min(
                                    matrix[i - 1][j - 1] + 1,
                                    matrix[i][j - 1] + 1,
                                    matrix[i - 1][j] + 1
                                );
                            }
                        }
                    }

                    return matrix[len1][len2];
                }

                function wordLevelLevenshteinDistance(phrase1, phrase2) {
                    const words1 = phrase1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);
                    const words2 = phrase2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);

                    const len1 = words1.length;
                    const len2 = words2.length;
                    const matrix = [];

                    for (let i = 0; i <= len1; i++) {
                        matrix[i] = [i];
                    }
                    for (let j = 0; j <= len2; j++) {
                        matrix[0][j] = j;
                    }

                    for (let i = 1; i <= len1; i++) {
                        for (let j = 1; j <= len2; j++) {
                            if (words1[i - 1] === words2[j - 1]) {
                                matrix[i][j] = matrix[i - 1][j - 1];
                            } else {
                                matrix[i][j] = Math.min(
                                    matrix[i - 1][j - 1] + 1,
                                    matrix[i][j - 1] + 1,
                                    matrix[i - 1][j] + 1
                                );
                            }
                        }
                    }

                    return matrix[len1][len2];
                }

                function fuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxDistance = 3) {
                    const words1 = text1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);
                    const words2 = text2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);

                    const ngrams1 = [];
                    const ngrams2 = [];

                    for (let i = 0; i <= words1.length - ngramSize; i++) {
                        ngrams1.push(words1.slice(i, i + ngramSize).join(' '));
                    }
                    for (let i = 0; i <= words2.length - ngramSize; i++) {
                        ngrams2.push(words2.slice(i, i + ngramSize).join(' '));
                    }

                    if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

                    const matches = new Set();

                    ngrams1.forEach((ng1, idx1) => {
                        ngrams2.forEach((ng2, idx2) => {
                            const distance = levenshteinDistance(ng1, ng2);
                            if (distance <= maxDistance) {
                                matches.add(\`\${idx1}-\${idx2}\`);
                            }
                        });
                    });

                    const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
                    return matches.size / totalNgrams;
                }

                function wordLevelFuzzyNgramSimilarity(text1, text2, ngramSize = 4, maxWordDistance = 1) {
                    const words1 = text1.toLowerCase().split(/\\s+/).filter(w => w.length > 0);
                    const words2 = text2.toLowerCase().split(/\\s+/).filter(w => w.length > 0);

                    const ngrams1 = [];
                    const ngrams2 = [];

                    for (let i = 0; i <= words1.length - ngramSize; i++) {
                        ngrams1.push(words1.slice(i, i + ngramSize));
                    }
                    for (let i = 0; i <= words2.length - ngramSize; i++) {
                        ngrams2.push(words2.slice(i, i + ngramSize));
                    }

                    if (ngrams1.length === 0 || ngrams2.length === 0) return 0;

                    const matches = new Set();

                    ngrams1.forEach((ng1, idx1) => {
                        ngrams2.forEach((ng2, idx2) => {
                            const distance = wordLevelLevenshteinDistance(ng1.join(' '), ng2.join(' '));
                            if (distance <= maxWordDistance) {
                                matches.add(\`\${idx1}-\${idx2}\`);
                            }
                        });
                    });

                    const totalNgrams = Math.max(ngrams1.length, ngrams2.length);
                    return matches.size / totalNgrams;
                }

                // Temporal Burstiness functions
                function calculateTemporalBurstiness(occurrences, totalWords) {
                    if (occurrences.length === 0 || totalWords === 0) return 0;

                    const f = occurrences.length;
                    const T = totalWords;
                    const sortedOccurrences = [...occurrences].sort((a, b) => a - b);

                    let maxArea = 0;
                    const steps = Math.min(200, T);
                    const dt = T / steps;

                    for (let k = 0; k < Math.min(f, 20); k++) {
                        const tk = sortedOccurrences[k];
                        let area = 0;
                        let occIdx = 0;

                        for (let i = 0; i < steps; i++) {
                            const t = i * dt;
                            while (occIdx < f && sortedOccurrences[occIdx] <= t) {
                                occIdx++;
                            }
                            const Ct = occIdx;
                            // Note: Cui et al. (2017) paper uses (k-1) with 1-based indexing;
                            // we use k with 0-based indexing (mathematically equivalent, verified)
                            const linearValue = (f / T) * (t - tk) + k;
                            const diff = Math.abs(Ct - linearValue);
                            area += diff * dt;
                        }

                        if (area > maxArea) {
                            maxArea = area;
                        }
                    }

                    const normalized = (2 * maxArea) / (f * T);
                    return Math.min(1, normalized);
                }

                function temporalBurstinessSimilarity(text1, text2) {
                    const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i',
                                               'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
                                               'this', 'but', 'his', 'by', 'from', 'they', 'we', 'say', 'her', 'she',
                                               'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their']);

                    const getWordPositions = (text) => {
                        const words = text.toLowerCase().match(/\\b[a-z]+\\b/g) || [];
                        const positions = {};
                        words.forEach((word, idx) => {
                            if (!stopWords.has(word) && word.length > 3) {
                                if (!positions[word]) positions[word] = [];
                                positions[word].push(idx);
                            }
                        });
                        return { positions, totalWords: words.length };
                    };

                    const data1 = getWordPositions(text1);
                    const data2 = getWordPositions(text2);

                    const commonWords = Object.keys(data1.positions).filter(word =>
                        data2.positions[word] &&
                        data1.positions[word].length >= 2 &&
                        data2.positions[word].length >= 2
                    );

                    if (commonWords.length === 0) return 0;

                    const burstinessScores = commonWords.map(word => {
                        const burst1 = calculateTemporalBurstiness(data1.positions[word], data1.totalWords);
                        const burst2 = calculateTemporalBurstiness(data2.positions[word], data2.totalWords);
                        return 1 - Math.abs(burst1 - burst2);
                    });

                    return burstinessScores.reduce((a, b) => a + b, 0) / burstinessScores.length;
                }

                // Calculate all metrics for given text pairs
                function calculateMetricsForPairs(pairs, selectedMetrics) {
                    return pairs.map(pair => {
                        const metrics = {};

                        selectedMetrics.forEach(metricId => {
                            switch(metricId) {
                                case 'cosine':
                                    metrics.cosine = cosineSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'jaccard':
                                    metrics.jaccard = jaccardSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'ngram':
                                    metrics.ngram = ngramSimilarity(pair.text1, pair.text2, 3);
                                    break;
                                case 'sentenceVariance':
                                    metrics.sentenceVariance = sentenceVarianceSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'wordCount':
                                    metrics.wordCount = wordCountSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'avgSentenceLength':
                                    metrics.avgSentenceLength = avgSentenceLengthSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'temporalBurstiness':
                                    metrics.temporalBurstiness = temporalBurstinessSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'pronounDensity':
                                    metrics.pronounDensity = pronounDensitySimilarity(pair.text1, pair.text2);
                                    break;
                                case 'transitionWords':
                                    metrics.transitionWords = transitionWordsSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'ngramPunctuation':
                                    metrics.ngramPunctuation = ngramWithPunctuationSimilarity(pair.text1, pair.text2, 3);
                                    break;
                                case 'wordNgram':
                                    metrics.wordNgram = wordNgramSimilarity(pair.text1, pair.text2, 3);
                                    break;
                                case 'ngram4':
                                    metrics.ngram4 = ngram4Similarity(pair.text1, pair.text2);
                                    break;
                                case 'ngram5':
                                    metrics.ngram5 = ngram5Similarity(pair.text1, pair.text2);
                                    break;
                                case 'ner':
                                    metrics.ner = nerSimilarity(pair.text1, pair.text2);
                                    break;
                                case 'fuzzyNgram3':
                                    metrics.fuzzyNgram3 = fuzzyNgramSimilarity(pair.text1, pair.text2, 3, 5);
                                    break;
                                case 'fuzzyNgram6':
                                    metrics.fuzzyNgram6 = fuzzyNgramSimilarity(pair.text1, pair.text2, 6, 13);
                                    break;
                                case 'wordLevelFuzzy3':
                                    metrics.wordLevelFuzzy3 = wordLevelFuzzyNgramSimilarity(pair.text1, pair.text2, 3, 1);
                                    break;
                                case 'wordLevelFuzzy5':
                                    metrics.wordLevelFuzzy5 = wordLevelFuzzyNgramSimilarity(pair.text1, pair.text2, 5, 2);
                                    break;
                            }
                        });

                        return {
                            id1: pair.id1,
                            id2: pair.id2,
                            text1: pair.text1,
                            text2: pair.text2,
                            metrics: metrics
                        };
                    });
                }

                // Worker message handler
                self.onmessage = function(e) {
                    const { pairs, selectedMetrics, workerId } = e.data;
                    const results = calculateMetricsForPairs(pairs, selectedMetrics);
                    self.postMessage({ workerId, results });
                };
            `;

            const blob = new Blob([workerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // ========== PARALLELIZED CALCULATION FUNCTION ==========

        async function calculateSimilarityPairs(responses) {
            if (analysisIsRunning) {
                alert('Analysis is already running. Please wait or cancel the current analysis.');
                return;
            }

            analysisIsRunning = true;
            allSimilarityPairs = [];
            const n = responses.length;
            const totalPairs = (n * (n - 1)) / 2;
            const selectedMetrics = getSelectedMetrics();

            showProgress('Analyzing Corpus');

            const startTime = Date.now();
            const pairMetrics = []; // Store all individual metrics for normalization

            // PHASE 1: Calculate all individual metrics using Web Workers (parallel)
            updateProgress(0, totalPairs, 'Phase 1: Calculating individual metrics (parallel)...', 'Initializing workers...');
            await sleep(10);

            // Determine number of workers (use logical CPU cores, max 8)
            const numWorkers = Math.min(navigator.hardwareConcurrency || 4, 8);
            updateProgress(0, totalPairs, 'Phase 1: Calculating individual metrics (parallel)...', `Using ${numWorkers} parallel workers...`);
            await sleep(10);

            // Build all pairs
            const allPairs = [];
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    allPairs.push({
                        id1: responses[i].id,
                        id2: responses[j].id,
                        text1: responses[i].text,
                        text2: responses[j].text
                    });
                }
            }

            // Split pairs into batches for each worker
            const batchSize = Math.ceil(allPairs.length / numWorkers);
            const batches = [];
            for (let i = 0; i < numWorkers; i++) {
                const start = i * batchSize;
                const end = Math.min(start + batchSize, allPairs.length);
                if (start < allPairs.length) {
                    batches.push(allPairs.slice(start, end));
                }
            }

            // Create workers and track progress
            const workers = [];
            const workerPromises = [];
            let completedPairs = 0;

            for (let i = 0; i < batches.length; i++) {
                const worker = createMetricsWorker();
                workers.push(worker);

                const promise = new Promise((resolve, reject) => {
                    worker.onmessage = (e) => {
                        const { workerId, results } = e.data;
                        completedPairs += results.length;

                        // Update progress
                        const elapsed = (Date.now() - startTime) / 1000;
                        const rate = completedPairs / elapsed;
                        const remaining = (totalPairs - completedPairs) / rate;
                        const eta = remaining > 60 ? `${Math.round(remaining / 60)}m ${Math.round(remaining % 60)}s` : `${Math.round(remaining)}s`;

                        updateProgress(
                            completedPairs,
                            totalPairs,
                            `Phase 1: Processing with ${numWorkers} workers (${completedPairs}/${totalPairs} pairs)`,
                            `Elapsed: ${Math.round(elapsed)}s | Est. remaining: ${eta} | Rate: ${Math.round(rate)} pairs/sec`
                        );

                        resolve(results);
                    };

                    worker.onerror = (error) => {
                        console.error('Worker error:', error);
                        reject(error);
                    };

                    // Check for cancellation before starting
                    if (cancelRequested) {
                        worker.terminate();
                        reject(new Error('Cancelled'));
                        return;
                    }

                    // Send work to this worker
                    worker.postMessage({
                        pairs: batches[i],
                        selectedMetrics: selectedMetrics,
                        workerId: i
                    });
                });

                workerPromises.push(promise);
            }

            // Wait for all workers to complete
            try {
                const allResults = await Promise.all(workerPromises);

                // Check for cancellation
                if (cancelRequested) {
                    workers.forEach(w => w.terminate());
                    hideProgress();
                    analysisIsRunning = false;
                    cancelRequested = false;
                    alert('Analysis cancelled by user.');
                    return;
                }

                // Merge results from all workers
                allResults.forEach(results => {
                    pairMetrics.push(...results);
                });

                // Clean up workers
                workers.forEach(w => w.terminate());

            } catch (error) {
                console.error('Worker execution failed:', error);
                workers.forEach(w => w.terminate());

                if (cancelRequested) {
                    hideProgress();
                    analysisIsRunning = false;
                    cancelRequested = false;
                    alert('Analysis cancelled by user.');
                    return;
                }

                // Fall back to non-parallel processing
                alert('Parallel processing failed. Falling back to single-threaded mode.');
                hideProgress();
                analysisIsRunning = false;
                cancelRequested = false;
                return;
            }

            // PHASE 2: Calculate normalization parameters (min/max for each metric)
            updateProgress(totalPairs, totalPairs, 'Phase 2: Calculating normalization parameters...', 'Please wait...');
            await sleep(0);

            metricNormalizationParams = {};
            selectedMetrics.forEach(metricId => {
                const values = pairMetrics.map(pair => pair.metrics[metricId]).filter(v => v !== undefined);
                if (values.length > 0) {
                    metricNormalizationParams[metricId] = {
                        min: Math.min(...values),
                        max: Math.max(...values)
                    };
                }
            });

            // PHASE 3: Calculate combined normalized similarities
            updateProgress(totalPairs, totalPairs, 'Phase 3: Combining normalized metrics...', 'Please wait...');
            await sleep(0);

            const weights = getMetricWeights();
            pairMetrics.forEach(pair => {
                let weightedSum = 0;
                let totalWeight = 0;

                selectedMetrics.forEach(metric => {
                    if (pair.metrics[metric] !== undefined) {
                        const weight = weights[metric] || 1.0;
                        const normalizedScore = normalizeMetric(pair.metrics[metric], metric);
                        weightedSum += normalizedScore * weight;
                        totalWeight += weight;
                    }
                });

                const combinedSimilarity = totalWeight > 0 ? weightedSum / totalWeight : 0;

                allSimilarityPairs.push({
                    id1: pair.id1,
                    id2: pair.id2,
                    text1: pair.text1,
                    text2: pair.text2,
                    similarity: combinedSimilarity
                });
            });

            // Sort by similarity (highest first)
            updateProgress(totalPairs, totalPairs, 'Sorting results...', 'Please wait...');
            await sleep(0);
            allSimilarityPairs.sort((a, b) => b.similarity - a.similarity);

            console.log('âœ“ Calculated', allSimilarityPairs.length, 'similarity pairs');

            hideProgress();
            analysisIsRunning = false;
            cancelRequested = false;
        }

        function updateThreshold(value) {
            document.getElementById('thresholdDisplay').textContent = value;

            const threshold = parseFloat(value);
            const filteredPairs = allSimilarityPairs.filter(p => p.similarity >= threshold);

            // Update pair count display
            document.getElementById('pairCountDisplay').textContent =
                `${filteredPairs.length} pairs above threshold`;

            renderSimilarityPairs(filteredPairs);
            renderFlaggedRespondents(filteredPairs);
            saveSession();
        }

        function renderSimilarityPairs(pairs) {
            const container = document.getElementById('similarityPairsList');

            if (pairs.length === 0) {
                container.innerHTML = `
                    <p style="color: #999; text-align: center; padding: 40px;">
                        No pairs found above the current threshold. Try lowering the threshold.
                    </p>
                `;
                return;
            }

            container.innerHTML = pairs.map(pair => {
                const scoreClass = pair.similarity >= 0.85 ? 'similarity-high' :
                                   pair.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';

                const preview = pair.text1.substring(0, 200) + (pair.text1.length > 200 ? '...' : '');

                return `
                    <div class="similarity-pair-item" onclick='showPairComparison(${JSON.stringify(pair).replace(/'/g, "\\'")} )'>
                        <div class="pair-header-row">
                            <span class="pair-ids">Respondent ${pair.id1} â†” Respondent ${pair.id2}</span>
                            <span class="similarity-badge ${scoreClass}">${(pair.similarity * 100).toFixed(1)}%</span>
                        </div>
                        <div class="response-preview">${escapeHtml(preview)}</div>
                    </div>
                `;
            }).join('');
        }

        function renderFlaggedRespondents(pairs) {
            const panel = document.getElementById('frequentRespondentsPanel');
            const container = document.getElementById('frequentRespondentsList');

            if (pairs.length === 0) {
                panel.style.display = 'none';
                return;
            }

            // Count how many times each respondent appears
            const counts = {};
            const matches = {};

            pairs.forEach(pair => {
                // Count for id1
                if (!counts[pair.id1]) {
                    counts[pair.id1] = 0;
                    matches[pair.id1] = [];
                }
                counts[pair.id1]++;
                matches[pair.id1].push({ id: pair.id2, similarity: pair.similarity });

                // Count for id2
                if (!counts[pair.id2]) {
                    counts[pair.id2] = 0;
                    matches[pair.id2] = [];
                }
                counts[pair.id2]++;
                matches[pair.id2].push({ id: pair.id1, similarity: pair.similarity });
            });

            // Filter to respondents in 2+ pairs
            const flagged = Object.entries(counts)
                .filter(([id, count]) => count >= 2)
                .map(([id, count]) => ({ id, count, matches: matches[id] }))
                .sort((a, b) => b.count - a.count);

            if (flagged.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';

            container.innerHTML = flagged.map(respondent => {
                // Sort matches by similarity
                respondent.matches.sort((a, b) => b.similarity - a.similarity);

                // Escape single quotes in ID for onclick handler
                const escapedId = String(respondent.id).replace(/'/g, "\\'");

                return `
                    <div class="flagged-respondent-item" onclick="showFlaggedRespondentMatches('${escapedId}')">
                        <div class="flagged-header">
                            <strong style="color: #2c3e50; font-size: 15px;">Respondent ${respondent.id}</strong>
                            <span class="flag-count-badge">${respondent.count} matches</span>
                        </div>
                        <div class="match-chips">
                            ${respondent.matches.map(m => {
                                const scoreClass = m.similarity >= 0.85 ? 'similarity-high' :
                                                   m.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';
                                return `<span class="match-chip ${scoreClass}">
                                    #${m.id} (${(m.similarity * 100).toFixed(0)}%)
                                </span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');

            // Also render least flagged respondents
            renderLeastFlaggedRespondents();
        }

        function renderLeastFlaggedRespondents() {
            const container = document.getElementById('infrequentRespondentsList');

            if (!allSimilarityPairs || allSimilarityPairs.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center;">No data available</p>';
                return;
            }

            // Calculate average similarity for each respondent
            const respondentScores = {};
            const respondentPairs = {};

            allSimilarityPairs.forEach(pair => {
                // Track for id1
                if (!respondentScores[pair.id1]) {
                    respondentScores[pair.id1] = [];
                    respondentPairs[pair.id1] = [];
                }
                respondentScores[pair.id1].push(pair.similarity);
                respondentPairs[pair.id1].push({ id: pair.id2, similarity: pair.similarity });

                // Track for id2
                if (!respondentScores[pair.id2]) {
                    respondentScores[pair.id2] = [];
                    respondentPairs[pair.id2] = [];
                }
                respondentScores[pair.id2].push(pair.similarity);
                respondentPairs[pair.id2].push({ id: pair.id1, similarity: pair.similarity });
            });

            // Calculate average and sort by lowest
            const leastFlagged = Object.entries(respondentScores)
                .map(([id, scores]) => ({
                    id,
                    avgSimilarity: scores.reduce((a, b) => a + b, 0) / scores.length,
                    count: scores.length,
                    pairs: respondentPairs[id]
                }))
                .sort((a, b) => a.avgSimilarity - b.avgSimilarity)
                .slice(0, 10); // Show top 10 least similar

            container.innerHTML = leastFlagged.map(respondent => {
                // Sort pairs by similarity (lowest first for this view)
                respondent.pairs.sort((a, b) => a.similarity - b.similarity);

                const escapedId = String(respondent.id).replace(/'/g, "\\'");
                const avgPercent = (respondent.avgSimilarity * 100).toFixed(1);

                return `
                    <div class="flagged-respondent-item" onclick="showFlaggedRespondentMatches('${escapedId}', true)">
                        <div class="flagged-header">
                            <strong style="color: #2c3e50; font-size: 15px;">Respondent ${respondent.id}</strong>
                            <span class="flag-count-badge" style="background: #27ae60;">Avg: ${avgPercent}%</span>
                        </div>
                        <div class="match-chips">
                            ${respondent.pairs.slice(0, 5).map(m => {
                                const scoreClass = m.similarity >= 0.85 ? 'similarity-high' :
                                                   m.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';
                                return `<span class="match-chip ${scoreClass}">
                                    #${m.id} (${(m.similarity * 100).toFixed(0)}%)
                                </span>`;
                            }).join('')}
                            ${respondent.pairs.length > 5 ? `<span style="color: #999; font-size: 12px;">+${respondent.pairs.length - 5} more</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function switchFlaggedTab(tab) {
            const mostTab = document.getElementById('mostFlaggedTab');
            const leastTab = document.getElementById('leastFlaggedTab');
            const mostContent = document.getElementById('mostFlaggedContent');
            const leastContent = document.getElementById('leastFlaggedContent');

            if (tab === 'most') {
                mostTab.style.borderBottom = '3px solid #57068C';
                mostTab.style.color = '#57068C';
                leastTab.style.borderBottom = '3px solid transparent';
                leastTab.style.color = '#666';
                mostContent.style.display = 'block';
                leastContent.style.display = 'none';
            } else {
                leastTab.style.borderBottom = '3px solid #57068C';
                leastTab.style.color = '#57068C';
                mostTab.style.borderBottom = '3px solid transparent';
                mostTab.style.color = '#666';
                leastContent.style.display = 'block';
                mostContent.style.display = 'none';
            }
        }

        function togglePanelMode() {
            const toggle = document.getElementById('panelModeToggle');
            const slider = document.getElementById('toggleSlider');
            const track = document.getElementById('toggleTrack');
            const flaggedLabel = document.getElementById('flaggedLabel');
            const patternLabel = document.getElementById('patternLabel');
            const info = document.getElementById('panelModeInfo');
            const flaggedContent = document.getElementById('flaggedRespondentsContent');
            const patternContent = document.getElementById('patternSearchContent');
            const similarityPairsPanel = document.getElementById('similarityPairsPanel');

            if (toggle.checked) {
                // Switch to Pattern Search mode
                slider.style.transform = 'translateX(24px)';
                track.style.background = 'rgba(76, 175, 80, 0.5)';
                flaggedLabel.style.color = 'rgba(255,255,255,0.5)';
                flaggedLabel.style.opacity = '0.6';
                patternLabel.style.color = 'white';
                patternLabel.style.opacity = '1';
                info.textContent = 'Find word correlations and patterns';
                flaggedContent.style.display = 'none';
                patternContent.style.display = 'block';
                similarityPairsPanel.style.display = 'none';
            } else {
                // Switch back to Flagged Respondents mode
                slider.style.transform = 'translateX(0)';
                track.style.background = 'rgba(255,255,255,0.3)';
                flaggedLabel.style.color = 'white';
                flaggedLabel.style.opacity = '1';
                patternLabel.style.color = 'rgba(255,255,255,0.5)';
                patternLabel.style.opacity = '0.6';
                info.textContent = 'Analysis by similarity patterns';
                flaggedContent.style.display = 'block';
                patternContent.style.display = 'none';
                similarityPairsPanel.style.display = 'block';
            }

            // Save panel mode state
            saveSession();
        }

        function showFlaggedRespondentMatches(respondentId, ignoreThreshold = false) {
            console.log('showFlaggedRespondentMatches called with ID:', respondentId);

            // Show loading spinner
            const spinner = document.getElementById('loadingSpinner');
            spinner.style.display = 'flex';

            // Use setTimeout to let the spinner render before processing
            setTimeout(() => {
                try {
                    // Find the respondent's full data
                    const responses = analysisResults.responses;
                    console.log('Available responses:', responses.map(r => r.id));

                    currentRespondent = responses.find(r => r.id === respondentId);
                    console.log('Found respondent:', currentRespondent);

                    if (!currentRespondent) {
                        console.error('Respondent not found with ID:', respondentId);
                        spinner.style.display = 'none';
                        return;
                    }

                    // Find all pairs involving this respondent
                    const threshold = parseFloat(document.getElementById('similarityThreshold').value);
                    currentRespondentMatches = allSimilarityPairs
                        .filter(p => {
                            const involvesRespondent = (p.id1 === respondentId || p.id2 === respondentId);
                            // For least flagged, show all pairs; for most flagged, respect threshold
                            return involvesRespondent && (ignoreThreshold || p.similarity >= threshold);
                        })
                        .map(p => {
                            // Normalize so currentRespondent is always the first one
                            if (p.id1 === respondentId) {
                                return { id: p.id2, text: p.text2, similarity: p.similarity };
                            } else {
                                return { id: p.id1, text: p.text1, similarity: p.similarity };
                            }
                        })
                        .sort((a, b) => {
                            // Least flagged: sort lowest to highest (to match list order)
                            // Most flagged: sort highest to lowest
                            return ignoreThreshold ? a.similarity - b.similarity : b.similarity - a.similarity;
                        });

                    if (currentRespondentMatches.length === 0) {
                        spinner.style.display = 'none';
                        return;
                    }

                    currentMatchIndex = 0;
                    renderCurrentMatch();

                    // Hide spinner after rendering
                    spinner.style.display = 'none';
                } catch (error) {
                    console.error('Error in showFlaggedRespondentMatches:', error);
                    spinner.style.display = 'none';
                }
            }, 10); // Small delay to ensure spinner shows
        }

        function renderCurrentMatch() {
            if (!currentRespondent || currentRespondentMatches.length === 0) return;

            const modal = document.getElementById('comparisonModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');

            const match = currentRespondentMatches[currentMatchIndex];
            const sharedPhrases = getCommonNgrams(currentRespondent.text, match.text);

            const scoreClass = match.similarity >= 0.85 ? 'similarity-high' :
                               match.similarity >= 0.70 ? 'similarity-medium' : 'similarity-low';

            // Highlight shared phrases
            const highlighted1 = highlightSharedPhrases(currentRespondent.text, sharedPhrases);
            const highlighted2 = highlightSharedPhrases(match.text, sharedPhrases);

            title.textContent = `Respondent ${currentRespondent.id} vs ${match.id} (${currentMatchIndex + 1} of ${currentRespondentMatches.length})`;

            body.innerHTML = `
                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px;">
                    ${generateMetricBadges(currentRespondent.text, match.text, match.similarity, currentRespondent.id, match.id)}
                </div>

                <div class="comparison-grid">
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${currentRespondent.id}</div>
                        <div class="comparison-text">${highlighted1}</div>
                    </div>
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${match.id}</div>
                        <div class="comparison-text">${highlighted2}</div>
                    </div>
                </div>

                ${sharedPhrases.length > 0 ? `
                    <div class="shared-phrases-box">
                        <h4>Shared Phrases (${sharedPhrases.length})
                            <span style="font-size: 11px; color: #666; font-weight: normal;">
                                - Yellow = exact, Orange = fuzzy (paraphrase)
                            </span>
                        </h4>
                        ${sharedPhrases.slice(0, 15).map(p =>
                            `<span class="phrase-chip" style="background: ${p.type === 'exact' ? '#ffeb3b' : '#ffe0b2'}; border: 1px solid ${p.type === 'exact' ? '#ffc107' : '#ff9800'};">
                                "${escapeHtml(p.text)}" (${p.length} words${p.type === 'fuzzy' ? ', ~' : ''})
                            </span>`
                        ).join('')}
                        ${sharedPhrases.length > 15 ? `<span class="phrase-chip">+${sharedPhrases.length - 15} more</span>` : ''}
                    </div>
                ` : ''}

                <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                    <button onclick="prevMatch()" ${currentMatchIndex === 0 ? 'disabled' : ''}
                        style="padding: 10px 30px; background: ${currentMatchIndex === 0 ? '#ccc' : '#57068C'}; color: white; border: none; border-radius: 5px; cursor: ${currentMatchIndex === 0 ? 'not-allowed' : 'pointer'}; font-weight: 600; font-size: 14px;">
                        â† Previous
                    </button>
                    <button onclick="nextMatch()" ${currentMatchIndex === currentRespondentMatches.length - 1 ? 'disabled' : ''}
                        style="padding: 10px 30px; background: ${currentMatchIndex === currentRespondentMatches.length - 1 ? '#ccc' : '#57068C'}; color: white; border: none; border-radius: 5px; cursor: ${currentMatchIndex === currentRespondentMatches.length - 1 ? 'not-allowed' : 'pointer'}; font-weight: 600; font-size: 14px;">
                        Next â†’
                    </button>
                </div>
            `;

            modal.style.display = 'block';
        }

        function prevMatch() {
            if (currentMatchIndex > 0) {
                currentMatchIndex--;
                renderCurrentMatch();
            }
        }

        function nextMatch() {
            if (currentMatchIndex < currentRespondentMatches.length - 1) {
                currentMatchIndex++;
                renderCurrentMatch();
            }
        }

        function showPairComparison(pair) {
            const modal = document.getElementById('comparisonModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');

            // Clear any stored comparison pair (we're viewing a fresh comparison)
            window.currentComparisonPair = null;

            title.textContent = `Respondent ${pair.id1} vs Respondent ${pair.id2}`;

            // Find shared phrases
            const sharedPhrases = getCommonNgrams(pair.text1, pair.text2);

            // Highlight shared phrases in both texts
            const highlighted1 = highlightSharedPhrases(pair.text1, sharedPhrases);
            const highlighted2 = highlightSharedPhrases(pair.text2, sharedPhrases);

            body.innerHTML = `
                <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                    ${generateMetricBadges(pair.text1, pair.text2, pair.similarity, pair.id1, pair.id2)}
                </div>

                <div class="comparison-grid">
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${pair.id1}</div>
                        <div class="comparison-text">${highlighted1}</div>
                    </div>
                    <div class="comparison-box">
                        <div class="comparison-header">Respondent ${pair.id2}</div>
                        <div class="comparison-text">${highlighted2}</div>
                    </div>
                </div>

                ${sharedPhrases.length > 0 ? `
                    <div class="shared-phrases-box">
                        <h4>Shared Phrases (${sharedPhrases.length})
                            <span style="font-size: 11px; color: #666; font-weight: normal;">
                                - Yellow = exact, Orange = fuzzy (paraphrase)
                            </span>
                        </h4>
                        ${sharedPhrases.slice(0, 15).map(p =>
                            `<span class="phrase-chip" style="background: ${p.type === 'exact' ? '#ffeb3b' : '#ffe0b2'}; border: 1px solid ${p.type === 'exact' ? '#ffc107' : '#ff9800'};">
                                "${escapeHtml(p.text)}" (${p.length} words${p.type === 'fuzzy' ? ', ~' : ''})
                            </span>`
                        ).join('')}
                        ${sharedPhrases.length > 15 ? `<span class="phrase-chip">+${sharedPhrases.length - 15} more</span>` : ''}
                    </div>
                ` : ''}
            `;

            modal.style.display = 'block';
        }

        function getCommonNgrams(text1, text2) {
            // Split and strip punctuation from each word
            const words1 = text1.toLowerCase().split(/\s+/)
                .map(w => w.replace(/[^\w]/g, ''))
                .filter(w => w.length > 0);
            const words2 = text2.toLowerCase().split(/\s+/)
                .map(w => w.replace(/[^\w]/g, ''))
                .filter(w => w.length > 0);

            const matches = [];

            // Find exact matching n-grams from 2 to 10 words
            for (let n = 2; n <= Math.min(10, words1.length, words2.length); n++) {
                const ngrams1 = new Set();
                for (let i = 0; i <= words1.length - n; i++) {
                    ngrams1.add(words1.slice(i, i + n).join(' '));
                }

                for (let i = 0; i <= words2.length - n; i++) {
                    const ngram = words2.slice(i, i + n).join(' ');
                    if (ngrams1.has(ngram)) {
                        matches.push({ text: ngram, length: n, type: 'exact' });
                    }
                }
            }

            // Find fuzzy matches using word-level Levenshtein distance
            // 3-word phrases with â‰¤1 word difference
            for (let i = 0; i <= words1.length - 3; i++) {
                const ngram1 = words1.slice(i, i + 3);
                for (let j = 0; j <= words2.length - 3; j++) {
                    const ngram2 = words2.slice(j, j + 3);
                    const distance = wordLevelLevenshteinDistance(ngram1.join(' '), ngram2.join(' '));
                    if (distance === 1) {  // Exactly 1 word different (fuzzy match)
                        const text = ngram2.join(' ');
                        matches.push({ text: text, length: 3, type: 'fuzzy' });
                    }
                }
            }

            // 5-word phrases with â‰¤2 word differences
            for (let i = 0; i <= words1.length - 5; i++) {
                const ngram1 = words1.slice(i, i + 5);
                for (let j = 0; j <= words2.length - 5; j++) {
                    const ngram2 = words2.slice(j, j + 5);
                    const distance = wordLevelLevenshteinDistance(ngram1.join(' '), ngram2.join(' '));
                    if (distance >= 1 && distance <= 2) {  // 1-2 words different (fuzzy match)
                        const text = ngram2.join(' ');
                        matches.push({ text: text, length: 5, type: 'fuzzy' });
                    }
                }
            }

            // Remove duplicates and substrings (keep longer/exact matches first)
            matches.sort((a, b) => {
                // Prioritize exact matches over fuzzy
                if (a.type === 'exact' && b.type !== 'exact') return -1;
                if (a.type !== 'exact' && b.type === 'exact') return 1;
                // Then sort by length
                return b.length - a.length;
            });

            const filtered = [];
            const seen = new Set();

            matches.forEach(match => {
                let isSubstring = false;
                for (const existing of filtered) {
                    if (existing.text.includes(match.text)) {
                        isSubstring = true;
                        break;
                    }
                }
                if (!isSubstring && !seen.has(match.text)) {
                    seen.add(match.text);
                    filtered.push(match);
                }
            });

            return filtered;
        }

        function highlightSharedPhrases(text, phrases) {
            if (!phrases || phrases.length === 0) return escapeHtml(text);

            let highlighted = text;

            // Sort by length (longest first) to avoid partial matches, prioritize exact over fuzzy
            const sorted = [...phrases].sort((a, b) => {
                if (a.type === 'exact' && b.type !== 'exact') return -1;
                if (a.type !== 'exact' && b.type === 'exact') return 1;
                return b.text.length - a.text.length;
            });

            sorted.forEach(phrase => {
                const highlightClass = phrase.type === 'exact' ? 'highlight-exact' : 'highlight-fuzzy';
                const regex = new RegExp(phrase.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                highlighted = highlighted.replace(regex, match => `<mark class="${highlightClass}">${match}</mark>`);
            });

            return highlighted;
        }

        function closeModal() {
            document.getElementById('comparisonModal').style.display = 'none';
        }

        function closeCalculationModal() {
            document.getElementById('calculationModal').style.display = 'none';
        }

        function closeModalAndReturnToComparison() {
            // If we have a stored comparison pair, return to it
            if (window.currentComparisonPair) {
                const pair = window.currentComparisonPair;
                // Find the full pair object from similarityPairs
                const fullPair = similarityPairs.find(p =>
                    (p.id1 === pair.id1 && p.id2 === pair.id2) ||
                    (p.id1 === pair.id2 && p.id2 === pair.id1)
                );

                if (fullPair) {
                    showPairComparison(fullPair);
                } else {
                    // Fallback: just close the modal
                    closeModal();
                }

                // Clear the stored pair
                window.currentComparisonPair = null;
            } else {
                // No stored pair, just close
                closeModal();
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('comparisonModal');
            if (modal.style.display !== 'block') return;

            if (e.key === 'Escape') {
                closeModal();
            } else if (e.key === 'ArrowLeft') {
                prevMatch();
            } else if (e.key === 'ArrowRight') {
                nextMatch();
            }
        });

        // ========== TAB SWITCHING ==========

        function switchTab(tabName) {
            // Only 'pairs' tab exists now
            if (tabName === 'pairs') {
                document.getElementById('pairs-tab').classList.add('active');
                document.querySelector('.tab-button').classList.add('active');
            }
        }

        // ========== PATTERN ANALYSIS ==========

        let patternAnalysisResults = null;

        function updateMinLiftDisplay(value) {
            document.getElementById('minLiftDisplay').textContent = value;
            if (patternAnalysisResults) {
                updatePatternAnalysis();
            }
        }

        function updateMinSupportDisplay(value) {
            document.getElementById('minSupportDisplay').textContent = value;
            if (patternAnalysisResults) {
                updatePatternAnalysis();
            }
        }

        function updatePatternAnalysis() {
            if (patternAnalysisResults) {
                renderPatternResults(patternAnalysisResults);
            }
        }

        function analyzePatterns() {
            if (!csvData || csvData.length === 0) {
                alert('Please upload and analyze a CSV file first.');
                return;
            }

            const columnSelect = document.getElementById('columnSelect');
            const selectedColumn = columnSelect.value;

            if (!selectedColumn) {
                alert('Please select a question column first.');
                return;
            }

            // Show loading state
            const container = document.getElementById('patternResultsContainer');
            container.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #999;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 48px; margin-bottom: 15px;"></i>
                    <p>Analyzing patterns in responses...</p>
                </div>
            `;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    const patterns = findCorrelatedPatterns(selectedColumn);
                    patternAnalysisResults = patterns;
                    renderPatternResults(patterns);
                } catch (error) {
                    console.error('Error analyzing patterns:', error);
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #e74c3c;">
                            <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 15px;"></i>
                            <p>Error analyzing patterns. Please try again.</p>
                        </div>
                    `;
                }
            }, 100);
        }

        function findCorrelatedPatterns(column) {
            // Extract all responses
            const responses = csvData.map(row => {
                const text = row[column] || '';
                return text.toString().toLowerCase();
            }).filter(text => text.length > 0);

            if (responses.length < 3) {
                return [];
            }

            // Tokenize and normalize all responses
            const normalizedResponses = responses.map(text => {
                // Clean and normalize text
                const cleaned = text.toLowerCase().replace(/[^\w\s]/g, ' ');
                return cleaned
                    .split(/\s+/)
                    .filter(word => word.length > 3) // Filter short words
                    .filter(word => !isStopWord(word));
            });

            // Build term frequency maps for each response
            const termPresence = new Map(); // term -> array of response indices where it appears

            normalizedResponses.forEach((tokens, idx) => {
                const uniqueTokens = [...new Set(tokens)];
                uniqueTokens.forEach(term => {
                    if (!termPresence.has(term)) {
                        termPresence.set(term, []);
                    }
                    termPresence.get(term).push(idx);
                });
            });

            // Also extract 2-3 word phrases
            const phrasePresence = new Map();

            normalizedResponses.forEach((tokens, idx) => {
                const seenPhrases = new Set(); // Track phrases seen in this response

                // 2-word phrases
                for (let i = 0; i < tokens.length - 1; i++) {
                    const phrase = tokens[i] + ' ' + tokens[i + 1];
                    if (!seenPhrases.has(phrase)) {
                        seenPhrases.add(phrase);
                        if (!phrasePresence.has(phrase)) {
                            phrasePresence.set(phrase, []);
                        }
                        phrasePresence.get(phrase).push(idx);
                    }
                }

                // 3-word phrases
                for (let i = 0; i < tokens.length - 2; i++) {
                    const phrase = tokens[i] + ' ' + tokens[i + 1] + ' ' + tokens[i + 2];
                    if (!seenPhrases.has(phrase)) {
                        seenPhrases.add(phrase);
                        if (!phrasePresence.has(phrase)) {
                            phrasePresence.set(phrase, []);
                        }
                        phrasePresence.get(phrase).push(idx);
                    }
                }
            });

            // Merge both maps
            const allTerms = new Map([...termPresence, ...phrasePresence]);

            console.log('Pattern Analysis Debug:');
            console.log('- Total responses:', responses.length);
            console.log('- Total unique terms:', termPresence.size);
            console.log('- Total unique phrases:', phrasePresence.size);
            console.log('- Combined terms:', allTerms.size);

            // Calculate patterns (pairs, trios, quartets)
            const patterns = [];
            const patternSize = document.getElementById('patternSizeSelect').value;
            const sizes = patternSize === 'all' ? [2, 3, 4] : [parseInt(patternSize)];

            const termArray = Array.from(allTerms.keys());
            const totalResponses = responses.length;

            console.log('- Analyzing pattern sizes:', sizes);
            console.log('- Terms to analyze:', termArray.length);

            // Generate combinations
            for (const size of sizes) {
                if (size === 2) {
                    // Pairs
                    for (let i = 0; i < termArray.length; i++) {
                        for (let j = i + 1; j < termArray.length; j++) {
                            const term1 = termArray[i];
                            const term2 = termArray[j];

                            const indices1 = new Set(allTerms.get(term1));
                            const indices2 = new Set(allTerms.get(term2));

                            const intersection = new Set([...indices1].filter(x => indices2.has(x)));
                            const support = intersection.size;

                            if (support >= 2) {
                                const prob1 = indices1.size / totalResponses;
                                const prob2 = indices2.size / totalResponses;
                                const probBoth = support / totalResponses;
                                const expectedProb = prob1 * prob2;
                                const lift = expectedProb > 0 ? probBoth / expectedProb : 0;

                                if (lift >= 1.5) {
                                    patterns.push({
                                        terms: [term1, term2],
                                        support: support,
                                        lift: lift,
                                        confidence: probBoth / prob1,
                                        respondentIndices: Array.from(intersection)
                                    });
                                }
                            }
                        }
                    }
                } else if (size === 3) {
                    // Trios (sample to avoid performance issues)
                    const maxTrios = Math.min(5000, termArray.length * 50);
                    let trioCount = 0;

                    for (let i = 0; i < termArray.length && trioCount < maxTrios; i++) {
                        for (let j = i + 1; j < termArray.length && trioCount < maxTrios; j++) {
                            for (let k = j + 1; k < Math.min(termArray.length, j + 20) && trioCount < maxTrios; k++) {
                                trioCount++;
                                const term1 = termArray[i];
                                const term2 = termArray[j];
                                const term3 = termArray[k];

                                const indices1 = new Set(allTerms.get(term1));
                                const indices2 = new Set(allTerms.get(term2));
                                const indices3 = new Set(allTerms.get(term3));

                                const intersection = new Set(
                                    [...indices1].filter(x => indices2.has(x) && indices3.has(x))
                                );
                                const support = intersection.size;

                                if (support >= 2) {
                                    const prob1 = indices1.size / totalResponses;
                                    const prob2 = indices2.size / totalResponses;
                                    const prob3 = indices3.size / totalResponses;
                                    const probAll = support / totalResponses;
                                    const expectedProb = prob1 * prob2 * prob3;
                                    const lift = expectedProb > 0 ? probAll / expectedProb : 0;

                                    if (lift >= 1.5) {
                                        patterns.push({
                                            terms: [term1, term2, term3],
                                            support: support,
                                            lift: lift,
                                            confidence: probAll / prob1,
                                            respondentIndices: Array.from(intersection)
                                        });
                                    }
                                }
                            }
                        }
                    }
                } else if (size === 4) {
                    // Quartets (very limited sampling)
                    const maxQuartets = Math.min(2000, termArray.length * 10);
                    let quartetCount = 0;

                    for (let i = 0; i < termArray.length && quartetCount < maxQuartets; i++) {
                        for (let j = i + 1; j < termArray.length && quartetCount < maxQuartets; j++) {
                            for (let k = j + 1; k < Math.min(termArray.length, j + 10) && quartetCount < maxQuartets; k++) {
                                for (let l = k + 1; l < Math.min(termArray.length, k + 10) && quartetCount < maxQuartets; l++) {
                                    quartetCount++;
                                    const term1 = termArray[i];
                                    const term2 = termArray[j];
                                    const term3 = termArray[k];
                                    const term4 = termArray[l];

                                    const indices1 = new Set(allTerms.get(term1));
                                    const indices2 = new Set(allTerms.get(term2));
                                    const indices3 = new Set(allTerms.get(term3));
                                    const indices4 = new Set(allTerms.get(term4));

                                    const intersection = new Set(
                                        [...indices1].filter(x => indices2.has(x) && indices3.has(x) && indices4.has(x))
                                    );
                                    const support = intersection.size;

                                    if (support >= 2) {
                                        const prob1 = indices1.size / totalResponses;
                                        const prob2 = indices2.size / totalResponses;
                                        const prob3 = indices3.size / totalResponses;
                                        const prob4 = indices4.size / totalResponses;
                                        const probAll = support / totalResponses;
                                        const expectedProb = prob1 * prob2 * prob3 * prob4;
                                        const lift = expectedProb > 0 ? probAll / expectedProb : 0;

                                        if (lift >= 1.5) {
                                            patterns.push({
                                                terms: [term1, term2, term3, term4],
                                                support: support,
                                                lift: lift,
                                                confidence: probAll / prob1,
                                                respondentIndices: Array.from(intersection)
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Filter out redundant patterns where one term contains another
            const filteredPatterns = patterns.filter(pattern => {
                // Check if any term is a substring of another term in the same pattern
                for (let i = 0; i < pattern.terms.length; i++) {
                    for (let j = 0; j < pattern.terms.length; j++) {
                        if (i !== j) {
                            // Check if term i is contained within term j
                            if (pattern.terms[j].includes(pattern.terms[i])) {
                                return false; // This is a redundant pattern
                            }
                        }
                    }
                }
                return true;
            });

            console.log('- Patterns before redundancy filter:', patterns.length);
            console.log('- Patterns after redundancy filter:', filteredPatterns.length);

            // Sort by lift (highest first)
            filteredPatterns.sort((a, b) => b.lift - a.lift);

            if (filteredPatterns.length > 0) {
                console.log('- Top pattern lift:', filteredPatterns[0].lift.toFixed(2));
                console.log('- Lowest pattern lift:', filteredPatterns[filteredPatterns.length - 1].lift.toFixed(2));
            }

            return filteredPatterns;
        }

        function isStopWord(word) {
            const stopWords = new Set([
                'the', 'and', 'for', 'with', 'this', 'that', 'from', 'have', 'has',
                'will', 'would', 'could', 'should', 'their', 'there', 'these', 'those',
                'which', 'what', 'when', 'where', 'who', 'why', 'how', 'are', 'was',
                'were', 'been', 'being', 'into', 'through', 'about', 'over', 'after',
                'before', 'between', 'each', 'other', 'some', 'such', 'only', 'also',
                'more', 'most', 'than', 'then', 'them', 'they', 'very', 'just', 'can',
                'like', 'make', 'made', 'many', 'much', 'well', 'think', 'need', 'help',
                'using', 'used', 'ways', 'want', 'work', 'take', 'even', 'come', 'know',
                'may', 'say', 'see', 'get', 'give', 'use', 'find', 'tell', 'ask', 'become',
                'seem', 'feel', 'try', 'leave', 'call', 'keep', 'let', 'begin', 'show'
            ]);
            return stopWords.has(word);
        }

        // Global storage for pattern data
        window.patternChipData = {};

        function renderPatternResults(patterns) {
            const minLift = parseFloat(document.getElementById('minLiftSlider').value);
            const minSupport = parseInt(document.getElementById('minSupportSlider').value);
            const container = document.getElementById('patternResultsContainer');

            console.log('Rendering patterns - Before filter:', patterns.length);
            console.log('- Min lift threshold:', minLift);
            console.log('- Min support threshold:', minSupport);

            // Filter patterns
            const filtered = patterns.filter(p => p.lift >= minLift && p.support >= minSupport);

            console.log('- After filter:', filtered.length);

            // Sort patterns based on user preference
            const sortBy = document.getElementById('patternSortSelect')?.value || 'suspicion';

            if (sortBy === 'suspicion') {
                // Sort by suspicion level: high lift + high support first
                filtered.sort((a, b) => {
                    const scoreA = a.lift * Math.log(a.support + 1);
                    const scoreB = b.lift * Math.log(b.support + 1);
                    return scoreB - scoreA;
                });
            } else if (sortBy === 'lift') {
                filtered.sort((a, b) => b.lift - a.lift);
            } else if (sortBy === 'support') {
                filtered.sort((a, b) => b.support - a.support);
            }

            console.log('- Sorted by:', sortBy);

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <i class="fas fa-search" style="font-size: 48px; margin-bottom: 15px; opacity: 0.3;"></i>
                        <p>No patterns found with current criteria.</p>
                        <p style="font-size: 13px; margin-top: 10px;">
                            ${patterns.length > 0 ?
                                `Found ${patterns.length} patterns total, but none meet the current thresholds.<br>Try lowering Min Lift to ${Math.max(1.5, Math.floor(patterns[0].lift * 10) / 10)} or Min Support to 2.` :
                                'No correlated patterns detected in the data.'}
                        </p>
                    </div>
                `;
                return;
            }

            // Get ID column (first column by default, or find one with "id" in the name)
            let idColumnKey = null;
            if (csvData.length > 0) {
                const firstRow = csvData[0];
                const keys = Object.keys(firstRow);
                // Try to find a column with "id" in the name
                idColumnKey = keys.find(k => k.toLowerCase().includes('id')) || keys[0];
            }

            container.innerHTML = `
                <div style="margin-bottom: 15px; padding: 12px; background: #e3f2fd; border-radius: 6px; border-left: 4px solid #2196f3;">
                    <strong style="color: #1565c0;">Found ${filtered.length} correlated patterns</strong>
                    <div style="font-size: 12px; color: #555; margin-top: 8px; line-height: 1.6;">
                        <strong>How to interpret these metrics:</strong><br>
                        â€¢ <strong>Lift:</strong> How much more likely terms appear together vs. random chance<br>
                        â€¢ <strong>Support:</strong> Number of respondents using this combination<br>
                        â€¢ <strong>ðŸš© Most suspicious:</strong> High lift (4+) + High support (10+) = likely copying/templates<br>
                        â€¢ <strong>âš ï¸ Worth investigating:</strong> High lift (4+) + Medium support (5-10)<br>
                        â€¢ <strong>â„¹ï¸ Less concerning:</strong> High lift + Low support (2-4) = may be coincidental
                    </div>
                </div>
                <div style="max-height: 600px; overflow-y: auto;">
                    ${filtered.slice(0, 100).map((pattern, idx) => {
                        const liftClass = pattern.lift >= 4 ? 'lift-high' : (pattern.lift >= 2.5 ? 'lift-medium' : 'lift-low');
                        const liftLabel = pattern.lift >= 4 ? 'Very High' : (pattern.lift >= 2.5 ? 'High' : 'Moderate');

                        // Determine suspicion level
                        let suspicionIcon = '';
                        let suspicionLabel = '';
                        let suspicionColor = '';
                        let suspicionExplanation = '';

                        if (pattern.lift >= 4 && pattern.support >= 10) {
                            suspicionIcon = 'ðŸš©';
                            suspicionLabel = 'HIGHLY SUSPICIOUS';
                            suspicionColor = '#c0392b';
                            suspicionExplanation = 'High lift with high support suggests likely copying, templates, or shared sources. This pattern warrants close investigation.';
                        } else if (pattern.lift >= 4 && pattern.support >= 5) {
                            suspicionIcon = 'âš ï¸';
                            suspicionLabel = 'WORTH INVESTIGATING';
                            suspicionColor = '#e67e22';
                            suspicionExplanation = 'High lift with moderate support. Could indicate shared language patterns or common phrasing. Review to determine if legitimate.';
                        } else if (pattern.lift >= 4) {
                            suspicionIcon = 'â„¹ï¸';
                            suspicionLabel = 'LOW CONCERN';
                            suspicionColor = '#3498db';
                            suspicionExplanation = 'High lift but low support. Likely a rare phrase used by few respondents. Less concerning unless context suggests otherwise.';
                        } else {
                            suspicionIcon = 'âœ“';
                            suspicionLabel = 'MODERATE CORRELATION';
                            suspicionColor = '#27ae60';
                            suspicionExplanation = 'Moderate correlation. This combination appears together more than random, but not at a highly suspicious level.';
                        }

                        // Get respondent IDs
                        const respondentIds = pattern.respondentIndices.map(i => {
                            if (idColumnKey && csvData[i]) {
                                return csvData[i][idColumnKey];
                            }
                            return i + 1;
                        });

                        return `
                            <div class="pattern-result-item pattern-expandable" onclick="togglePatternDetails(${idx})">
                                <div style="display: flex; justify-content: space-between; align-items: start; gap: 15px; margin-bottom: 10px;">
                                    <div class="pattern-terms" style="flex: 1;">
                                        ${pattern.terms.map((term, i) => `
                                            <span class="pattern-term-badge">${escapeHtml(term)}</span>
                                            ${i < pattern.terms.length - 1 ? '<span class="pattern-arrow">+</span>' : ''}
                                        `).join('')}
                                    </div>
                                    <div style="display: flex; gap: 8px; align-items: center;">
                                        <span class="lift-badge ${liftClass}" title="${liftLabel} Lift - Hover for explanation"
                                            style="cursor: help; position: relative;">
                                            ${pattern.lift.toFixed(2)}Ã— lift
                                        </span>
                                    </div>
                                </div>

                                <div style="display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: ${suspicionColor}15; border-left: 4px solid ${suspicionColor}; border-radius: 4px; margin-bottom: 10px;">
                                    <span style="font-size: 18px;">${suspicionIcon}</span>
                                    <div style="flex: 1;">
                                        <div style="font-weight: 700; font-size: 11px; color: ${suspicionColor}; letter-spacing: 0.5px;">
                                            ${suspicionLabel}
                                        </div>
                                        <div style="font-size: 12px; color: #555; margin-top: 2px;">
                                            ${suspicionExplanation}
                                        </div>
                                    </div>
                                </div>

                                <div class="pattern-metrics">
                                    <div class="pattern-metric-badge" title="Number of respondents who used this combination">
                                        <span class="pattern-metric-label">Support</span>
                                        <span class="pattern-metric-value">${pattern.support}</span>
                                    </div>
                                    <div class="pattern-metric-badge" title="Probability that when the first term appears, all other terms also appear">
                                        <span class="pattern-metric-label">Confidence</span>
                                        <span class="pattern-metric-value">${(pattern.confidence * 100).toFixed(1)}%</span>
                                    </div>
                                    <div class="pattern-metric-badge" title="Lift score interpretation: ${liftLabel} (${pattern.lift.toFixed(2)}Ã— more than random)">
                                        <span class="pattern-metric-label">Lift Category</span>
                                        <span class="pattern-metric-value" style="font-size: 14px;">${liftLabel}</span>
                                    </div>
                                </div>

                                <div class="pattern-details" id="patternDetails${idx}">
                                    <h4 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 14px;">
                                        ðŸ“Š What This Means
                                    </h4>
                                    <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                                        <p style="font-size: 13px; color: #555; line-height: 1.6; margin: 0;">
                                            If these terms appeared together <strong>by random chance</strong>, we'd expect to see them together in
                                            <strong>~${(pattern.support / pattern.lift).toFixed(1)} responses</strong>.
                                            <br><br>
                                            But they <strong>actually appear together</strong> in <strong>${pattern.support} responses</strong>.
                                            <br><br>
                                            This is <strong>${pattern.lift.toFixed(1)}Ã— more</strong> than random chance would predict, suggesting
                                            ${pattern.lift >= 10 ? 'a very strong' : pattern.lift >= 4 ? 'a strong' : 'a moderate'} correlation between these terms.
                                        </p>
                                    </div>
                                    <h4 style="margin: 15px 0 10px 0; color: #2c3e50; font-size: 14px;">
                                        Respondents Using This Pattern (${respondentIds.length})
                                    </h4>
                                    <div class="respondent-list" data-pattern-idx="${idx}">
                                        ${respondentIds.slice(0, 20).map(id =>
                                            `<span class="respondent-chip pattern-chip-${idx}" style="cursor: pointer; transition: opacity 0.2s;"
                                                data-respondent-id="${escapeHtml(String(id))}"
                                                data-pattern-idx="${idx}"
                                                onmouseover="this.style.opacity='0.7'"
                                                onmouseout="this.style.opacity='1'"
                                                title="Click to see all responses with pattern terms highlighted">
                                                ${escapeHtml(String(id))}
                                            </span>`
                                        ).join('')}
                                        ${respondentIds.length > 20 ? `<span class="respondent-chip">+${respondentIds.length - 20} more</span>` : ''}
                                    </div>
                                    <div style="font-size: 11px; color: #7f8c8d; margin-top: 8px;">
                                        ðŸ’¡ Click any respondent ID to view all responses in this group with pattern terms highlighted
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    ${filtered.length > 100 ? `
                        <div style="padding: 20px; text-align: center; color: #666; background: #f8f9fa; border-radius: 6px; margin-top: 10px;">
                            Showing top 100 patterns out of ${filtered.length} total.
                            Adjust filters to refine results.
                        </div>
                    ` : ''}
                </div>
            `;

            // Attach click handlers to pattern chips after rendering
            setTimeout(() => {
                filtered.forEach((pattern, idx) => {
                    const chips = document.querySelectorAll(`.pattern-chip-${idx}`);
                    window.patternChipData[`pattern_${idx}`] = {
                        indices: pattern.respondentIndices,
                        terms: pattern.terms
                    };
                    chips.forEach(chip => {
                        chip.onclick = function() {
                            const data = window.patternChipData[`pattern_${idx}`];
                            showPatternRespondentMatches(this.dataset.respondentId, data.indices, data.terms);
                        };
                    });
                });
            }, 100);
        }

        function togglePatternDetails(idx) {
            const details = document.getElementById(`patternDetails${idx}`);
            if (details) {
                details.classList.toggle('expanded');
            }
        }

        // Store current pattern search terms for highlighting
        let currentPatternSearchTerms = [];

        function showPatternRespondentMatches(clickedRespondentId, patternRespondentIndices, searchTerms = []) {
            console.log('showPatternRespondentMatches called with:', clickedRespondentId, patternRespondentIndices);

            // Store search terms for highlighting
            currentPatternSearchTerms = searchTerms;

            // Show loading spinner
            const spinner = document.getElementById('loadingSpinner');
            spinner.style.display = 'flex';

            setTimeout(() => {
                try {
                    // Get ID column and selected column
                    let idColumnKey = null;
                    if (csvData.length > 0) {
                        const firstRow = csvData[0];
                        const keys = Object.keys(firstRow);
                        idColumnKey = keys.find(k => k.toLowerCase().includes('id')) || keys[0];
                    }

                    const columnSelect = document.getElementById('columnSelect');
                    const selectedColumn = columnSelect.value;

                    // Collect all respondents in this pattern
                    const respondents = patternRespondentIndices.map(idx => {
                        const id = idColumnKey ? csvData[idx][idColumnKey] : (idx + 1);
                        const text = csvData[idx][selectedColumn] || '';
                        return { id, text, idx };
                    });

                    if (respondents.length === 0) {
                        alert('No respondents found in this pattern.');
                        spinner.style.display = 'none';
                        return;
                    }

                    // Render the pattern group modal
                    renderPatternGroupModal(respondents, currentPatternSearchTerms);

                    spinner.style.display = 'none';
                } catch (error) {
                    console.error('Error in showPatternRespondentMatches:', error);
                    alert('Error loading comparison. Please try again.');
                    spinner.style.display = 'none';
                }
            }, 100);
        }

        // Simple Porter Stemmer implementation for grouping word variants
        function stemWord(word) {
            // Don't stem very short words
            if (word.length <= 3) return word;

            // Step 1: Handle plurals and -ed/-ing
            word = word.replace(/sses$/, 'ss');
            word = word.replace(/ies$/, 'i');
            word = word.replace(/([^s])s$/, '$1');

            // Handle -ed, -ing
            if (word.match(/(at|bl|iz)ed$/)) {
                word = word.replace(/ed$/, 'e');
            } else if (word.match(/([^aeiou])\1ed$/)) {
                word = word.replace(/.ed$/, '');
            } else if (word.match(/ed$/)) {
                word = word.replace(/ed$/, '');
            }

            if (word.match(/ing$/)) {
                const stem = word.replace(/ing$/, '');
                if (stem.length >= 3) {
                    word = stem;
                    // Add 'e' for words like 'making' -> 'make'
                    if (word.match(/(at|bl|iz)$/)) {
                        word = word + 'e';
                    }
                }
            }

            // Step 2: Handle -tion, -ation, -ment, -ness, etc.
            word = word.replace(/ational$/, 'ate');
            word = word.replace(/tional$/, 'tion');
            word = word.replace(/tion$/, 'tion'); // Keep -tion
            word = word.replace(/ement$/, 'e');
            word = word.replace(/ment$/, '');
            word = word.replace(/ness$/, '');
            word = word.replace(/ity$/, '');
            word = word.replace(/ful$/, '');
            word = word.replace(/ous$/, '');
            word = word.replace(/ive$/, '');
            word = word.replace(/able$/, '');
            word = word.replace(/ible$/, '');
            word = word.replace(/ize$/, '');
            word = word.replace(/ise$/, '');
            word = word.replace(/ly$/, '');

            return word;
        }

        function findSharedTerms(responses, searchTerms) {
            // Tokenize all responses and create sets of unique words
            const tokenizedResponses = responses.map(text => {
                const cleaned = text.toLowerCase().replace(/[^\w\s]/g, ' ');
                const words = cleaned.split(/\s+/)
                    .filter(word => word.length > 3)
                    .filter(word => !isStopWord(word));

                // Filter out search terms and their wildcard matches
                const filteredWords = words.filter(word => {
                    // Check if this word matches any search term (including wildcards)
                    return !searchTerms.some(st => {
                        if (st.includes('*')) {
                            const regexPattern = st.replace(/\*/g, '[a-z]*').replace(/\s+/g, '\\s+');
                            const regex = new RegExp('\\b' + regexPattern + '\\b', 'i');
                            return regex.test(word);
                        } else {
                            // For multi-word search terms, check each word
                            const stWords = st.toLowerCase().split(/\s+/);
                            return stWords.some(stWord => word === stWord || word.includes(stWord) || stWord.includes(word));
                        }
                    });
                });

                return filteredWords;
            });

            // If no responses, return empty array
            if (tokenizedResponses.length === 0) return [];

            // Group words by their stems and track original forms
            const stemGroups = {}; // stem -> {originalForms: Set, responseIndices: Set}

            tokenizedResponses.forEach((words, responseIdx) => {
                const seenStems = new Set(); // Track stems we've seen in this response

                words.forEach(word => {
                    const stem = stemWord(word);

                    // Initialize stem group if needed
                    if (!stemGroups[stem]) {
                        stemGroups[stem] = {
                            originalForms: new Set(),
                            responseIndices: new Set(),
                            wordsByResponse: {}
                        };
                    }

                    stemGroups[stem].originalForms.add(word);

                    // Only count each stem once per response
                    if (!seenStems.has(stem)) {
                        stemGroups[stem].responseIndices.add(responseIdx);
                        seenStems.add(stem);
                    }

                    // Track which forms appear in which responses for counting
                    if (!stemGroups[stem].wordsByResponse[responseIdx]) {
                        stemGroups[stem].wordsByResponse[responseIdx] = [];
                    }
                    stemGroups[stem].wordsByResponse[responseIdx].push(word);
                });
            });

            // Calculate threshold: at least half of responses
            const threshold = Math.ceil(responses.length / 2);

            // Find stem groups that appear in at least half of the responses
            const frequentTerms = [];

            Object.keys(stemGroups).forEach(stem => {
                const group = stemGroups[stem];
                const responsesWithTerm = group.responseIndices.size;

                // Include only if stem appears in at least half of responses
                if (responsesWithTerm >= threshold) {
                    // Count total occurrences across all responses
                    let totalOccurrences = 0;
                    Object.values(group.wordsByResponse).forEach(words => {
                        totalOccurrences += words.length;
                    });

                    // Choose the most representative form (shortest or most common)
                    const formsArray = Array.from(group.originalForms);
                    const representativeForm = formsArray.sort((a, b) => a.length - b.length)[0];

                    // Create display text showing main form + variants if multiple
                    let displayText = representativeForm;
                    if (formsArray.length > 1) {
                        const otherForms = formsArray.filter(f => f !== representativeForm).slice(0, 2);
                        if (otherForms.length > 0) {
                            displayText += ' (' + otherForms.join(', ') + (formsArray.length > 3 ? '...' : '') + ')';
                        }
                    }

                    frequentTerms.push({
                        term: displayText,
                        stem: stem,
                        count: totalOccurrences,
                        responseCount: responsesWithTerm,
                        forms: formsArray
                    });
                }
            });

            // Sort by number of responses containing the term, then by total count
            return frequentTerms.sort((a, b) => {
                if (b.responseCount !== a.responseCount) {
                    return b.responseCount - a.responseCount;
                }
                return b.count - a.count;
            });
        }

        function renderPatternGroupModal(respondents, searchTerms) {
            const modal = document.getElementById('patternGroupModal');
            const title = document.getElementById('patternGroupTitle');
            const body = document.getElementById('patternGroupBody');

            // Set title
            title.textContent = `Pattern Group: ${respondents.length} Respondent${respondents.length > 1 ? 's' : ''} Using ${searchTerms.length > 0 ? 'Search Terms' : 'This Pattern'}`;

            // Find other shared terms across all responses
            const sharedTerms = findSharedTerms(respondents.map(r => r.text), searchTerms);

            // Build fixed header content (combined collapsible banner)
            let fixedContent = `
                <div style="background: linear-gradient(135deg, #fff3cd 0%, #e8f5e9 100%); border-bottom: 3px solid #4caf50; padding: 15px; cursor: pointer;" onclick="toggleHighlightLegend()">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h4 style="margin: 0; color: #2c3e50; font-size: 15px; font-weight: 600;">
                            ðŸŽ¨ Highlighting Legend
                        </h4>
                        <span id="highlightLegendToggle" style="font-size: 18px; font-weight: bold; color: #2c3e50;">â–¼</span>
                    </div>
                </div>
                <div id="highlightLegendContent" style="background: #f8f9fa; padding: 15px; border-bottom: 2px solid #e0e0e0;">
            `;

            // Show search terms being highlighted
            if (searchTerms.length > 0) {
                fixedContent += `
                    <div style="margin-bottom: 15px;">
                        <h5 style="margin: 0 0 8px 0; color: #856404; font-size: 13px; font-weight: 600;">
                            ðŸ” Search Terms (Yellow)
                        </h5>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${searchTerms.map(term =>
                                `<span style="background: #ffeb3b; padding: 4px 10px; border-radius: 4px; font-size: 13px; font-weight: 600; border: 1px solid #ffc107;">
                                    ${escapeHtml(term)}
                                </span>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            // Show other shared terms
            if (sharedTerms.length > 0) {
                fixedContent += `
                    <div>
                        <h5 style="margin: 0 0 8px 0; color: #2e7d32; font-size: 13px; font-weight: 600;">
                            ðŸ”— Frequent Terms (Green) - Found in ${Math.ceil(respondents.length / 2)}+ of ${respondents.length} Responses
                        </h5>
                        <p style="font-size: 11px; color: #666; margin: 0 0 8px 0;">
                            Excluding search terms and common stop words
                        </p>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${sharedTerms.slice(0, 20).map(term =>
                                `<span style="background: #c8e6c9; padding: 4px 10px; border-radius: 4px; font-size: 13px; font-weight: 600; border: 1px solid #81c784; color: #1b5e20;">
                                    ${escapeHtml(term.term)} <span style="opacity: 0.7; font-size: 11px;">(${term.responseCount}/${respondents.length})</span>
                                </span>`
                            ).join('')}
                            ${sharedTerms.length > 20 ? `<span style="color: #666; font-size: 12px; padding: 4px 10px;">+${sharedTerms.length - 20} more</span>` : ''}
                        </div>
                    </div>
                `;
            }

            fixedContent += `</div>`;

            // Build scrollable content (respondents)
            let scrollableContent = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
            `;

            respondents.forEach((respondent, idx) => {
                const highlightedText = highlightSearchTermsInText(respondent.text, searchTerms, sharedTerms);

                scrollableContent += `
                    <div style="margin-bottom: 20px; border: 2px solid #e0e0e0; border-radius: 8px; overflow: hidden; height: fit-content;">
                        <div style="background: #f8f9fa; padding: 12px 15px; border-bottom: 2px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-weight: 600; color: #2c3e50; font-size: 15px;">
                                Respondent: ${escapeHtml(String(respondent.id))}
                            </div>
                            <div style="font-size: 12px; color: #7f8c8d;">
                                ${idx + 1} of ${respondents.length}
                            </div>
                        </div>
                        <div style="padding: 15px; background: white; font-size: 14px; line-height: 1.8; color: #2c3e50;">
                            ${highlightedText}
                        </div>
                    </div>
                `;
            });

            scrollableContent += `</div>`;

            // Combine fixed and scrollable content with proper layout
            body.innerHTML = `
                <div style="position: sticky; top: 0; background: white; z-index: 10;">
                    ${fixedContent}
                </div>
                <div style="padding: 0 25px 25px 25px;">
                    ${scrollableContent}
                </div>
            `;

            modal.style.display = 'block';
        }

        function toggleHighlightLegend() {
            const content = document.getElementById('highlightLegendContent');
            const toggle = document.getElementById('highlightLegendToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                toggle.textContent = 'â–¶';
            }
        }

        function highlightSearchTermsInText(text, searchTerms, sharedTerms) {
            let highlightedText = text;

            // First, highlight shared/frequent terms in green (all word forms)
            if (sharedTerms && sharedTerms.length > 0) {
                sharedTerms.forEach(termObj => {
                    // Get all forms of this term
                    const allForms = termObj.forms || [termObj.term];

                    allForms.forEach(form => {
                        const regex = new RegExp('\\b(' + form.replace(/\s+/g, '\\s+') + ')\\b', 'gi');
                        highlightedText = highlightedText.replace(regex, (match) => {
                            return `<mark style="background: #c8e6c9; padding: 2px 4px; border-radius: 3px; font-weight: 600; border: 1px solid #81c784;">${match}</mark>`;
                        });
                    });
                });
            }

            // Then, highlight search terms in yellow (which will override green if they overlap)
            if (searchTerms && searchTerms.length > 0) {
                // Sort terms by length (longest first) to avoid partial matches
                const sortedTerms = [...searchTerms].sort((a, b) => b.length - a.length);

                sortedTerms.forEach(term => {
                    // Handle wildcard terms
                    if (term.includes('*')) {
                        // Convert wildcard to regex pattern
                        const regexPattern = term.replace(/\*/g, '[a-z]*').replace(/\s+/g, '\\s+');
                        const regex = new RegExp('\\b(' + regexPattern + ')\\b', 'gi');

                        highlightedText = highlightedText.replace(regex, (match) => {
                            return `<mark style="background: #ffeb3b; padding: 2px 4px; border-radius: 3px; font-weight: 600;">${match}</mark>`;
                        });
                    } else {
                        // Regular term matching
                        const regex = new RegExp('\\b(' + term.replace(/\s+/g, '\\s+') + ')\\b', 'gi');

                        highlightedText = highlightedText.replace(regex, (match) => {
                            return `<mark style="background: #ffeb3b; padding: 2px 4px; border-radius: 3px; font-weight: 600;">${match}</mark>`;
                        });
                    }
                });
            }

            return highlightedText;
        }

        function closePatternGroupModal() {
            document.getElementById('patternGroupModal').style.display = 'none';
        }

        // Add keyboard listener for ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('patternGroupModal');
                if (modal.style.display === 'block') {
                    closePatternGroupModal();
                }
            }
        });

        function searchSpecificTerms() {
            const input = document.getElementById('specificTermsInput').value.trim();
            const resultDiv = document.getElementById('specificTermsResult');

            if (!input) {
                resultDiv.innerHTML = `
                    <div style="padding: 10px; background: #f8d7da; color: #721c24; border-radius: 5px; font-size: 13px;">
                        Please enter at least 1 term to search.
                    </div>
                `;
                return;
            }

            if (!csvData || csvData.length === 0) {
                resultDiv.innerHTML = `
                    <div style="padding: 10px; background: #f8d7da; color: #721c24; border-radius: 5px; font-size: 13px;">
                        Please upload and analyze a CSV file first.
                    </div>
                `;
                return;
            }

            const columnSelect = document.getElementById('columnSelect');
            const selectedColumn = columnSelect.value;

            if (!selectedColumn) {
                resultDiv.innerHTML = `
                    <div style="padding: 10px; background: #f8d7da; color: #721c24; border-radius: 5px; font-size: 13px;">
                        Please select a question column first.
                    </div>
                `;
                return;
            }

            // Parse and normalize terms
            const searchTerms = input.split(',').map(t => t.trim().toLowerCase()).filter(t => t.length > 0);

            if (searchTerms.length < 1) {
                resultDiv.innerHTML = `
                    <div style="padding: 10px; background: #f8d7da; color: #721c24; border-radius: 5px; font-size: 13px;">
                        Please enter at least 1 term to search.
                    </div>
                `;
                return;
            }

            // Show loading
            resultDiv.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 24px; color: #ffc107;"></i>
                    <p style="margin-top: 10px; font-size: 13px; color: #666;">Searching for correlation...</p>
                </div>
            `;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    const result = calculateSpecificTermCorrelation(selectedColumn, searchTerms);
                    displaySpecificTermResult(result, searchTerms);

                    // Save search terms for persistence
                    saveSession();
                } catch (error) {
                    console.error('Error searching terms:', error);
                    resultDiv.innerHTML = `
                        <div style="padding: 10px; background: #f8d7da; color: #721c24; border-radius: 5px; font-size: 13px;">
                            Error searching for terms. Please try again.
                        </div>
                    `;
                }
            }, 100);
        }

        function calculateSpecificTermCorrelation(column, searchTerms) {
            // Extract all responses
            const responses = csvData.map(row => {
                const text = row[column] || '';
                return text.toString().toLowerCase();
            }).filter(text => text.length > 0);

            const totalResponses = responses.length;

            // For each response, check which search terms appear
            const termPresence = searchTerms.map(term => []);
            const respondentIndices = [];

            responses.forEach((text, idx) => {
                const cleaned = text.toLowerCase().replace(/[^\w\s]/g, ' ');

                searchTerms.forEach((term, termIdx) => {
                    let matched = false;

                    // Handle wildcard search with *
                    if (term.includes('*')) {
                        // Convert wildcard to regex pattern
                        // e.g., "align*" becomes "align[a-z]*"
                        const regexPattern = term
                            .replace(/\*/g, '[a-z]*')
                            .replace(/\s+/g, '\\s+');
                        const regex = new RegExp('\\b' + regexPattern + '\\b', 'i');
                        matched = regex.test(text);
                    } else {
                        // Regular exact term matching
                        const regex = new RegExp('\\b' + term.replace(/\s+/g, '\\s+') + '\\b', 'i');
                        matched = regex.test(text) || cleaned.includes(term);
                    }

                    if (matched) {
                        termPresence[termIdx].push(idx);
                    }
                });
            });

            // Find responses that contain ALL search terms
            const allTermsSet = new Set(termPresence[0]);
            for (let i = 1; i < termPresence.length; i++) {
                const currentSet = new Set(termPresence[i]);
                for (const idx of allTermsSet) {
                    if (!currentSet.has(idx)) {
                        allTermsSet.delete(idx);
                    }
                }
            }

            const intersection = Array.from(allTermsSet);
            const support = intersection.length;

            // Calculate probabilities
            const individualProbs = termPresence.map(arr => arr.length / totalResponses);
            const jointProb = support / totalResponses;
            const expectedProb = individualProbs.reduce((a, b) => a * b, 1);
            const lift = expectedProb > 0 ? jointProb / expectedProb : 0;

            // Calculate confidence (P(all terms | first term))
            const confidence = termPresence[0].length > 0 ? support / termPresence[0].length : 0;

            // NEW: Find other correlated terms
            const correlatedTerms = findCorrelatedTermsWithSearch(responses, intersection, searchTerms);

            // NEW: Find actual matched variations for wildcard terms
            const matchedVariations = searchTerms.map((term, termIdx) => {
                if (!term.includes('*')) return null;

                const variations = new Set();
                const regexPattern = term.replace(/\*/g, '[a-z]*').replace(/\s+/g, '\\s+');
                const regex = new RegExp('\\b(' + regexPattern + ')\\b', 'ig');

                termPresence[termIdx].forEach(idx => {
                    const text = responses[idx];
                    const matches = text.match(regex);
                    if (matches) {
                        matches.forEach(match => variations.add(match.toLowerCase()));
                    }
                });

                return Array.from(variations).sort();
            });

            return {
                terms: searchTerms,
                support: support,
                lift: lift,
                confidence: confidence,
                respondentIndices: intersection,
                individualCounts: termPresence.map(arr => arr.length),
                totalResponses: totalResponses,
                expectedCount: expectedProb * totalResponses,
                correlatedTerms: correlatedTerms,
                matchedVariations: matchedVariations
            };
        }

        function findCorrelatedTermsWithSearch(responses, searchResponseIndices, searchTerms) {
            if (searchResponseIndices.length === 0) {
                return [];
            }

            // Get responses that contain the search terms
            const searchResponses = searchResponseIndices.map(idx => responses[idx]);

            // Tokenize and count terms in these responses
            const termCounts = new Map();

            searchResponses.forEach(text => {
                const cleaned = text.toLowerCase().replace(/[^\w\s]/g, ' ');
                const tokens = cleaned.split(/\s+/).filter(word => word.length > 3 && !isStopWord(word));

                // Single words
                const uniqueTokens = [...new Set(tokens)];
                uniqueTokens.forEach(term => {
                    // Skip if it's one of the search terms
                    if (searchTerms.some(st => term.includes(st) || st.includes(term))) {
                        return;
                    }
                    termCounts.set(term, (termCounts.get(term) || 0) + 1);
                });

                // 2-word phrases
                for (let i = 0; i < tokens.length - 1; i++) {
                    const phrase = tokens[i] + ' ' + tokens[i + 1];
                    // Skip if it overlaps with search terms
                    if (searchTerms.some(st => phrase.includes(st) || st.includes(phrase))) {
                        continue;
                    }
                    termCounts.set(phrase, (termCounts.get(phrase) || 0) + 1);
                }
            });

            // Calculate lift for each term
            const totalResponses = responses.length;
            const searchSupport = searchResponseIndices.length;
            const searchProb = searchSupport / totalResponses;

            const correlations = [];

            termCounts.forEach((count, term) => {
                // Count how many times this term appears across all responses
                let totalOccurrences = 0;
                responses.forEach(text => {
                    const regex = new RegExp('\\b' + term.replace(/\s+/g, '\\s+') + '\\b', 'i');
                    if (regex.test(text)) {
                        totalOccurrences++;
                    }
                });

                const termProb = totalOccurrences / totalResponses;
                const jointProb = count / totalResponses;
                const expectedProb = searchProb * termProb;
                const lift = expectedProb > 0 ? jointProb / expectedProb : 0;

                if (count >= 2 && lift >= 1.5) {
                    correlations.push({
                        term: term,
                        support: count,
                        lift: lift,
                        totalOccurrences: totalOccurrences
                    });
                }
            });

            // Sort by suspicion score (lift * log(support))
            correlations.sort((a, b) => {
                const scoreA = a.lift * Math.log(a.support + 1);
                const scoreB = b.lift * Math.log(b.support + 1);
                return scoreB - scoreA;
            });

            return correlations.slice(0, 15); // Return top 15
        }

        function displaySpecificTermResult(result, searchTerms) {
            const resultDiv = document.getElementById('specificTermsResult');

            // Get ID column
            let idColumnKey = null;
            if (csvData.length > 0) {
                const firstRow = csvData[0];
                const keys = Object.keys(firstRow);
                idColumnKey = keys.find(k => k.toLowerCase().includes('id')) || keys[0];
            }

            // Get respondent IDs
            const respondentIds = result.respondentIndices.map(i => {
                if (idColumnKey && csvData[i]) {
                    return csvData[i][idColumnKey];
                }
                return i + 1;
            });

            // Determine suspicion level
            let suspicionIcon = '';
            let suspicionLabel = '';
            let suspicionColor = '';
            let suspicionExplanation = '';

            if (result.lift >= 4 && result.support >= 10) {
                suspicionIcon = 'ðŸš©';
                suspicionLabel = 'HIGHLY SUSPICIOUS';
                suspicionColor = '#c0392b';
                suspicionExplanation = 'High lift with high support suggests likely copying, templates, or shared sources.';
            } else if (result.lift >= 4 && result.support >= 5) {
                suspicionIcon = 'âš ï¸';
                suspicionLabel = 'WORTH INVESTIGATING';
                suspicionColor = '#e67e22';
                suspicionExplanation = 'High lift with moderate support. Could indicate shared language patterns.';
            } else if (result.lift >= 4) {
                suspicionIcon = 'â„¹ï¸';
                suspicionLabel = 'LOW CONCERN';
                suspicionColor = '#3498db';
                suspicionExplanation = 'High lift but low support. Likely coincidental.';
            } else if (result.support > 0) {
                suspicionIcon = 'âœ“';
                suspicionLabel = 'MODERATE CORRELATION';
                suspicionColor = '#27ae60';
                suspicionExplanation = 'These terms appear together, but not at a highly suspicious level.';
            } else {
                suspicionIcon = 'âŒ';
                suspicionLabel = 'NO CORRELATION';
                suspicionColor = '#95a5a6';
                suspicionExplanation = 'These terms never appear together in any response.';
            }

            const liftClass = result.lift >= 4 ? 'lift-high' : (result.lift >= 2.5 ? 'lift-medium' : 'lift-low');

            const hasWildcards = searchTerms.some(t => t.includes('*'));
            const isSingleTerm = searchTerms.length === 1;

            resultDiv.innerHTML = `
                <div style="border: 2px solid ${isSingleTerm ? '#57068C' : suspicionColor}; border-radius: 8px; overflow: hidden;">
                    <div style="background: ${isSingleTerm ? '#57068C' : suspicionColor}; color: white; padding: 12px; font-weight: 600; font-size: 15px;">
                        ${isSingleTerm ? 'ðŸ”' : suspicionIcon} Search Results for: ${searchTerms.map(t => '"' + escapeHtml(t) + '"').join(' + ')}
                        ${hasWildcards ? '<span style="font-size: 12px; opacity: 0.9; margin-left: 8px;">(using wildcards)</span>' : ''}
                    </div>

                    <div style="padding: 15px; background: white;">
                        ${!isSingleTerm ? `
                            <!-- Suspicion Level -->
                            <div style="display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: ${suspicionColor}15; border-left: 4px solid ${suspicionColor}; border-radius: 4px; margin-bottom: 15px;">
                                <span style="font-size: 18px;">${suspicionIcon}</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; font-size: 11px; color: ${suspicionColor}; letter-spacing: 0.5px;">
                                        ${suspicionLabel}
                                    </div>
                                    <div style="font-size: 12px; color: #555; margin-top: 2px;">
                                        ${suspicionExplanation}
                                    </div>
                                </div>
                            </div>
                        ` : `
                            <!-- Single Term Info -->
                            <div style="display: flex; align-items: center; gap: 10px; padding: 10px 12px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px; margin-bottom: 15px;">
                                <span style="font-size: 18px;">â„¹ï¸</span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; font-size: 11px; color: #1565c0; letter-spacing: 0.5px;">
                                        SINGLE TERM ANALYSIS
                                    </div>
                                    <div style="font-size: 12px; color: #555; margin-top: 2px;">
                                        Showing frequency and correlated terms. Add more terms to see joint correlations.
                                    </div>
                                </div>
                            </div>
                        `}

                        <!-- Individual Term Counts -->
                        <div style="margin-bottom: 15px;">
                            <h4 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 13px;">Individual Term Appearances</h4>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                ${searchTerms.map((term, idx) => `
                                    <div style="background: #ecf0f1; padding: 8px 12px; border-radius: 5px; font-size: 12px;">
                                        <strong>"${escapeHtml(term)}"</strong>: ${result.individualCounts[idx]} responses
                                        <span style="color: #7f8c8d;">(${(result.individualCounts[idx] / result.totalResponses * 100).toFixed(1)}%)</span>
                                        ${result.matchedVariations && result.matchedVariations[idx] ? `
                                            <div style="margin-top: 5px; font-size: 10px; color: #666;">
                                                <strong>Matched forms:</strong> ${result.matchedVariations[idx].slice(0, 8).map(v => escapeHtml(v)).join(', ')}${result.matchedVariations[idx].length > 8 ? ` +${result.matchedVariations[idx].length - 8} more` : ''}
                                            </div>
                                        ` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <!-- Metrics -->
                        ${!isSingleTerm ? `
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 15px;">
                                <div class="pattern-metric-badge">
                                    <span class="pattern-metric-label">Support</span>
                                    <span class="pattern-metric-value">${result.support}</span>
                                </div>
                                <div class="pattern-metric-badge">
                                    <span class="pattern-metric-label">Lift</span>
                                    <span class="pattern-metric-value" style="color: ${result.lift >= 4 ? '#e74c3c' : result.lift >= 2.5 ? '#f39c12' : '#3498db'};">
                                        ${result.lift > 0 ? result.lift.toFixed(2) + 'Ã—' : 'N/A'}
                                    </span>
                                </div>
                                <div class="pattern-metric-badge">
                                    <span class="pattern-metric-label">Confidence</span>
                                    <span class="pattern-metric-value">${(result.confidence * 100).toFixed(1)}%</span>
                                </div>
                            </div>
                        ` : ''}

                        <!-- Interpretation -->
                        ${result.support > 0 ? `
                            ${!isSingleTerm ? `
                                <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                                    <h4 style="margin: 0 0 8px 0; color: #2c3e50; font-size: 13px;">ðŸ“Š What This Means</h4>
                                    <p style="font-size: 13px; color: #555; line-height: 1.6; margin: 0;">
                                        If these terms appeared together <strong>by random chance</strong>, we'd expect to see them in
                                        <strong>~${result.expectedCount.toFixed(1)} responses</strong>.
                                        <br><br>
                                        They <strong>actually appear together</strong> in <strong>${result.support} responses</strong>.
                                        <br><br>
                                        ${result.lift > 1
                                            ? `This is <strong>${result.lift.toFixed(1)}Ã— more</strong> than random chance would predict.`
                                            : result.lift === 1
                                                ? 'This matches random chance exactly.'
                                                : 'This is less than random chance would predict.'}
                                    </p>
                                </div>
                            ` : ''}

                            <!-- Respondent List -->
                            <div style="margin-bottom: 15px;">
                                <h4 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 13px;">
                                    ${isSingleTerm
                                        ? `Respondents Using This Term (${respondentIds.length} / ${result.totalResponses})`
                                        : `Respondents Using All These Terms (${respondentIds.length})`}
                                </h4>
                                <div class="respondent-list search-result-chips" id="searchResultChips">
                                    ${respondentIds.slice(0, 30).map(id =>
                                        `<span class="respondent-chip search-chip" style="cursor: pointer; transition: opacity 0.2s;"
                                            data-respondent-id="${escapeHtml(String(id))}"
                                            onmouseover="this.style.opacity='0.7'"
                                            onmouseout="this.style.opacity='1'"
                                            title="Click to see all responses with search terms highlighted">
                                            ${escapeHtml(String(id))}
                                        </span>`
                                    ).join('')}
                                    ${respondentIds.length > 30 ? `<span class="respondent-chip">+${respondentIds.length - 30} more</span>` : ''}
                                </div>
                                <div style="font-size: 11px; color: #7f8c8d; margin-top: 8px;">
                                    ðŸ’¡ Click any respondent ID to view all responses in this group with search terms highlighted
                                </div>
                            </div>

                            <!-- Correlated Terms -->
                            ${result.correlatedTerms && result.correlatedTerms.length > 0 ? `
                                <div style="border-top: 2px solid #e0e0e0; padding-top: 15px;">
                                    <h4 style="margin: 0 0 10px 0; color: #2c3e50; font-size: 14px;">
                                        ðŸ”— Other Terms Frequently Appearing With Your Search
                                    </h4>
                                    <p style="font-size: 12px; color: #666; margin-bottom: 12px;">
                                        These terms/phrases appear alongside your search terms more than random chance would predict.
                                        Click any term to search for it.
                                    </p>
                                    <div style="display: flex; flex-direction: column; gap: 8px;">
                                        ${result.correlatedTerms.map((corr, idx) => {
                                            const liftColor = corr.lift >= 4 ? '#e74c3c' : corr.lift >= 2.5 ? '#f39c12' : '#3498db';
                                            const suspicionScore = corr.lift * Math.log(corr.support + 1);
                                            return `
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid ${liftColor}; cursor: pointer; transition: background 0.2s;"
                                                    onclick="document.getElementById('specificTermsInput').value = '${searchTerms.join(', ')}, ${escapeHtml(corr.term).replace(/'/g, "\\'")}'; searchSpecificTerms();"
                                                    onmouseover="this.style.background='#ecf0f1'"
                                                    onmouseout="this.style.background='#f8f9fa'">
                                                    <div style="flex: 1;">
                                                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 3px;">
                                                            ${idx + 1}. "${escapeHtml(corr.term)}"
                                                        </div>
                                                        <div style="font-size: 11px; color: #666;">
                                                            Appears in ${corr.support}/${result.support} matching responses
                                                            (${(corr.support / result.support * 100).toFixed(0)}%)
                                                            â€¢ Total occurrences: ${corr.totalOccurrences}
                                                        </div>
                                                    </div>
                                                    <div style="display: flex; gap: 8px; align-items: center;">
                                                        <div style="text-align: center;">
                                                            <div style="font-size: 10px; color: #7f8c8d; text-transform: uppercase; letter-spacing: 0.5px;">Lift</div>
                                                            <div style="font-size: 16px; font-weight: 700; color: ${liftColor};">
                                                                ${corr.lift.toFixed(1)}Ã—
                                                            </div>
                                                        </div>
                                                        <i class="fas fa-search" style="color: #57068C; font-size: 14px;"></i>
                                                    </div>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                    <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 4px; font-size: 11px; color: #1565c0;">
                                        ðŸ’¡ <strong>Tip:</strong> Click any term above to add it to your search and see how all terms correlate together.
                                    </div>
                                </div>
                            ` : ''}
                        ` : `
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 6px; text-align: center; color: #666;">
                                <i class="fas fa-info-circle" style="font-size: 36px; margin-bottom: 10px; opacity: 0.5;"></i>
                                <p style="margin: 0; font-size: 14px;">
                                    These terms do not appear together in any responses.
                                    Try searching for individual terms or different combinations.
                                </p>
                            </div>
                        `}
                    </div>
                </div>
            `;

            // Attach click handlers to search result chips after rendering
            setTimeout(() => {
                const searchChips = document.querySelectorAll('.search-chip');
                searchChips.forEach(chip => {
                    chip.onclick = function() {
                        showPatternRespondentMatches(this.dataset.respondentId, result.respondentIndices, searchTerms);
                    };
                });
            }, 100);
        }
    </script>
</body>
</html>
